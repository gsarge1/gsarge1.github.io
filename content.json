{"meta":{"title":"Valar Dohaeris","subtitle":"","description":"世上只有一种真正的英雄主义,那就是认清生活的真相后依然热爱生活","author":"烨钬","url":"http://example.com","root":"/"},"pages":[],"posts":[{"title":"javascript对象","slug":"javascript对象","date":"2022-05-26T02:54:56.000Z","updated":"2022-05-26T03:17:04.617Z","comments":true,"path":"2022/05/26/javascript对象/","link":"","permalink":"http://example.com/2022/05/26/javascript%E5%AF%B9%E8%B1%A1/","excerpt":"","text":"对象对象是一种复合值，它汇聚多个值并允许它们按名字存储和获取这些值。对象是一个属性的无序集合，每个属性都有名字和值。 1）创建对象对象可以通过对象字面量、new关键字和object.create()函数来创建。 对象字面量创建对象最简单的方式是js代码中直接包含对象字面量。对象字面量的最简单形式是包含在一对花括号中的一组逗号分隔的“键:值”对。属性名是js标识符或字符串字面量。属性值是任何js的表达式，这个表达式的值会变成属性的值。 12let empty = &#123;&#125;let point = &#123;x:0,y:0&#125; 使用New创建对象new操作符用于创建和初始化一个新对象。new关键字后面必须跟一个函数调用。以这种方式使用的函数被称为构造函数，目的是初始化新创建的对象。 12let o = new Object(); //&#123;&#125;let a = new Array();//[] Object.create()ECMAScript 5 定义了一个名为 Object.create() 的方法，它创建一个新对象，其中第一个参数是这个对象的原型。Object.create() 提供第二个可选参数，用以对对象的属性进行进一步描述。Object.create() 是一个静态函数，而不是提供给某个对象调用的方法。使用它的方法很简单，只须传入所需的原型对象即可。例如： 123var person = Object.create(Object.prototype);person.name = &quot;stone&quot;;person.age = 28; 其中 var person = Object.create(Object.prototype); 也等价于 var person = &#123;&#125;; 。 2）原型所有通过对象字面量创建的对象都具有同一个原型对象，并可以通过 JavaScript 代码 Object.prototype 获得对原型对象的引用。通过关键字 new 和构造函数调用创建的对象的原型就是构造函数的 prototype 属性的值。因此，同使用 &#123;&#125; 创建对象一样，通过 new Object() 创建的对象也继承自 Object.prototype。同样，通过 new Array() 创建的对象的原型就是 Array.prototype，通过 new Date() 创建的对象的原型就是 Date.prototype。 没有原型的对象为数不多，Object.prototype 就是其中之一。它不继承任何属性。其他原型对象都是普通对象，普通对象都具有原型。所有的内置构造函数（以及大部分自定义的构造函数）都具有一个继承自 Object.prototype 的原型。例如，Date.prototype 的属性继承自 Object.prototype，因此由 new Date() 创建的 Date 对象的属性同时继承自 Date.prototype 和 Object.prototype。 3）查询或设置属性前面有提到过，可以通过点 . 或方括号 [] 运算符来获取属性的值。对于点 . 来说，左侧应当是一个对象，右侧必须是一个以属性名称命名的简单标识符。对于方括号来说 [] ，方括号内必须是一个计算结果为字符串的表达式，这个字符串就是属性的名称。例如： 1234567// 推荐写法console.log(person.name); // &quot;stone&quot;console.log(person.age); // &quot;28&quot;// 也可以写成console.log(person[&quot;name&quot;]); // stoneconsole.log(person[&quot;age&quot;]); // 28 和获取属性的值写法一样，通过点和方括号也可以创建属性或给属性赋值，但需要将它们放在赋值表达式的左侧。例如： 123456789// 推荐写法person.name = &quot;sophie&quot;; // 赋值person.age = 30; // 赋值person.weight = 38; // 创建// 也可以写成person[&quot;name&quot;] = &quot;sophie&quot;; // 赋值person[&quot;age&quot;] = 30; // 赋值person[&quot;weight&quot;] = 38; // 创建 当使用方括号时，方括号内的表达式必须返回字符串。更严格地讲，表达式必须返回字符串或返回一个可以转换为字符串的值。 查看一个对象本身的所有属性，可以使用Object.keys方法。 1234567var obj = &#123; key1: 1, key2: 2&#125;;Object.keys(obj);// [&#x27;key1&#x27;, &#x27;key2&#x27;] 4）属性的访问错误查询一个不存在的属性并不会报错，如果在对象 o 自身的属性或继承的属性中均未找到属性 x，属性访问表达式 o.x 返回 undefined。例如： 12var person = &#123;&#125;;person.wife; // undefined 但是，如果对象不存在，那么试图查询这个不存在的对象的属性就会报错。null 和 undefined 值都没有属性，因此查询这些值的属性会报错。例如： 12var person = &#123;&#125;;person.wife.name; // Uncaught TypeError: Cannot read property &#x27;name&#x27; of undefined. 除非确定 person 和 person.wife 都是对象，否则不能这样写表达式 person.wife.name，因为会报「未捕获的错误类型」，下面提供了两种避免出错的方法： 123456789// 冗余但易懂的写法var name;if (person) &#123; if (person.wife) name = person.wife.name;&#125;// 简练又常用的写法（推荐写法）var name = person &amp;&amp; person.wife &amp;&amp; person.wife.name; 5）删除属性delete操作符用于从对象中移除属性。它唯一的操作数应该是一个属性访问表达式。 123456var obj = &#123; p: 1 &#125;;Object.keys(obj) // [&quot;p&quot;]delete obj.p // trueobj.p // undefinedObject.keys(obj) // [] 上面代码中，delete命令删除对象obj的p属性。删除后，再读取p属性就会返回undefined，而且Object.keys方法的返回值也不再包括该属性。 注意，删除一个不存在的属性，delete不报错，而且返回true。 12var obj = &#123;&#125;;delete obj.p // true 上面代码中，对象obj并没有p属性，但是delete命令照样返回true。因此，不能根据delete命令的结果，认定某个属性是存在的。 另外，需要注意的是，delete命令只能删除对象本身的属性，无法删除继承的属性。 123var obj = &#123;&#125;;delete obj.toString // trueobj.toString // function toString() &#123; [native code] &#125; 上面代码中，toString是对象obj继承的属性，虽然delete命令返回true，但该属性并没有被删除，依然存在。这个例子还说明，即使delete返回true，该属性依然可能读取到值。 6）检测属性JavaScript 对象可以看做属性的集合，我们经常会检测集合中成员的所属关系（判断某个属性是否存在于某个对象中）。可以通过 in 运算符、hasOwnPreperty() 和 propertyIsEnumerable() 来完成这个工作，甚至仅通过属性查询也可以做到这一点。 in 运算符的左侧是属性名（字符串），右侧是对象。如果对象的自有属性或继承属性中包含这个属性则返回 true。例如： 1234var o = &#123; x: 1 &#125;console.log(&quot;x&quot; in o); // true，x是o的属性console.log(&quot;y&quot; in o); // false，y不是o的属性console.log(&quot;toString&quot; in o); // true，toString是继承属性 对象的 hasOwnProperty() 方法用来检测给定的名字是否是对象的自有属性。对于继承属性它将返回 false。例如： 1234var o = &#123; x: 1 &#125;console.log(o.hasOwnProperty(&quot;x&quot;)); // true，x是o的自有属性console.log(o.hasOwnProperty(&quot;y&quot;)); // false，y不是o的属性console.log(o.hasOwnProperty(&quot;toString&quot;)); // false，toString是继承属性 propertyIsEnumerable() 是 hasOwnProperty() 的增强版，只有检测到是自有属性且这个属性的可枚举性（enumerable attribute）为 true 时它才返回 true。某些内置属性是不可枚举的。通常由 JavaScript 代码创建的属性都是可枚举的，除非在 ECMAScript 5 中使用一个特殊的方法来改变属性的可枚举性。例如： 12345var o = inherit(&#123; y: 2 &#125;);o.x = 1;o.propertyIsEnumerable(&quot;x&quot;); // true:，x是o的自有属性，可枚举o.propertyIsEnumerable(&quot;y&quot;); // false，y是继承属性Object.prototype.propertyIsEnumerable(&quot;toString&quot;); // false，不可枚举 除了使用 in 运算符之外，另一种更简便的方法是使用 !== 判断一个属性是否是 undefined。例如： 1234var o = &#123; x: 1 &#125;console.log(o.x !== undefined); // true，x是o的属性console.log(o.y !== undefined); // false，y不是o的属性console.log(o.toString !== undefined); // true，toString是继承属性 然而有一种场景只能使用 in 运算符而不能使用上述属性访问的方式。in 可以区分不存在的属性和存在但值为 undefined 的属性。例如： 1234567var o = &#123; x: undefined &#125; // 属性被显式赋值为undefinedconsole.log(o.x !== undefined); // false，属性存在，但值为undefinedconsole.log(o.y !== undefined); // false，属性不存在console.log(&quot;x&quot; in o); // true，属性存在console.log(&quot;y&quot; in o); // false，属性不存在console.log(delete o.x); // true，删除了属性xconsole.log(&quot;x&quot; in o); // false，属性不再存在 7）枚举属性除了检测对象的属性是否存在，我们还会经常遍历对象的属性。通常使用 for-in 循环遍历，ECMAScript 5 提供了两个更好用的替代方案。 for-in 循环可以在循环体中遍历对象中所有可枚举的属性（包括自有属性和继承的属性），把属性名称赋值给循环变量。对象继承的内置方法不可枚举的，但在代码中给对象添加的属性都是可枚举的。例如： 123456789101112var obj = &#123;a: 1, b: 2, c: 3&#125;;for (var i in obj) &#123; console.log(&#x27;键名：&#x27;, i); console.log(&#x27;键值：&#x27;, obj[i]);&#125;// 键名： a// 键值： 1// 键名： b// 键值： 2// 键名： c// 键值： 3 for...in循环有两个使用注意点。 它遍历的是对象所有可遍历（enumerable）的属性，会跳过不可遍历的属性。 它不仅遍历对象自身的属性，还遍历继承的属性。 举例来说，对象都继承了toString属性，但是for...in循环不会遍历到这个属性。 12345678var obj = &#123;&#125;;// toString 属性是存在的obj.toString // toString() &#123; [native code] &#125;for (var p in obj) &#123; console.log(p);&#125; // 没有任何输出 上面代码中，对象obj继承了toString属性，该属性不会被for...in循环遍历到，因为它默认是“不可遍历”的。关于对象属性 的可遍历性，参见《标准库》章节中 Object 一章的介绍。 如果继承的属性是可遍历的，那么就会被for...in循环遍历到。但是，一般情况下，都是只想遍历对象自身的属性，所以使 用for...in的时候，应该结合使用hasOwnProperty方法，在循环内部判断一下，某个属性是否为对象自身的属性。 12345678var person = &#123; name: &#x27;老张&#x27; &#125;;for (var key in person) &#123; if (person.hasOwnProperty(key)) &#123; console.log(key); &#125;&#125;// name 8）属性的 getter 和 setter我们知道，对象属性是由名字、值和一组特性（attribute）构成的。在 ECMAScript 5 中，属性值可以用一个或两个方法替代，这两个方法就是 getter 和 setter。由 getter 和 setter 定义的属性称做「存取器属性（accessor property）」，它不同于「数据属性（data property）」，数据属性只有一个简单的值。 当程序查询存取器属性的值时，JavaScript 调用 getter 方法。这个方法的返回值就是属性存取表达式的值。当程序设置一个存取器属性的值时，JavaScript 调用 setter 方法，将赋值表达式右侧的值当做参数传入 setter。从某种意义上讲，这个方法负责「设置」属性值。可以忽略 setter 方法的返回值。 和数据属性不同，存取器属性不具有可写性（writable attribute）。如果属性同时具有 getter 和 setter 方法，那么它是一个读&#x2F;写属性。如果它只有 getter 方法，那么它是一个只读属性。如果它只有 setter 方法，那么它是一个只写属性，读取只写属性总是返回 undefined。定义存取器属性最简单的方法是使用对象直接量语法的一种扩展写法。例如： 12345678var o = &#123; // 普通的数据属性 data_prop: value, // 存取器属性都是成对定义的函数 get accessor_prop() &#123; /*这里是函数体 */ &#125;, set accessor_prop(value) &#123; /* 这里是函数体*/ &#125;&#125;; 存取器属性定义为一个或两个和属性同名的函数，这个函数定义没有使用 function 关键字，而是使用 get 或 set。注意，这里没有使用冒号将属性名和函数体分隔开，但在函数体的结束和下一个方法或数据属性之间有逗号分隔。 9）序列化对象（JSON）对象序列化（serialization）是指将对象的状态转换为字符串，也可将字符串还原为对象。ECMAScript 5 提供了内置函数 JSON.stringify() 和 JSON.parse() 用来序列化和还原 JavaScript 对象。这些方法都使用 JSON 作为数据交换格式，JSON 的全称是「JavaScript 对象表示法（JavaScript Object Notation）」，它的语法和 JavaScript 对象与数组直接量的语法非常相近。例如： 123o = &#123;x:1, y:&#123;z:[false,null,&quot;&quot;]&#125;&#125;; // 定义一个对象s = JSON.stringify(o); // s是 &#x27;&#123;&quot;x&quot;:1,&quot;y&quot;:&#123;&quot;z&quot;:[false,null,&quot;&quot;]&#125;&#125;&#x27;p = JSON.parse(s); // p是o的深拷贝 ECMAScript 5 中的这些函数的本地实现和 https://github.com/douglascrockford/JSON-js 中的公共域 ECMAScript 3 版本的实现非常类似，或者说完全一样，因此可以通过引入 json2.js 模块在 ECMAScript 3 的环境中使用 ECMAScript 5 中的这些函数。 JSON 的语法是 JavaScript 语法的子集，它并不能表示 JavaScript 里的所有值。它支持对象、数组、字符串、无穷大数字、true、false 和 null，可以序列化和还原它们。NaN、Infinity 和 -Infinity 序列化的结果是 null，日期对象序列化的结果是 ISO 格式的日期字符串（参照 Date.toJSON() 函数），但 JSON.parse() 依然保留它们的字符串形态，而不会将它们还原为原始日期对象。函数、RegExp、Error 对象和 undefined 值不能序列化和还原。JSON.stringify() 只能序列化对象可枚举的自有属性。对于一个不能序列化的属性来说，在序列化后的输出字符串中会将这个属性省略掉。JSON.stringify() 和 JSON.parse() 都可以接收第二个可选参数，通过传入需要序列化或还原的属性列表来定制自定义的序列化或还原操作。","categories":[{"name":"javascript","slug":"javascript","permalink":"http://example.com/categories/javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://example.com/tags/javascript/"}]},{"title":"vue响应式原理","slug":"vue响应式原理","date":"2019-05-25T09:28:36.000Z","updated":"2022-05-26T00:05:45.015Z","comments":true,"path":"2019/05/25/vue响应式原理/","link":"","permalink":"http://example.com/2019/05/25/vue%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8E%9F%E7%90%86/","excerpt":"","text":"数据驱动 数据响应式、双向绑定、数据驱动 数据响应式 数据模型仅仅是普通的 JavaScript 对象，而当我们修改数据时，视图会进行更新，避免了繁琐的 DOM 操作提高开发效率 双向绑定 数据改变，视图改变;视图改变，数据也随之改变 我们可以使用 v-model 在表单元素上创建双向数据绑定 数据驱动是Vue最独特的特性之一，MVVM表示的是Model-View-ViewModel 开发过程中仅需要关注数据本身，不需要关心数据是如何渲染到视图 Model：模型层，负责处理业务逻辑以及和服务器端进行交互 View：视图层：负责将数据模型转化为UI展示出来，可以简单的理解为HTML页面 ViewModel：视图模型层，用来连接Model和View，是Model和View之间的通信桥梁 数据响应式的核心原理Vue 2.x 核心是通过 ES5 的保护对象的 Object.defindeProperty 中的访问器属性中的 get 和 set 方法，data 中声明的属性都被添加了访问器属性，当读取 data 中的数据时自动调用 get 方法，当修改 data 中的数据时，自动调用 set 方法，检测到数据的变化，会通知观察者 Wacher，观察者 Wacher自动触发重新render 当前组件（子组件不会重新渲染）,生成新的虚拟 DOM 树，Vue 框架会遍历并对比新虚拟 DOM 树和旧虚拟 DOM 树中每个节点的差别，并记录下来，最后，加载操作，将所有记录的不同点，局部修改到真实 DOM树上 总结：Vue 采用数据劫持结合发布—订阅模式的方法，通过 Object.defineProperty() 来劫持各个属性的 setter，getter，在数据变动时发布消息给订阅者，触发相应的监听回调 Object.defineProperty()，那么它的用法是什么，以及优缺点是什么呢？ 可以检测对象中数据发生的修改 对于复杂的对象，层级很深的话，是不友好的，需要经行深度监听，这样子就需要递归到底，这也是它的缺点。 对于一个对象中，如果你新增加属性，删除属性，Object.defineProperty()是不能观测到的，那么应该如何解决呢？可以通过Vue.set()和Vue.delete()来实现。 1234567891011121314151617181920212223242526272829303132// 模拟 Vue 中的 data 选项 let data = &#123; msg: &#x27;hello&#x27;&#125;// 模拟 Vue 的实例 let vm = &#123;&#125;// 数据劫持:当访问或者设置 vm 中的成员的时候，做一些干预操作Object.defineProperty(vm, &#x27;msg&#x27;, &#123; // 可枚举(可遍历) enumerable: true, // 可配置(可以使用 delete 删除，可以通过 defineProperty 重新定义) configurable: true, // 当获取值的时候执行 get () &#123; console.log(&#x27;get: &#x27;, data.msg) return data.msg &#125;, // 当设置值的时候执行 set (newValue) &#123; console.log(&#x27;set: &#x27;, newValue) if (newValue === data.msg) &#123; return &#125; data.msg = newValue // 数据更改，更新 DOM 的值 document.querySelector(&#x27;#app&#x27;).textContent = data.msg &#125; &#125;)// 测试vm.msg = &#x27;Hello World&#x27; console.log(vm.msg) Vue 3.x Vue3.x改用Proxy替代Object.defineProperty。因为Proxy可以直接监听对象和数组的变化，并且有多达13种拦截方法。并且作为新标准将受到浏览器厂商重点持续的性能优化。 12345678910111213141516171819202122232425262728293031const data = [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;]const proxyData = new Proxy(data, &#123; get(target, key, receiver) &#123; // 只处理本身（非原型的）属性 const ownKeys = Reflect.ownKeys(target) if (ownKeys.includes(key)) &#123; console.log(&#x27;get&#x27;, key) // 监听 &#125; const result = Reflect.get(target, key, receiver) return result // 返回结果 &#125;, set(target, key, val, receiver) &#123; // 重复的数据，不处理 if (val === target[key]) &#123; return true &#125; const result = Reflect.set(target, key, val, receiver) console.log(&#x27;set&#x27;, key, val) // console.log(&#x27;result&#x27;, result) // true return result // 是否设置成功 &#125;, deleteProperty(target, key) &#123; const result = Reflect.deleteProperty(target, key) console.log(&#x27;delete property&#x27;, key) // console.log(&#x27;result&#x27;, result) // true return result // 是否删除成功 &#125;&#125;) Reflect作用： 和proxy能力一一对应 规范化，标准化，函数式 代替Object上的工具函数 12345678910const obj = &#123;a: 100, b: 200&#125;&#x27;a&#x27; in obj //trueReflect.has(obj,&#x27;a&#x27;) //truedelete obj.a //trueReflect.deleteProperty(obj,&#x27;a&#x27;) //trueObject.getOwnPropertyNames(obj) //[&quot;a&quot;,&quot;b&quot;]Reflect.owbKeys(obj) //[&quot;a&quot;,&quot;b&quot;] proxy创建响应式 Proxy只会代理对象的第一层，那么Vue3又是怎样处理这个问题的呢？ 判断当前Reflect.get的返回值是否为Object，如果是则再通过reactive方法做代理， 这样就实现了深度观测。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172// 创建响应式function reactive(target = &#123;&#125;) &#123; if (typeof target !== &#x27;object&#x27; || target == null) &#123; // 不是对象或数组，则返回 return target &#125; // 代理配置 const proxyConf = &#123; get(target, key, receiver) &#123; // 只处理本身（非原型的）属性 const ownKeys = Reflect.ownKeys(target) if (ownKeys.includes(key)) &#123; console.log(&#x27;get&#x27;, key) // 监听 &#125; const result = Reflect.get(target, key, receiver) // 深度监听 // 性能如何提升的？ return reactive(result) &#125;, set(target, key, val, receiver) &#123; // 重复的数据，不处理 if (val === target[key]) &#123; return true &#125; const ownKeys = Reflect.ownKeys(target) if (ownKeys.includes(key)) &#123; console.log(&#x27;已有的 key&#x27;, key) &#125; else &#123; console.log(&#x27;新增的 key&#x27;, key) &#125; const result = Reflect.set(target, key, val, receiver) console.log(&#x27;set&#x27;, key, val) // console.log(&#x27;result&#x27;, result) // true return result // 是否设置成功 &#125;, deleteProperty(target, key) &#123; const result = Reflect.deleteProperty(target, key) console.log(&#x27;delete property&#x27;, key) // console.log(&#x27;result&#x27;, result) // true return result // 是否删除成功 &#125; &#125; // 生成代理对象 const observed = new Proxy(target, proxyConf) return observed&#125;// 测试数据const data = &#123; name: &#x27;zhangsan&#x27;, age: 20, info: &#123; city: &#x27;beijing&#x27;, a: &#123; b: &#123; c: &#123; d: &#123; e: 100 &#125; &#125; &#125; &#125; &#125;&#125;const proxyData = reactive(data) Proxy 相比于 defineProperty 的优势 数组变化也能监听到 不需要深度遍历监听","categories":[{"name":"vue","slug":"vue","permalink":"http://example.com/categories/vue/"}],"tags":[{"name":"vue","slug":"vue","permalink":"http://example.com/tags/vue/"}]},{"title":"javascript函数","slug":"javascript函数","date":"2017-05-26T03:24:17.000Z","updated":"2022-05-26T03:44:11.044Z","comments":true,"path":"2017/05/26/javascript函数/","link":"","permalink":"http://example.com/2017/05/26/javascript%E5%87%BD%E6%95%B0/","excerpt":"","text":"函数函数是一个代码块，定义之后，可以被执行或调用任意多次。Js函数是参数化的，即函数定义可以包含一组标识符，称为参数或形参。 定义函数在Js中定义函数最直观的方式就是使用function关键字，这个关键字可以用作声明或表达式。 命名函数的标识符 一对圆括号，中间包含逗号分隔的零或多个标识符。 一对花括号，其中包含零或多个Js语句。 123function 函数名(参数,参数2,......)&#123; 表达式&#125; 例如，这段代码定义了square，来引用一个函数，它产生给定数字的平方： 123456const square = function(x) &#123; return x * x;&#125;;console.log(square(12));// → 144 变量和作用域每个变量都有一个作用域，它是程序的一部分，其中变量是可见的。 对于在任何函数或块之外定义的变量，作用域是整个程序 - 您可以在任何地方引用这种变量。它们被称为全局的。 但是为函数参数创建的，或在函数内部声明的变量，只能在该函数中引用，所以它们被称为局部变量。 每次调用该函数时，都会创建这些变量的新实例。 这提供了函数之间的一些隔离 - 每个函数调用，都在它自己的小世界（它的局部环境）中运行，并且通常可以在不知道全局环境中发生的事情的情况下理解。 用let和const声明的变量，实际上是它们的声明所在的块的局部对象，所以如果你在循环中创建了一个，那么循环之前和之后的代码就不能“看见”它。JavaScript 2015 之前，只有函数创建新的作用域，因此，使用var关键字创建的旧式变量，在它们出现的整个函数中内都可见，或者如果它们不在函数中，在全局作用域可见。 12345678910let x = 10;if (true) &#123; let y = 20; var z = 30; console.log(x + y + z); // → 60&#125;// y is not visible hereconsole.log(x + z);// → 40 每个作用域都可以“向外查看”它周围的作用域，所以示例中的块内可以看到x。 当多个变量具有相同名称时例外 - 在这种情况下，代码只能看到最内层的那个。 例如，当halve函数中的代码引用n时，它看到它自己的n，而不是全局的n。 12345678const halve = function(n) &#123; return n / 2;&#125;let n = 10;console.log(halve(100));// → 50console.log(n);// → 10 嵌套作用域JavaScript 不仅区分全局和局部变量。 块和函数可以在其他块和函数内部创建，产生多层局部环境。 例如，这个函数的内部有另一个函数： 123456789101112131415const hummus = function(factor) &#123; const ingredient = function(amount, unit, name) &#123; let ingredientAmount = amount * factor; if (ingredientAmount &gt; 1) &#123; unit += &quot;s&quot;; &#125; console.log(`$&#123;ingredientAmount&#125; $&#123;unit&#125; $&#123;name&#125;`); &#125;; ingredient(1, &quot;can&quot;, &quot;chickpeas&quot;); ingredient(0.25, &quot;cup&quot;, &quot;tahini&quot;); ingredient(0.25, &quot;cup&quot;, &quot;lemon juice&quot;); ingredient(1, &quot;clove&quot;, &quot;garlic&quot;); ingredient(2, &quot;tablespoon&quot;, &quot;olive oil&quot;); ingredient(0.5, &quot;teaspoon&quot;, &quot;cumin&quot;);&#125;; ingredient函数中的代码，可以从外部函数中看到factor变量。 但是它的局部变量，比如unit或ingredientAmount，在外层函数中是不可见的。 简而言之，每个局部作用域也可以看到所有包含它的局部作用域。 块内可见的变量集，由这个块在程序文本中的位置决定。 每个局部作用域也可以看到包含它的所有局部作用域，并且所有作用域都可以看到全局作用域。 这种变量可见性方法称为词法作用域。 作为值的函数函数变量通常只充当程序特定部分的名称。 这样的变量被定义一次，永远不会改变。 这使得容易混淆函数和名称。 123456let launchMissiles = function(value) &#123; missileSystem.launch(&quot;now&quot;);&#125;;if (safeMode) &#123; launchMissiles = function() &#123;/* do nothing */&#125;;&#125; 箭头函数箭头函数的一般形式是圆括号中逗号分隔的参数列表，后跟箭头&#x3D;&gt;，再跟包含在花括号中的函数体： 1const sum = (x,y) =&gt;&#123;return x+y&#125; 调用函数语法： 123456function add(参数,参数2....)&#123;&#125;调用方法：add(参数,参数2....) 对象中方法调用 12345678let calculator = &#123; operand1 : 1, operand2 : 2, add()&#123; this.result = this.operand1 + this.operand2 &#125;&#125;calculator.add(); this关键字不具有变量那样的作用域机制，除了箭头函数，嵌套函数不会继承包含函数的this值。如果嵌套函数被当做方法来调用，那它的this值就是调用它的对象。 可选参数与默认值当调用函数时传入的实参少于声明的形参时，额外的形参会获得默认值，通常是undefined. 1234567891011121314//把对象o的可枚举属性名放到数组a中，返回a//如果不传a,则创建一个新数组function getPropertyNames(o,a)&#123; if(a === undefined)&#123; a = []; &#125; for(let property in o)&#123; a.push(property) &#125; return a;&#125;let o = &#123;x:1&#125;,p=&#123;y:2,z:3&#125;let a = getPropertyNames(o);getPropertyNames(p,a); 现在可以直接在函数形参列表中为每个参数定义默认值。语法是形参名后面加上等于号和默认值，这样在没有给该形参传值时就会使用这个默认值。 123456function getPropertyNames(o ,a = [])&#123; for(let property in o)&#123; a.push(property) &#125; return a;&#125; 闭包闭包（closure）就是能够读取其他函数内部变量的函数。 由于在Javascript语言中，只有函数内部的子函数才能读取局部变量，因此可以把闭包简单理解成”定义在一个函数内部的函数”。 所以，在本质上，闭包就是将函数内部和函数外部连接起来的一座桥梁。 变量作用域要理解闭包，首先必须理解Javascript特殊的变量作用域。 变量的作用域无非就是两种：全局变量和局部变量。 Javascript语言的特殊之处，就在于函数内部可以直接读取全局变量。 12345var n=999;function f1()&#123; alert(n);&#125;f1(); // 999 另一方面，在函数外部自然无法读取函数内的局部变量。 12345function f1()&#123; var n=999;&#125;alert(n); // error 这里有一个地方需要注意，函数内部声明变量的时候，一定要使用var命令。如果不用的话，你实际上声明了一个全局变量！ 1234567function f1()&#123; n=999;&#125;f1();alert(n); // 999 如何从外部获取内部变量出于种种原因，我们有时候需要得到函数内的局部变量。但是，前面已经说过了，正常情况下，这是办不到的，只有通过变通方法才能实现。 那就是在函数的内部，再定义一个函数。 1234567function f1()&#123; var n=999; function f2()&#123; alert(n); // 999 &#125;&#125; 在上面的代码中，函数f2就被包括在函数f1内部，这时f1内部的所有局部变量，对f2都是可见的。但是反过来就不行，f2内部的局部变量，对f1就是不可见的。这就是Javascript语言特有的”链式作用域”结构（chain scope），子对象会一级一级地向上寻找所有父对象的变量。所以，父对象的所有变量，对子对象都是可见的，反之则不成立。 既然f2可以读取f1中的局部变量，那么只要把f2作为返回值，我们不就可以在f1外部读取它的内部变量了吗！ 123456789101112131415function f1()&#123; var n=999; function f2()&#123; alert(n); &#125; return f2;&#125;var result=f1();result(); // 999 闭包的用途闭包可以用在许多地方。它的最大用处有两个，一个是前面提到的可以读取函数内部的变量，另一个就是让这些变量的值始终保持在内存中。 123456789101112131415161718192021function f1()&#123; var n=999; nAdd=function()&#123;n+=1&#125; function f2()&#123; alert(n); &#125; return f2;&#125;var result=f1();result(); // 999nAdd();result(); // 1000 在这段代码中，result实际上就是闭包f2函数。它一共运行了两次，第一次的值是999，第二次的值是1000。这证明了，函数f1中的局部变量n一直保存在内存中，并没有在f1调用后被自动清除。 为什么会这样呢？原因就在于f1是f2的父函数，而f2被赋给了一个全局变量，这导致f2始终在内存中，而f2的存在依赖于f1，因此f1也始终在内存中，不会在调用结束后，被垃圾回收机制（garbage collection）回收。 这段代码中另一个值得注意的地方，就是”nAdd&#x3D;function(){n+&#x3D;1}”这一行，首先在nAdd前面没有使用var关键字，因此nAdd是一个全局变量，而不是局部变量。其次，nAdd的值是一个匿名函数（anonymous function），而这个匿名函数本身也是一个闭包，所以nAdd相当于是一个setter，可以在函数外部对函数内部的局部变量进行操作。 立即执行函数立即执行函数通常有下面两种写法： 12345678//第一种写法(function()&#123; ...&#125;)();//第二种写法(function()&#123; ...&#125;()); 立即执行函数的作用 立即执行函数只有一个作用：创建一个独立的作用域。这个作用域里面的变量，外面访问不到（即避免了「变量污染」）。 123456var liList = ul.getElementsByTagName(&#x27;li&#x27;)for(var i=0; i&lt;6; i++)&#123; liList[i].onclick = function()&#123; alert(i) // 为什么 alert 出来的总是 6，而不是 0、1、2、3、4、5 &#125;&#125; 因为输出的 i 是全局作用域的，当循环结束后 i 的值是 6，所以输出的 i 就是6。 用立即执行函数可以解决这个问题。 12345678var liList = document.getElementsByTagName(&#x27;li&#x27;);for(var i=0; i&lt;6; i++)&#123; (function(j)&#123; liList[j].onclick = function()&#123; alert(j) // 0、1、2、3、4、5 &#125; &#125;)(i)&#125; 因为 JS 中调用函数传递参数都是值传递 ，所以当立即执行函数执行时，首先会把参数 i 的值复制一份，然后再创建函数作用域来执行函数，循环5次就会创建5个作用域，所以每个 li 元素访问的都是不同作用域的 i 的值 。","categories":[{"name":"javascript","slug":"javascript","permalink":"http://example.com/categories/javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://example.com/tags/javascript/"}]},{"title":"javascript数组","slug":"javascript数组","date":"2017-05-14T03:24:06.000Z","updated":"2022-05-26T03:35:00.165Z","comments":true,"path":"2017/05/14/javascript数组/","link":"","permalink":"http://example.com/2017/05/14/javascript%E6%95%B0%E7%BB%84/","excerpt":"","text":"数组数组是值的有序集合。每个值叫做一个元素，而每个元素在数组中有一个位置，以数字表示，称为索引。 JavaScript 数组是无类型的，数组元素可以是任意类型，并且同一个数组中的不同元素也可能有不同的类型。数组的元素甚至也可能是对象或其他数组。 JavaScript 数组是动态的，根据需要它们会增长或缩减，并且在创建数组时无须声明一个固定的大小或者在数组大小变化时无须重新分配空间。 JavaScript 数组可能是稀疏的，数组元素的索引不一定要连续的，它们之间可以有空缺。每个 JavaScript 数组都有一个 length 属性。针对非稀疏数组，该属性就是数组元素的个数。针对稀疏数组，length 比所有元素的索引要大。 JavaScript 数组是 JavaScript 对象的特殊形式，数组索引实际上和碰巧是整数的属性名差不多。通常，数组的实现是经过优化的，用数字索引来访问数组元素一般来说比访问常规的对象属性要快很多。 数组继承自 Array.prototype 中的属性，它定义了一套丰富的数组操作方法。 1）创建数组1）数组字面量 12345678910var empty = []; // 没有元素的数组var primes = [2, 3, 5, 7, 11]; // 有5个数值的数组var misc = [1.1, true, &quot;a&quot;]; // 3个不同类型的元素// 数组直接量中的值不一定要是常量，可以是任意的表达式var base = 1024;var table = [base, base+1, base+2, base+3];// 也可以包含对象直接量或其他数组直接量var b = [[1, &#123;x:1, y:2&#125;], [2, &#123;x:3, y:4&#125;]]; 注意，不要忽略数组字面量的最后一个元素，仅以逗号结尾。下面几个案例，在不同的浏览器下，可能会被识别成2个元素，也有可能识别成3个元素，而造成程序bug。例如： 123var nums = [,,,]; // 不好的写法var names = [&quot;stone&quot;,,]; // 不好的写法var colors = [&quot;red&quot;,&quot;green&quot;,]; // 不好的写法 2）通过new Array()创建 12345678// 调用时没有参数var a = new Array();// 调用时有一个数值参数，它指定长度var a = new Array(10); // 显式指定多个数组元素或者数组的一个非数值元素var a = new Array(5, 4, 3, 2, 1, &quot;testing&quot;); 2）数组的读写使用 [] 操作符来访问数组中的一个元素。数组的引用位于方括号的左边。方括号中是一个返回非负整数值的任意表达式。使用该语法既可以读又可以写数组的一个元素。例如： 1234567var a = [&quot;world&quot;]; // 从一个元素的数组开始var value = a[0]; // 读第0个元素a[1] = 3.14; // 写第1个元素var i = 2; a[i] = 3; // 写第2个元素a[i + 1] = &quot;hello&quot;; // 写第3个元素a[a[i]] = a[0]; // 读第0个和第2个元素，写第3个元素 请记住，数组是对象的特殊形式，可以为其创建任意名字的属性。但如果使用的属性是数组的索引，数组的特殊行为就是将根据需要更新它们的length属性值。 注意，可以使用负数或非整数来索引数组。这种情况下，数值转换为字符串，字符串作为属性名来用。既然名字不是非负整数，它就只能当做常规的对象属性，而非数组的索引。同样，如果凑巧使用了是非负整数的字符串，它就当做数组索引，而非对象属性。当使用的一个浮点数和一个整数相等时情况也是一样的。例如： 123a[-1.23] = true; // 这将创建一个名为&quot;-1.23&quot;的属性a[&quot;1000&quot;] = 0; // 这是数组的第1001个元素a[1.000] // 和 a[1] 相等 事实上数组索引仅仅是对象属性名的一种特殊类型，这意味着 JavaScript 数组没有「越界」错误的概念。当试图查询任何对象中不存在的属性时，不会报错，只会得到 undefined 值。 3）稀疏数组稀疏数组就是包含从0开始的不连续索引的数组。通常，数组的 length 属性值代表数组中元素的个数。如果数组是稀疏的，length 属性值大于元素的个数。可以用 Array() 构造函数或简单地指定数组的索引值大于当前的数组长度来创建稀疏数组。 123a = new Array(5); // 数组没有元素，但是 a.length = 5a = []; // 创建一个空数组，a.length = 0a[1000] = 0; // 添加一个元素，a.length 被自动更新为1001 足够稀疏的数组通常在实现上比稠密的数组更慢、内存利用率更高，在这样的数组中查找元素的时间与常规对象属性的查找时间一样长。 需要注意的是，当省略数组直接量中的值时（使用连续的逗号，比如 [1,,3] ），这时所得到的数组也是稀疏数组，省略掉的值是不存在的： 1234var a1 = [,&#x27;1&#x27;,&#x27;2&#x27;]; // 此数组长度是3 var a2 = [undefined]; // 此数组包含一个值为 undefined 的元素 console.log(0 in a1); // false，a1 在索引0处没有元素console.log(0 in a2); // true，a2 在索引0处有一个值为 undefined 的元素 了解稀疏数组是了解 JavaScript 数组的真实本质的一部分。尽管如此，实际上你所碰到的绝大多数 JavaScript 数组不是稀疏数组。并且，如果你确实碰到了稀疏数组，你的代码很可能像对待非稀疏数组一样来对待它们，只不过它们包含一些 undefined 值。 4）数组的长度每个数组有一个 length 属性，就是这个属性使其区别于常规的 JavaScript 对象。针对稠密（也就是非稀疏）数组，length 属性值代表数组中元素的个数。其值比数组中最大的索引大1。例如： 12[].length // 0，数组没有元素[&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;].length // 3，最大的索引为2，length 为3 当数组是稀疏的时，length 属性值大于元素的个数。而且关于此我们可以说的一切也就是数组长度保证大于它每个元素的索引值。或者，换一种说法，在数组中（无论稀疏与否）肯定找不到一个元素的索引值大于或等于它的长度。为了维持此规则不变化，数组有两个特殊的行为。 第一个如同上面的描述：如果为一个数组元素赋值，它的索引 i 大于或等于现有数组的长度时，length 属性的值将设置为 i+1。 第二个特殊的行为就是设置 length 属性为一个小于当前长度的非负整数 n 时，当前数组中那些索引值大于或等于 n 的元素将从中删除。例如： 1234a = [1,2,3,4,5]; // 从5个元素的数组开始a.length = 3; // 现在 a 为[1,2,3]a.length = 0; // 删除所有的元素。a 为[ ]a.length = 5; // 长度为5，但是没有元素，就像 new Array(5) 还可以将数组的 length 属性值设置为大于其当前的长度。实际上这不会向数组中添加新的元素，它只是在数组尾部创建一个空的区域。 在 ECMAScript 5 中，可以用 Object.defineProperty() 让数组的 length 属性变成只读的。例如： 123a = [1,2,3]; // 从3个元素的数组开始Object.defineProperty(a, &quot;length&quot;, &#123;writable: false&#125;); // 让 length 属性只读a.length = 0; // a 不会改变 5）添加或删除数组元素push():向数组末尾添加一个或多个元素 123let a = [];a.push(&#x27;one&#x27;);a.push(&#x27;two&#x27;,&#x27;three&#x27;) pop():删除数组最后一个元素并返回该元素。 12let a = [&#x27;one&#x27;,&#x27;two&#x27;,&#x27;three&#x27;];a.pop(); shift():删除并返回数组的第一个元素 12let a = [&#x27;one&#x27;,&#x27;two&#x27;,&#x27;three&#x27;];a.shift(); unshift():想数组首位添加一个元素 123let a = [&#x27;one&#x27;,&#x27;two&#x27;,&#x27;three&#x27;];a.unshift(&#x27;four&#x27;);a.unshift(&#x27;five&#x27;,&#x27;six&#x27;); splice(index,num): 从下标index位置开始，删除num个元素 12let color = [&#x27;red&#x27;,&#x27;yellow&#x27;,&#x27;green&#x27;,&#x27;pink&#x27;];let b = color.splice(1,2);//从下标1的位置，删除两项，并将调用splice放的返回值存放在变量b中 arr.splice(index,0,val1,val2..):在下标index位置，添加多个元素 12let color = [&#x27;red&#x27;,&#x27;yellow&#x27;,&#x27;green&#x27;,&#x27;pink&#x27;];console.log(color.splice(1,0,&#x27;#fff&#x27;,&#x27;#000&#x27;)) arr.splice(index,num,val1,val2…):先删除后添加; 从index 位置开始，先删除num个元素，再添加多个新元素； 12let color = [&#x27;red&#x27;,&#x27;yellow&#x27;,&#x27;green&#x27;,&#x27;pink&#x27;];let result = color.splice(2,2,&#x27;black&#x27;,&#x27;white&#x27;) 6）数组迭代使用 for 循环是遍历数组元素最常见的方法。例如： 123456var keys = Object.keys(o); // 获得 o 对象属性名组成的数组var values = [] // 在数组中存储匹配属性的值for(var i = 0; i &lt; keys.length; i++) &#123; // 对于数组中每个索引 var key = keys[i]; // 获得索引处的键值 values[i] = o[key]; // 在 values 数组中保存属性值&#125; 在嵌套循环或其他性能非常重要的上下文中，可以看到这种基本的数组遍历需要优化，数组的长度应该只查询一次而非每次循环都要查询。例如： 123for(var i = 0, len = keys.length; i &lt; len; i++) &#123; // 循环体仍然不变&#125; 这些例子假设数组是稠密的，并且所有的元素都是合法数据。否则，使用数组元素之前应该先检测它们。例如： 123456for(var i = 0; i &lt; a.length; i++) &#123; if (!a[i]) continue; // 跳过 null、undefined 和不存在的元素 if (!(i in a)) continue ; // 跳过不存在的元素 if (a[i] === undefined) continue; // 跳过 undefined 和不存在的元素 // 循环体&#125; 还可以使用 for-in 循环处理稀疏数组。循环每次将一个可枚举的属性名（包括数组索引）赋值给循环变量，不存在的索引将不会遍历到。例如： 1234for(var index in sparseArray) &#123; var value = sparseArray[index]; // 此处可以使用索引和值做一些事情&#125; 但由于 for-in 循环能够枚举继承的属性名，如添加到 Array.prototype 中的方法。基于这个原因，在数组上不应该使用 for-in 循环，除非使用额外的检测方法来过滤不想要的属性。例如： 1234567for(var i in a) &#123; // 跳过继承的属性 if (!a.hasOwnProperty(i)) continue; // 跳过不是非负整数的 i if (String(Math.floor(Math.abs(Number(i)))) !== i) continue;&#125; JavaScript 规范允许 for-in 循环以不同的顺序遍历对象的属性。通常数组元素的遍历实现是升序的，但不能保证一定是这样的。如果数组同时拥有对象属性和数组元素，返回的属性名很可能是按照创建的顺序而非数值的大小顺序。如何处理这个问题的实现，各个浏览器都不相同，如果算法依赖于遍历的顺序，那么最好不要使用 for-in 而用常规的 for 循环。 forEach():迭代数组的每个元素，并对每个元素都调用一次指定的函数。 12345678let data = [1,2,3,4,5,6,7],sum = 0;data.forEach(function(item)&#123; sum +=item;&#125;)或data.forEach(item=&gt;&#123; sum +=item;&#125;) map():把调用它的数组的每个元素分别传给指定的函数，返回这个函数的返回值构成的数组。 123let a = [1,2,3];let result = a.map(x =&gt; x*x)console.log(result) filter():返回一个数组，该数组包含调用它的数组的子数组。 123let a = [1,2,3,4,5,6,7,8];let result = a.filter(x=&gt;x&lt;3)let res = a.filter((x,i) =&gt; i%2===0); **some()**：类似于数学上的“存在”量词，只要数组元素中有一个让断言函数返回true它就返回true,但必须数组的所有元素对断言函数都返回false才返回false. 123let a = [1,2,3,4,5]a.some(x=&gt;x%2===0);a.some(isNaN) every():与数学上的全称量词类似，它在且只有断言函数对数组的所有元素都返回true时才返回true 123let a = [1,2,3,4,5];a.every(x=&gt;x&lt;10)a.every(x=&gt; x%2 ===0); 7）数组检测给定一个未知的对象，判定它是否为数组通常非常有用。在 ECMAScript 5 中，可以使用 Array.isArray() 函数来做这件事情。例如： 12Array.isArray([]) // trueArray.isArray(&#123;&#125;) // false 但是，在 ECMAScript 5 以前，要区分数组和非数组对象很困难。typeof 运算符对数组返回 &quot;object&quot;（并且对于除了函数以外的所有对象都是如此）。instanceof 操作符也只能用于简单的情形。例如： 12[] instanceof Array // true(&#123;&#125;) instanceof Array // false 使用 instanceof 的问题是在 Web 浏览器中有可能有多个窗体存在。每个窗体都有自己的 JavaScript 环境，有自己的全局对象。并且，每个全局对象有自己的一组构造函数。因此一个窗体中的对象将不可能是另外窗体中的构造函数的实例。窗体之间的混淆不常发生，但这个问题足已证明 instanceof 操作符不能视为一个可靠的数组检测方法。 解决方案是检查对象的类属性，对数组而言该属性的值总是 &quot;Array&quot;，因此在 ECMAScript 3 中 isArray() 函数的代码可以这样书写。例如： 123var isArray = Array.isArray || function(o) &#123; return typeof o === &quot;object&quot; &amp;&amp; Object.prototype.toString.call(o) === &quot;[object Array]&quot;;&#125;; 8）反转数组reverse():数组反转 12let a = [1,2,3,4,5]a.reverse(); 9）数组排序sort():数组的排序语法：arr.sort(function(a,b){return a-b}); 1234567891011121314升序var arr = [34,7,23,9,5];arr.sort(function(a,b)&#123; return a-b;&#125;)降序var arr = [34,7,23,9,5];arr.sort(function(a,b)&#123; return b-a;&#125;)不传参：按照ASCII码排序var arr = [34,7,23,9,5];arr.sort();console.log(arr); 10）数组合并**concat()**：将多个数组内容拿出来，合并成一个新数组； 语法：arr.concat(arr,arr1,arr2,….) 123var arr = [&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;,&#x27;d&#x27;];var arr2 = [1,2,3];console.log(arr.concat(arr2)); 11）数组的截取slice():返回截取的内容 slice的截取时，包含开始位置，不包含截取位置； arr.slice(start,end);&#x2F;&#x2F;从开始start位置截取到end位置，不包含结束位置 arr.slice(start);&#x2F;&#x2F;从开始位置一直截取最后 arr.slice();&#x2F;&#x2F;不传参：表示，截取整个数组； slice();支持负值； slice()不会改变原数组 123456789101112传两个参数：var color = [&#x27;pink&#x27;,&#x27;red&#x27;,&#x27;yellow&#x27;,&#x27;blue&#x27;,&#x27;green&#x27;];console.log(color.slice(1,3))//从下标1开始截取到下标3，不包含下标3传一个参数var color = [&#x27;pink&#x27;,&#x27;red&#x27;,&#x27;yellow&#x27;,&#x27;blue&#x27;,&#x27;green&#x27;];var a = color.slice(1);//参数1表示从下标1开始一直截取到最后不传参var color = [&#x27;pink&#x27;,&#x27;red&#x27;,&#x27;yellow&#x27;,&#x27;blue&#x27;,&#x27;green&#x27;];var b = color.slice();//不传参，表示全部截取，将截取结果赋值给b参数为负值var color = [&#x27;pink&#x27;,&#x27;red&#x27;,&#x27;yellow&#x27;,&#x27;blue&#x27;,&#x27;green&#x27;];var c = color.slice(-3,4);//坐标= 负值+数组长度 -3+5 = 2(2,4) 12）数组索引indexOf():从数组前向后中搜索指定的值并返回第一个找到的元素的索引，如果没找到则返回-1. 123var color = [&#x27;pink&#x27;,&#x27;red&#x27;,&#x27;yellow&#x27;,&#x27;blue&#x27;,&#x27;green&#x27;];console.log(color.indexOf(&#x27;red&#x27;)) lastIndexOf():从数组后向前中搜索指定的值并返回第一个找到的元素的索引，如果没找到则返回-1. 12var color = [&#x27;pink&#x27;,&#x27;red&#x27;,&#x27;yellow&#x27;,&#x27;blue&#x27;,&#x27;green&#x27;];console.log(color.lastIndexOf(&#x27;red&#x27;)) 13）数组转字符串join():将数组的每一项通过连接符，拼接为一个新字符串； 12var color = [&#x27;pink&#x27;,&#x27;red&#x27;,&#x27;yellow&#x27;,&#x27;blue&#x27;,&#x27;green&#x27;];console.log(color.join(&#x27;,&#x27;))","categories":[{"name":"javascript","slug":"javascript","permalink":"http://example.com/categories/javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://example.com/tags/javascript/"}]},{"title":"javascript字符串","slug":"javascript字符串","date":"2017-05-05T03:19:08.000Z","updated":"2022-05-26T03:25:39.946Z","comments":true,"path":"2017/05/05/javascript字符串/","link":"","permalink":"http://example.com/2017/05/05/javascript%E5%AD%97%E7%AC%A6%E4%B8%B2/","excerpt":"","text":"String对象字符串的拼接可以使用“+”操作符 1let msg = &quot;Hello&quot; + &quot;World&quot;; 可以使用标准的全等&#x3D;&#x3D;&#x3D;和不全等!&#x3D;&#x3D;操作符进行字符串比较。 字符串也可以使用&lt;、&lt;&#x3D;、&gt;和&gt;&#x3D;操作符来比较，字符串比较是通过比较16位值完成的。 1）length:字符串长度12var s = &quot;hello world&quot;;console.log(s.length) 2）截取字符串1234var s = &quot;Hello World&quot;;s.substring(1,4);//取第2-4个字符s.slice(1,4);//同上s.slice(-3);最后3个字符 3）拆分字符串12var s = &quot;Hello,World&quot;;s.split(&quot;,&quot;);//[&quot;Hello&quot;,&quot;World&quot;]从定界符处拆开 4）搜索字符串1234var s = &quot;Hello World&quot;;s.indexOf(&quot;l&quot;); //第一个字母l的位置s.indexOf(&quot;l&quot;,3);//位置3后面第一个&quot;l&quot;的位置s.indexOf(&quot;zz&quot;);// -1,s并不包含子串&quot;zz&quot; 5）从后向前搜索字符串。12var s = &quot;Hello World&quot;;s.lastIndexOf(&#x27;l&#x27;)// 9 6）字符串已那些字符开头或结尾1234var s = &quot;Hello World&quot;;s.startWith(&quot;Hell&quot;);=&gt;trues.endWith(&quot;!&quot;)=&gt;falses.includes(&quot;or&quot;) ;=&gt;true 7）替换与正则表达式匹配的子串12var s = &quot;Hello World&quot;;s.replace(&quot;llo&quot;,&#x27;ya&#x27;) 8）把字符串转换为小写123var s = &quot;HELLO WORLD&quot;;s.toLowerCase();s.toLocaleLowerCase() 9）把字符串转换为大写123var s = &quot;hello world&quot;;s.toUpperCase();s.toLocaleUpperCase() 10）返回在指定位置的字符12var s = &quot;Hello World&quot;;s.charAt(0) 11）从起始索引号提取字符串中指定数目的字符12var str=&quot;Hello world!&quot;document.write(str.substr(3)) =&gt;lo world! 12）去除空格1234var s =&quot; Hello World &quot;;s.trim();//删除两侧空格s.trimStart();//删除左侧空格s.trimEnd();//删除右侧空格 13) 字符串填充123var s =&quot;Hello World&quot;;s.padStart(3,&#x27;*&#x27;);//左侧填充三个*s.padEnd(3,&#x27;*&#x27;);//右侧填充三个*","categories":[{"name":"javascript","slug":"javascript","permalink":"http://example.com/categories/javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://example.com/tags/javascript/"}]},{"title":"javascript语句","slug":"javascript语句","date":"2017-05-03T01:34:16.000Z","updated":"2022-05-26T02:55:59.511Z","comments":true,"path":"2017/05/03/javascript语句/","link":"","permalink":"http://example.com/2017/05/03/javascript%E8%AF%AD%E5%8F%A5/","excerpt":"","text":"语句表达式在 JavaScript 中是短语，那么语句就是整句命令。表达式用来计算出一个值，语句用来执行以使某件事发生。从本质上看，语句定义了 JavaScript 中的主要语法，语句通常使用一或多个关键字来完成给定任务。语句可以很简单，例如通知函数退出；也可以比较复杂，例如指定重复执行某个命令的次数。下表列出了 JavaScript 大部分语句的语法和用途： 语句 语法 用途 break break [label]; 退出最内层循环或者退出 switch 语句，又或者退出 label 指定的语句 case case expression: 在 switch 语句中标记一条语句 continue continue [label]; 重新开始最内层的循环或重新开始 label 指定的循环 debugger debugger; 断点器调试 default default; 在 switch 中标记默认的语句 do-while do statement while(expression); while 循环的一种替代形式 empty ; 什么都不做 for for(init;expr;incr) statement 简写的循环结构 for-in for(var in object) statement 遍历一个对象的属性 function function name([param[],...])&#123;statement&#125; 声明一个函数 if-else if (expression) statement1[else statement2] 执行 statement1 或者 statement2 label label:statement 给 statement 指定一个名字 label return return [expression]; 从函数返回一个值 switch switch(expression)&#123;statement&#125; 用 case 或者 default 语句标记的多分支语句 throw throw expression; 抛出异常 try try &#123;statement&#125;[catch &#123;handler statement&#125;][finally &#123;cleaup statement&#125;] 捕获异常 use strict &quot;use strict&quot; 对脚本和函数应用严格模式 var var name=[=expr][,...]; 声明并初始化一个或多个变量 while while(expression) statement 基本的循环结构 with with(object) statement 扩展作用域链 1)条件语句if-else 语句大多数编程语言中最为常用的一个语句就是 if-else 语句。以下是 if-else 语句的语法： 1if (condition) statement1 [else statement2] 其中的 condition 可以是任意表达式；而且对这个表达式求值的结果不一定是布尔值。JavaScript 会自动调用 Boolean() 转换函数将这个表达式的结果转换为一个布尔值。如果对 condition 求值的结果是 true，则执行 statement1，如果对 condition 求值的结果是 false，则执行 statement2。而且这两个语句既可以是一行代码，也可以是一个代码块（以一对花括号括起来的多行代码）。请看下面的例子： 12345if (i &gt; 25) console.log(&quot;Greater than 25.&quot;); // 单行语句else &#123; console.log(&quot;Less than or equal to 25.&quot;); // 代码块中的语句&#125; 业界普遍推崇的最佳实践是始终使用代码块，即使要执行的只有一行代码。因为这样可以消除人们的误解，否则可能让人分不清在不同条件下要执行哪些语句。 switch 语句switch 语句与 if 语句的关系最为密切，而且也是在其他语言中普遍使用的一种流控制语句。JavaScript 中 switch 语句的语法与其他基于 C 的语言非常接近，如下所示： 1234567891011switch (expression) &#123; case value: statement break; case value: statement break; case value: statement break; case value: statement break; default: statement&#125; switch 语句中的每一种情形的含义是：“如果表达式等于这个值（value），则执行后面的语句（statement）”。而 break 关键字会导致代码执行流跳出 switch 语句。如果省略 break 关键字，就会导致执行完当前 case 后，继续执行下一个 case。最后的 default 关键字则用于在表达式不匹配前面任何一种情形的时候，也相当于一个 else 语句。从根本上讲，switch 语句就是为了让开发人员免于编写像下面这样的代码： 123456789if (i === 25)&#123; console.log(&quot;25&quot;);&#125; else if (i === 35) &#123; console.log(&quot;35&quot;);&#125; else if (i === 45) &#123; console.log(&quot;45&quot;);&#125; else &#123; console.log(&quot;Other&quot;);&#125; 而与此等价的switch语句如下所示： 12345678910111213switch (i) &#123; case 25: console.log(&quot;25&quot;); break; case 35: console.log(&quot;35&quot;); break; case 45: console.log(&quot;45&quot;); break; default: console.log(&quot;Other&quot;);&#125; 通过为每个case后面都添加一个break语句，就可以避免同时执行多个case代码的情况。假如确实需要混合几种情形，不要忘了在代码中添加注释，说明你是有意省略了break关键字。 虽然 JavaScript 中的 switch 语句借鉴自其他语言，但这个语句也有自己的特色。首先，可以在 switch 语句中使用任何数据类型（在很多其他语言中只能使用数值），无论是字符串，还是对象都没有问题。其次，每个 case 的值不一定是常量，可以是变量，甚至是表达式。请看下面这两个例子： 12345678910111213141516171819202122232425switch (&quot;hello world&quot;) &#123; case &quot;hello&quot; + &quot; world&quot;: console.log(&quot;Greeting was found.&quot;); break; case &quot;goodbye&quot;: console.log(&quot;Closing was found.&quot;); break; default: console.log(&quot;Unexpected message was found.&quot;);&#125;var num = 25;switch (true) &#123; case num &lt; 0: console.log(&quot;Less than 0.&quot;); break; case num &gt;= 0 &amp;&amp; num &lt;= 10: console.log(&quot;Between 0 and 10.&quot;); break; case num &gt; 10 &amp;&amp; num &lt;= 20: console.log(&quot;Between 10 and 20.&quot;); break; default: console.log(&quot;More than 20.&quot;);&#125; switch 语句首先计算 switch 关键字后的表达式，然后按照从上到下的顺序计算每个 case 后的表达式，直到执行到 case 的表达式的值与 switch 的表达式的值相等时为止。由于对每个 case 的匹配操作实际上是 === 恒等运算符比较，而不是 == 相等运算符比较，因此，表达式和 case 的匹配并不会做任何类型转换。 2）循环while 语句while 语句属于前测试循环语句，也就是说，在循环体内的代码被执行之前，就会对出口条件求值。因引，循环体内的代码有可能永远不会被执行。以下是 while 语句的语法： 1while(expression) statement 下面是一个示例： 1234var i = 0;while (i &lt; 10) &#123; i += 2;&#125; do-while 语句do-while 语句是一种后测试循环语句，即只有在循环体中的代码执行之后，才会测试出口条件。换句话说，在对条件表达式求值之前，循环体内的代码至少会被执行一次。以下是 do-while 语句的语法： 123do &#123; statement&#125; while (expression); 下面是一个示例： 1234var i = 0;do &#123; i += 2;&#125; while (i &lt; 10); for 语句for 语句也是一种前测试循环语句，但它具有在执行循环之前初始化变量和定义循环后要执行的代码的能力。以下是 for 语句的语法： 1for (初始化变量; 条件表达式; 操作表达式) 循环体 下面是一个示例： 1234var count = 10;for (var i = 0; i &lt; count; i++)&#123; console.log(i);&#125; 这个 for 循环语句与下面的 while 语句的功能相同： 123456var count = 10;var i = 0;while (i &lt; count)&#123; console.log(i); i++;&#125; 由于 JavaScript 中不存在块级作用域，因此在循环内部定义的变量也可以在外部访问到。例如： 12345var count = 10;for (var i = 0; i &lt; count; i++)&#123; console.log(i);&#125;console.log(i); // 10 此外，for 语句中的初始化表达式、控制表达式和循环后表达式都是可选的。将这两个表达式全部省略，就会创建一个无限循环，例如： 12345// 无限循环for (;;) &#123; doSomething();&#125; for-in 语句for-in 语句是一种精准的迭代语句，可以用来枚举对象的属性。以下是 for-in 语句的语法： 1for (property in object) statement 下面是一个示例： 123for (var propName in window) &#123; console.log(propName);&#125; 在这个例子中，我们使用 for-in 循环来显示了 BOM 中 window 对象的所有属性。每次执行循环时，都会将 window 对象中存在的一个属性名赋值给变量 propName。这个过程会一直持续到对象中的所有属性都被枚举一遍为止。与 for 语句类似，这里控制语句中的 var 操作符也不是必需的。但是，为了保证使用局部变量，我们推荐上面例子中的这种做法。 JavaScript 对象的属性没有顺序。因此，通过 for-in 循环输出的属性名的顺序是不可预测的。具体来讲，所有属性都会被返回一次，但返回的先后次序可能会因浏览器而异。 如果表示要迭代的对象的变量值为 null 或 undefined，for-in 语句会抛出错误。虽然 ECMAScript 5 更正了这一行为；对这种情况不再抛出错误，而只是不执行循环体。为了保证最大限度的兼容性，建议在使用 for-in 循环之前，先检测确认该对象的值不是 null 或 undefined。 3）跳转break 和 continue 语句break 和 continue 语句用于在循环中精确地控制代码的执行。其中，break 语句会立即退出循环，强制继续执行循环后面的语句。而 continue 语句虽然也是立即退出循环，但退出循环后会从循环的顶部继续执行。请看下面的例子： 12345678910var num = 0;for (var i=1; i &lt; 10; i++) &#123; if (i % 5 == 0) &#123; break; &#125; num++;&#125;console.log(num); // 4 这个例子中的 for 循环会将变量 i 由1递增至 10。在循环体内，有一个 if 语句检查 i 的值是否可以被 5 整除（使用求模运算符）。如果是，则执行 break 语句退出循环。另一方面，变量 num 从 0 开始，用于记录循环执行的次数。在执行 break 语句之后，结果显示 4。也就是说，在变量 i 等于 5 时，循环总共执行了 4 次；而 break 语句的执行，导致了循环在 num 再次递增之前就退出了。如果在这里把 break 替换为 continue 的话，则可以看到另一种结果： 12345678910var num = 0;for (var i=1; i &lt; 10; i++) &#123;if (i % 5 == 0) &#123; continue; &#125; num++;&#125;console.log(num); // 8 例子的结果显示 8，也就是循环总共执行了 8 次。当变量 i 等于 5 时，循环会在 num 再次递增之前退出，但接下来执行的是下一次循环，即i的值等于 6 的循环。于是，循环又继续执行，直到 i 等于 10 时自然结束。而 num 的最终值之所以是 8，是因为 continue 语句导致它少递增了一次。 break 和 continue 语句都可以与 label 语句联合使用，从而返回代码中特定的位置。这种联合使用的情况多发生在循环嵌套的情况下，如下面的例子所示： 12345678910111213var num = 0;outermost:for (var i = 0; i &lt; 10; i++) &#123; for (var j = 0; j &lt; 10; j++) &#123; if (i == 5 &amp;&amp; j == 5) &#123; break outermost; &#125; num++; &#125;&#125;console.log(num); // 55 在这个例子中，outermost 标签表示外部的 for 语句。如果每个循环正常执行 10 次，则 num++ 语句就会正常执行 100 次。换句话说，如果两个循环都自然结束，num 的值应该是 100。但内部循环中的 break 语句带了一个参数：要返回到的标签。添加这个标签的结果将导致 break 语句不仅会退出内部的 for 语句（即使用变量 j 的循环），而且也会退出外部的 for 语句（即使用变量 i 的循环）。为此，当变量 i 和 j 都等于 5 时， num的值正好是 55。同样，continue 语句也可以像这样与 label 语句联用，如下面的例子所示： 12345678910111213var num = 0;outermost:for (var i = 0; i &lt; 10; i++) &#123; for (var j = 0; j &lt; 10; j++) &#123; if (i == 5 &amp;&amp; j == 5) &#123; continue outermost; &#125; num++; &#125;&#125;console.log(num); // 95 在这种情况下，continue 语句会强制继续执行循环，退出内部循环，执行外部循环。当 j 是 5 时，continue 语句执行，而这也就意味着内部循环少执行了 5 次，因此 num 的结果是 95。 虽然联用 break、continue 和 label 语句能够执行复杂的操作，但如果使用过度，也会给调试带来麻烦。在此，我们建议如果使用 label 语句，一定要使用描述性的标签，同时不要嵌套过多的循环。 return 语句return 语句的作用是指定函数调用后的返回值。return 语句的语法如下： 1return [expression]; 下面是一个示例： 12function square(x) &#123; return x*x; &#125; // 一个包含 return 语句的函数square(2); // 调用结果为 4 return 语句只能在函数体内出现，如果不是的话会报语法错误。当执行到 return 语句的时候，函数终止执行，并返回 expression 的值给调用程序。如果没有 return 语句，则函数调用仅依次执行函数体内的每一条语句直到函数结束，最后返回调用程序。这种情况下，调用表达式的结果是 undefined。return 语句经常作为函数内的最后一条语句出现，但并不是说要一定放在函数最后。return 语句可以单独使用而不必带有 expression，这样的话函数也会向调用程序返回 undefined。 由于 JavaScript 可以自动插入分号，因此在 return 关键字和它后面的表达式之间不能有换行。 4）其他with 语句with 语句的作用是将代码的作用域设置到一个特定的对象中。with 语句的语法如下： 1with (expression) statement; 定义 with 语句的目的主要是为了简化多次编写同一个对象的工作，如下面的例子所示： 123var qs = location.search.substring(1);var hostName = location.hostname;var url = location.href; 上面几行代码都包含 location 对象。如果使用 with 语句，可以把上面的代码改写成如下所示： 12345with(location)&#123; var qs = search.substring(1); var hostName = hostname; var url = href;&#125; 在这个重写后的例子中，使用 with 语句关联了 location 对象。这意味着在 with 语句的代码块内部，每个变量首先被认为是一个局部变量，而如果在局部环境中找不到该变量的定义，就会查询 location 对象中是否有同名的属性。如果发现了同名属性，则以 location 对象属性的值作为变量的值。 由于大量使用 with 语句会导致性能下降，同时也会给调试代码造成困难，因此在开发大型应用程序时，不建议使用 with 语句。严格模式下不允许使用 with 语句，否则将视为语法错误。 代码块代码块将多个语句组合为一个复合语句。代码块其实就是一系列语句，可以放在任何期待一个语句的地方： 12345&#123; x = Math.PI cx = Math.cos(x) console.log(&quot;cos(n)= &quot; + cx)&#125; 注意：1)它没有以分号结尾。块中的单条语句都以分号结尾，但块本身没有。2）块中的代码相对于包含它们的花括号缩进","categories":[{"name":"javascript","slug":"javascript","permalink":"http://example.com/categories/javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://example.com/tags/javascript/"}]},{"title":"javascript表达式和操作符","slug":"javascript表达式和操作符","date":"2017-04-23T08:18:22.000Z","updated":"2022-05-26T02:13:21.260Z","comments":true,"path":"2017/04/23/javascript表达式和操作符/","link":"","permalink":"http://example.com/2017/04/23/javascript%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%92%8C%E6%93%8D%E4%BD%9C%E7%AC%A6/","excerpt":"","text":"表达式与操作符1）表达式表达式是由数字、运算符、数字分组符号（如括号）、自由变量和约束变量等以能求得数值的有意义排列方法所得的组合。JavaScript 表达式主要有以下几种形式： 原始表达式：常量、变量、保留字。 对象、数组初始化表达式：var obj=&#123;a:1,b:2&#125;;，var arr=[1,2,3];。 函数定义表达式：var fn=function()&#123;&#125;。 属性访问表达式：Math.abs。 调用表达式：alert(&#39;hello&#39;);。 对象创建表达式：new object();。 1）函数定义表达式函数定义表达式通常用关键字function,位于括号中的逗号分隔的0或多个标识符，以及一个位于花括号中的js代码块构成。 12345let square = function(x)&#123; return x*x;&#125;或function square(x)&#123; return x*x;&#125; 2）属性访问表达式属性访问表达式求值为对象属性或数组元素的值，其语法结构为 12expression.identifierexpression[identifier] 第一种属性访问语法是表达式后跟着一个句点和一个标识符。其中，表达式指定对象，标识符指定属性名。第二种属性访问语法是表达式后跟另一个位于方括号中的表达式。这第二个表达式指定属性名或数组元素的索引。 123456let o = &#123;x:1,y:&#123;z:3&#125;&#125;;let a = [o,4,[5,6]]o.x;o.y.za[1]a[0] 2）运算符JavaScript 中的运算符用于算术表达式、比较表达式、逻辑表达式、赋值表达式等。需要注意的是，大多数运算符都是由标点符号表示的，比如 + 和 =。而另外一些运算符则是由关键字表示的，比如 typeof 和 instanceof，关键字运算符和标点符号都是正规的运算符。 下表列出了 JavaScript 中所有的运算符，并按照运算符的优先级排序的，前面的运算符优先级要高于后面的运算符优先级，被空行分隔开来的运算符具有不同的优先级。标题为 A 的列表示运算符的结合性（Associativity），L 表示从左至右、R 表示从右至左，标题为 N 的列表示操作数的个数（Number）。 运算符 操作 A N ++ 前&#x2F;后增量 R 1 -- 前&#x2F;后增量 R 1 - 求反 R 1 + 转换为数字 R 1 ~ 按位求反 R 1 ! 逻辑非 R 1 delete 删除属性 R 1 typeof 检测类型 R 1 void 返回undefined R 1 * / % 乘，除，求模 L 2 + - 加，减 L 2 + 字符串连接 L 2 &lt;&lt; 左移位 L 2 &gt;&gt; 有符号右移 L 2 &gt;&gt;&gt; 无符号右移 L 2 &lt; &lt;= &gt; &gt;= 比较数字顺序 L 2 &lt; &lt;= &gt; &gt;= 比较字母顺序 L 2 instanceof 测试对象类 L 2 in 测试属性是否存在 L 2 == 判断相等 L 2 != 判断不等 L 2 === 判断恒等 L 2 !== 判断恒不等 L 2 &amp; 按位与 L 2 ^ 按位异或 L 2 ┃ 按位或 L 2 &amp;&amp; 逻辑与 L 2 ┃┃ 逻辑或 L 2 ?: 条件运算符 R 3 = 赋值 R 2 *= /= %= += -= &amp;= &lt;&lt;= &gt;&gt;= ^= ┃= &gt;&gt;&gt;= 运算且赋值 R 2 , 忽略第一个操作数， 返回第二个操作数 L 2 因为 | 是制表符，会导致格式混乱，所以表格中的 | 均以 ┃ 代替。 1）一元运算符（1）delete 运算符delete 运算符用来删除对象属性或者数组元素，如果删除成功或所删除的目标不存在，delete 将返回 true。然而，并不是所有的属性都可删除，一些内置核心和客户端属性是不能删除的，通过 var 语句声明的变量不能删除，通过 function 语句定义的函数也是不能删除的。例如： 1234567891011121314151617var o = &#123; x: 1, y: 2&#125;; // 定义一个对象console.log(delete o.x); // true，删除一个属性console.log(delete o.x); // true，什么都没做，x 在已上一步被删除console.log(&quot;x&quot; in o); // false，这个属性在对象中不再存在console.log(delete o.toString); // true，什么也没做，toString是继承来的console.log(delete 1); // true，无意义var a = [&quot;x&quot;,&quot;y&quot;,&quot;z&quot;]; // 定义一个数组console.log(2 in a); // true，下标为2的元素，在数组中存在console.log(delete a[2]); // true，删除下标为2的元素（最后一个数组元素）console.log(2 in a); // false，下标为2的元素，在数组中不再存在console.log(a.length); // 3，数组长度并不会因 delete 而改变console.log(a[2]); // undefined，下标为2的元素，位置被空了出来console.log(delete a); // false，通过 var 语句声明的变量不能删除function f(args)&#123;&#125; // 定义一个函数console.log(delete f); // false，通过 function 语句声明的函数不能删除 （2）void 运算符void 运算符可以应用于任何表类型的表达式，表达式会被执行，但计算结果会被忽略并返回 undefined。例如： 1234567void 0;void &quot;you are useless?&quot;;void false;void [];void /(useless)/ig;void function()&#123; console.log(&quot;you are so useless?&quot;); &#125;// always return undefined （3）typeof 运算符鉴于 JavaScript 是松散类型的，因此需要有一种手段来检测给定变量的数据类型，typeof 就是负责提供这方面信息的运算符。对一个值使用 typeof 运算符可能返回下列某个字符串： &quot;undefined&quot;，如果这个值未声明或已声明但未初始化。 &quot;boolean&quot;，如果这个值是布尔值。 &quot;string&quot;，如果这个值是字符串。 &quot;number&quot;，如果这个值是数值。 &quot;object&quot;，如果这个值是对象或 null。 &quot;function&quot;，如果这个值是函数。 下面是几个使用 typeof 运算符的例子： 1234var message = &quot;some string&quot;;console.log(typeof message); // &quot;string&quot;console.log(typeof(message)); // &quot;string&quot;console.log(typeof 95); // &quot;number&quot; 从以上例子可以看出，typeof 运算符既可以对变量使用，又可以对字面量使用。由于 typeof 是一个运算符而不是函数，因此例子中的圆括号尽管可以使用，但并不提倡。 typeof null 结果是 &quot;object&quot; 是历史遗留 Bug，在 ECMAScript 6 中，曾经有提案为历史平反, 将 typeof null 的值纠正为 &quot;null&quot;，但最后该提案被拒。理由是历史遗留代码太多，不如继续将错就错。 （4）++ -- 运算符++ -- 递增递减运算符借鉴自 C 语言，它们分前置型和后置型，作用是改变一个变量的值。例如： 12345var a = 5;console.log(a++); // 5console.log(++a); // 7console.log(a--); // 7console.log(--a); // 5 （5）+ - 运算符当 + - 作为一元运算符时，应用于数值，表示数值的正负。应用于非数值，先按 Number() 转型函数对这个值执行转换，再表示该值的正负。 （6）~ ! 运算符 ~ 按位非运算符，请参见下面「位运算符」。! 逻辑非运算符，请参见下面「逻辑运算符」。 2）乘性运算符JavaScript 定义了3个乘性运算符：乘法、除法和求模。这些运算符与 C 语言的相应运算符用途类似，只不过在操作数为非数值的情况下会执行自动的类型转换。如果参与乘法计算的某个操作数不是数值，后台会先使用 Number() 转型函数将其转换为数值。也就是说，空字符串将被当作 0，布尔值 true 将被当作 1。 （1）* 乘法运算符用于计算两个数值的乘积，在处理特殊值的情况下，乘法运算符遵循下列特殊的规则： 如果操作数都是数值，执行常规的乘法计算，即两个正数或两个负数相乘的结果还是正数，而如果只有一个操作数有符号，那么结果就是负数。如果乘积超过了 JavaScript 数值的表示范围，则返回 Infinity 或 -Infinity； 如果有一个操作数是 NaN，则结果是 NaN； 如果是 Infinity 与 0 相乘，则结果是 NaN； 如果是 Infinity 与非 0 数值相乘，则结果是 Infinity 或 -Infinity，取决于有符号操作数的符号； 如果是 Infinity 与 Infinity 相乘，则结果是 Infinity；如果有一个操作数不是数值，则在后台调用 Number()将其转换为数值，然后再应用上面的规则。 （2）/ 除法运算符用于计算两个数值的商，与乘法运算符类似，除法运算符对特殊的值也有特殊的处理规则。这些规则如下： 如果操作数都是数值，执行常规的除法计算，即两个正数或两个负数相除的结果还是正数，而如果只有一个操作数有符号，那么结果就是负数。如果商超过了 JavaScript 数值的表示范围，则返回 Infinity 或 -Infinity； 如果有一个操作数是 NaN，则结果是 NaN； 如果是 Infinity 被 Infinity 除，则结果是 NaN； 如果是零被零除，则结果是 NaN； 如果是非零的有限数被零除，则结果是 Infinity 或 -Infinity，取决于有符号操作数的符号； 如果是 Infinity 被任何非零数值除，则结果是 Infinity 或 -Infinity，取决于有符号操作数的符号； 如果有一个操作数不是数值，则在后台调用 Number() 将其转换为数值，然后再应用上面的规则。 （3）% 求模运算符用于计算两个数值的余数，与另外两个乘性运算符类似，求模运算符会遵循下列特殊规则来处理特殊的值： 如果操作数都是数值，执行常规的除法计算，返回除得的余数； 如果被除数是无穷大值而除数是有限大的数值，则结果是 NaN； 如果被除数是有限大的数值而除数是零，则结果是 NaN； 如果是 Infinity 被 Infinity 除，则结果是 NaN； 如果被除数是有限大的数值而除数是无穷大的数值，则结果是被除数； 如果被除数是零，则结果是零； 如果有一个操作数不是数值，则在后台调用 Number() 将其转换为数值，然后再应用上面的规则。 3）加性运算符加法和减法这两个加性运算符应该说是编程语言中最简单的算术运算符了。但是在 JavaScript 中，这两个运算符却都有一系列的特殊行为。与乘性运算符类似，加性运算符也会在后台转换不同的数据类型。然而，对于加性运算符而言，相应的转换规则还稍微有点复杂。 + 加法运算符如果两个运算符都是数值，执行常规的加法计算，然后根据下列规则返回结果： 如果有一个操作数是 NaN，则结果是 NaN； 如果是 Infinity 加 Infinity，则结果是 Infinity； 如果是 -Infinity 加 -Infinity，则结果是 -Infinity； 如果是 Infinity 加- Infinity，则结果是 NaN； 如果是 +0 加 +0，则结果是 +0； 如果是 -0 加 -0，则结果是 -0； 如果是 +0 加 -0，则结果是 +0; 如果有一个操作数不是数值，那么就要应用如下规则： 如果两个操作数都是字符串，则将第二个操作数与第一个操作数拼接起来； 如果只有一个操作数是字符串，则将另一个操作数转换为字符串，然后再将两个字符串拼接起来。 如果有一个操作数是对象、数值或布尔值，则调用它们的 toString() 方法取得相应的字符串值，然后再应用前面关于字符串的规则。对于 undefined 和 null，则分别调用 String() 函数并取得字符串 &quot;undefined&quot; 和 &quot;null&quot;。 如果是 null 加 null，则结果是 0; 如果是 undefined 加 undefined，则结果是 NaN; 下面来举几个例子： 12345678910var result1 = 5 + 5; // 两个数值相加console.log(result1); // 10var result2 = 5 + &quot;5&quot;; // 一个数值和一个字符串相加console.log(result2); // &quot;55&quot;var num1 = 5;var num2 = 10;var message = &quot;The sum of 5 and 10 is &quot; + num1 + num2;console.log(message); // &quot;The sum of 5 and 10 is 510&quot;，如何修改？ - 减法运算符如果两个运算符都是数值，执行常规的减法计算，然后根据下列规则返回结果： 如果有一个操作数是 NaN，则结果是 NaN； 如果是 Infinity 减 Infinity，则结果是 NaN； 如果是 -Infinity 减 -Infinity，则结果是 NaN； 如果是 Infinity 减 -Infinity，则结果是 Infinity； 如果是 -Infinity 减 Infinity，则结果是 -Infinity； 如果是 +0 减 +0，则结果是 +0； 如果是 +0 减 -0，则结果是 -0； 如果是 -0 减 -0，则结果是 +0； 如果有一个操作数不是数值，那么就要应用如下规则： 如果有一个操作数是字符串、布尔值、null 或 undefined，则先在后台调用 Number() 函数将其转换为数值，然后再根据前面的规则执行减法计算。如果转换的结果是 NaN，则减法的结果就是 NaN； 如果有一个操作数是对象，则调用对象的 valueOf() 方法以取得表示该对象的数值。如果得到的值是 NaN，则减法的结果就是 NaN。如果对象没有 valueOf() 方法，则调用其 toString()方法并将得到的字符串转换为数值。 如果是 null 减 null，则结果是 0; 如果是 undefined 减 undefined，则结果是 NaN; 下面来举几个例子： 123456var result1 = 5 - true; // 4，因为true被转换成了1var result2 = NaN - 1; // NaNvar result3 = 5 - 3; // 2var result4 = 5 - &quot;&quot;; // 5，因为&quot;&quot; 被转换成了0var result5 = 5 - &quot;2&quot;; // 3，因为&quot;2&quot;被转换成了2var result6 = 5 - null; // 5，因为null被转换成了0 4）等值运算符确定两个变量是否相等是编程中的一个非常重要的操作。在比较简单数据类型之间的相等性时，问题还比较简单。但在涉及到对象之间的比较时，问题就变得复杂了。最早的 JavaScript 中的相等和不等运算符会在执行比较之前，先将对象转换成相似的类型。后来，有人提出了这种转换到底是否合理的质疑。最后，JavaScript 的解决方案就是提供两组运算符：相等和不相等（先转换再比较），恒等和不恒等（仅比较而不转换）。 == != 运算符== != 这两个运算符都会先转换操作数（通常称为强制转型），然后再比较它们的相等性。在转换不同的数据类型时，相等和不相等运算符遵循下列基本规则： 如果有一个操作数是布尔值，则在比较相等性之前先将其转换为数值（false 转换为 0，而 true 转换为 1）； 如果一个操作数是字符串，另一个操作数是数值，在比较相等性之前先将字符串转换为数值； 如果一个操作数是对象，另一个操作数不是，则调用对象的 valueOf() 方法，用得到的基本类型值按照前面的规则进行比较； null 和 undefined 是相等的。要比较相等性之前，不能将 null 和 undefined 转换成其他任何值。 如果有一个操作数是 NaN，则相等运算符返回 false，而不相等运算符返回 true。重要提示：即使两个操作数都是 NaN，相等运算符也返回 false；因为按照规则，NaN 不等于 NaN。 如果两个操作数都是对象，则比较它们是不是同一个对象。如果两个操作数都指向同一个对象，则相等运算符返回 true；否则，返回 false。 列出了一些特殊情况及比较结果： 1234567891011null == undefined // true&quot;NaN&quot; == NaN // false5 == NaN // falseNaN == NaN // falseNaN != NaN // truefalse == 0 // truetrue == 1 // truetrue == 2 // falseundefined == 0 // falsenull == 0 // false&quot;5&quot; == 5 // true === !== 运算符除了在比较之前不转换操作数之外，恒等和不恒等运算符与相等和不相等运算符没有什么区别。它只在两个操作数未经转换就相等的情况下返回 true，如下面的例子所示： 1234var result1 = (&quot;55&quot; == 55); // true，因为转换后相等var result2 = (&quot;55&quot; === 55); // false，因为不同的数据类型不相等var result3 = (null == undefined) // true，因为它们是类似的值var result4 = (null === undefined) // false，因为它们是不同类型的值 5）关系运算符&lt; &gt; &lt;= &gt;= 运算符&lt; 小于、&gt; 大于、&lt;= 小于等于、 &gt;= 大于等于 这几个关系运算符用于对两个值进行比较返回一个布尔值。与 JavaScript 中的其他运算符一样，当关系运算符的操作数使用了非数值时，也要进行数据转换或完成某些奇怪的操作。以下就是相应的规则。 如果两个操作数都是数值，则执行数值比较。 如果两个操作数都是字符串，则比较两个字符串对应的字符编码值（可以通过字符串的 charCodeAt() 函数获取字符编码值）。 如果一个操作数是数值，则将另一个操作数转换为一个数值，然后执行数值比较。 如果一个操作数是对象，则调用这个对象的 valueOf() 方法，用得到的结果按照前面的规则执行比较。如果对象没有 valueOf()方法，则调用 toString()方法，并用得到的结果根据前面的规则执行比较。 如果一个操作数是布尔值，则先将其转换为数值，然后再执行比较。 请思考下面几个例子的结果是如何得出的： 1234567var result1 = &quot;Brick&quot; &lt; &quot;alphabet&quot;; // truevar result2 = &quot;brick&quot; &lt; &quot;alphabet&quot;; // falsevar result3 = &quot;23&quot; &lt; &quot;3&quot;; // truevar result4 = &quot;23&quot; &lt; 3; // falsevar result5 = &quot;a&quot; &lt; 3; // falsevar result6 = NaN &lt; 3; // falsevar result7 = NaN &gt;= 3; // false in 运算符in 运算符希望它的左操作数是一个字符串或可以转换为字符串，希望它的右操作数是一个对象。如果右侧的对象拥有一个名为左操作数值的属性名，那么表达式返回 true，例如： 123456789var point = &#123; x:1, y:1 &#125;; // 定义一个对象&quot;x&quot; in point // true，对象有一个名为&quot;x&quot;的属性&quot;z&quot; in point // false，对象中不存在名为&quot;z&quot;的属性&quot;toString&quot; in point // true，对象继承了toString()方法var data = [7,8,9]; // 拥有三个元素的数组&quot;0&quot; in data // true，数组包含元素&quot;0&quot;1 in data // true，数字转换为字符串3 in data // false，没有索引为3的元素 instanceof 运算符instanceof 运算符希望左操作数是一个对象，右操作数标识对象的类。如果左侧的对象是右侧类的实例，则表达式返回 true；否则返回 false。后面会讲 JavaScript 中对象的类是通过初始化它们的构造函数来定义的。这样的话，instanceof 的右操作数应当是一个函数。比如： 123456789var d = new Date(); // 通过 Date() 构造函数来创建一个新对象d instanceof Date; // true，d 是由 Date() 创建的d instanceof Object; // true，所有的对象都是 Object 的实例d instanceof Number; // false，d 不是一个 Number 对象var a = [1, 2, 3]; // 通过数组字面量的写法创建一个数组a instanceof Array; // true，a 是一个数组a instanceof Object; // true，所有的数组都是对象a instanceof RegExp; // false，数组不是正则表达式 需要注意的是，所有的对象都是 Object 的实例。当通过 instanceof 判断一个对象是否是一个类的实例的时候，这个判断也会包含对「父类」的检测。如果 instanceof 的左操作数不是对象的话，instanceof 返回 false。如果右操作数不是函数，则抛出一个类型错误异常。 6）逻辑运算符逻辑运算符是对操作数进行布尔算术运算，经常和关系运算符一起配合使用，逻辑运算符将多个关系表达式组合起来组成一个更复杂的表达式。 &amp;&amp; 逻辑与逻辑与操作可以应用于任何类型的操作数，而不仅仅是布尔值。在有一个操作数不是布尔值的情况下，逻辑与操作不一定返回布尔值；此时，它遵循下列规则： 如果第一个操作数是对象，则返回第二个操作数； 如果第二个操作数是对象，则只有在第一个操作数的求值结果为 true 的情况下才会返回该对象； 如果两个操作数都是对象，则返回第二个操作数； 如果有一个操作数是 null，则返回 null； 如果有一个操作数是 NaN，则返回 NaN； 如果有一个操作数是 undefined，则返回 undefined。 逻辑与操作属于短路操作，即如果第一个操作数能够决定结果，那么就不会再对第二个操作数求值。对于逻辑与操作而言，如果第一个操作数是 false，无论第二个操作数是什么值，结果都不再可能是 true 了。 12console.log(3 &gt; 5 &amp;&amp; 3 &gt; 2); // falseconsole.log(3 &lt; 5 &amp;&amp; 3 &gt; 2); // true || 逻辑或与逻辑与操作相似，如果有一个操作数不是布尔值，逻辑或也不一定返回布尔值；此时，它遵循下列规则： 如果第一个操作数是对象，则返回第一个操作数； 如果第一个操作数的求值结果为 false，则返回第二个操作数； 如果两个操作数都是对象，则返回第一个操作数； 如果两个操作数都是 null，则返回 null； 如果两个操作数都是 NaN，则返回 NaN； 如果两个操作数都是 undefined，则返回 undefined。 与逻辑与运算符相似，逻辑或运算符也是短路运算符。也就是说，如果第一个操作数的求值结果为 true，就不会对第二个操作数求值了。 12console.log(3 &gt; 5 || 3 &gt; 2); // true console.log(3 &gt; 5 || 3 &lt; 2); // false ! 逻辑非逻辑非操作可以应用于任何类型的操作数，无论这个值是什么数据类型，这个运算符都会返回一个布尔值。逻辑非运算符首先会将它的操作数转换为一个布尔值，然后再对其求反。逻辑非运算符遵循下列规则： 如果操作数是一个对象，返回 false； 如果操作数是一个空字符串，返回 true； 如果操作数是一个非空字符串，返回 false； 如果操作数是数值 0，返回 true； 如果操作数是任意非 0 数值（包括 Infinity），返回 false； 如果操作数是 null，返回 true； 如果操作数是 NaN，返回 true； 如果操作数是 undefined，返回 true。 下面几个例子展示了应用上述规则的结果： 123456console.log(!false); // trueconsole.log(!&quot;blue&quot;); // falseconsole.log(!0); // trueconsole.log(!NaN); // trueconsole.log(!&quot;&quot;); // trueconsole.log(!12345); // false 逻辑非运算符也可以用于将一个值转换为与其对应的布尔值。而同时使用两个逻辑非运算符，实际上就会模拟 Boolean() 转型函数的行为。其中，第一个逻辑非操作会基于无论什么操作数返回一个布尔值，而第二个逻辑非操作则对该布尔值求反，于是就得到了这个值真正对应的布尔值。当然，最终结果与对这个值使用 Boolean() 函数相同，例如： 12345console.log(!!&quot;blue&quot;); //trueconsole.log(!!0); //falseconsole.log(!!NaN); //falseconsole.log(!!&quot;&quot;); //falseconsole.log(!!12345); //true 7）位运算符在 JavaScript 中，当对数值应用位运算符时，后台会发生如下转换过程：64位的数值被转换成32位数值，然后执行位操作，最后再将32位的结果转换回64位数值。这个转换过程导致了一个严重的副效应，即在对特殊的 NaN 和 Infinity 值应用位操作时，这两个值都会被当成 0 来处理。如果对非数值应用位运算符，会先使用 Number() 函数将该值转换为一个数值，然后再应用位操作，得到的结果将是一个数值。 ~ 按位非简单的理解，对任一数值 x 进行按位非操作的结果为 -(x+1)。例如： 1234567891011console.log(~null); // -1console.log(~undefined); // -1console.log(~0); // -1console.log(~&#123;&#125;); // -1console.log(~[]); // -1console.log(~(1/0)); // -1console.log(~false); // -1console.log(~true); // -2console.log(~1.2543); // -2console.log(~4.9); // -5console.log(~(-2.999)); // 1 &amp; 按位与按位与操作就是将两个数值的每一位对齐，两个数值的对应位都是 1 时才返回 1，任何一位是 0，结果都是 0。如下表所示： 第一个数值的位 第二个数值的位 结果 1 1 1 1 0 0 0 1 0 0 0 0 | 按位或按位或操作就是将两个数值的每一位对齐，两个数值只要有一个位是 1 就返回 1，只在两个位都是 0 的情况下才返回 0。如下表所示： 第一个数值的位 第二个数值的位 结果 1 1 1 1 0 1 0 1 1 0 0 0 ^ 按位异或按位异或与按位或的不同之处在于，两个数值只有一个 1 时才返回 1，如果对应的两位都是 1 或都是 0，则返回 0。 第一个数值的位 第二个数值的位 结果 1 1 0 1 0 1 0 1 1 0 0 0 &lt;&lt; 左移这个运算符会将数值的所有位向左移动指定的位数。例如： 12var oldValue = 2; // 等于二进制的 10var newValue = oldValue &lt;&lt; 5; // 等于二进制的 1000000，十进制的 64 注意，左移不会影响操作数的符号位。换句话说，如果将 -2 向左移动 5 位，结果将是 -64，而非 64。 &gt;&gt; 有符号的右移这个运算符会将数值向右移动，但保留符号位（即正负号标记）。 12var oldValue = 64; // 等于二进制的 1000000var newValue = oldValue &gt;&gt; 5; // 等于二进制的 10 ，即十进制的 2 &gt;&gt;&gt; 无符号的右移这个运算符会将数值的所有32位都向右移动。对正数来说，无符号右移的结果与有符号右移相同。 12var oldValue = 64; // 等于二进制的 1000000var newValue = oldValue &gt;&gt;&gt; 5; // 等于二进制的 10 ，即十进制的 2 无符号右移运算符会把负数的二进制码当成正数的二进制码。而且，由于负数以其绝对值的二进制补码形式表示，因此就会导致无符号右移后的结果非常之大。 12var oldValue = -64; // 等于二进制的 11111111111111111111111111000000var newValue = oldValue &gt;&gt;&gt; 5; // 等于十进制的 134217726 8）赋值运算符简单的赋值运算符由等于号 = 表示，其作用就是把右侧的值赋给左侧的变量，如下面的例子所示： 1var num = 10; 如果在等于号 = 前面再添加乘性运算符、加性运算符或位运算符，就可以完成复合赋值操作。这种复合赋值操作相当于是对下面常规表达式的简写形式： 12var num = 10;num += 10; // 等同于 num = num + 10; 每个主要算术运算符（以及个别的其他运算符）都有对应的复合赋值运算符。这些运算符如下所示： 乘&#x2F;赋值 *=； 除&#x2F;赋值 /=； 模&#x2F;赋值 %=； 加&#x2F;赋值 +=； 减&#x2F;赋值 -=； 左移&#x2F;赋值 &lt;&lt;=； 有符号右移&#x2F;赋值 &gt;&gt;=； 无符号右移&#x2F;赋值 &gt;&gt;&gt;=。 设计这些运算符的主要目的就是简化赋值操作，使用它们不会带来任何性能的提升。 9）条件运算符? : 条件运算符应该算是 JavaScript 中最灵活的一种运算符了，而且它遵循与 Java 中的条件运算符相同的语法形式，如下面的例子所示： 1variable = boolean_expression ? true_value : false_value; 10）逗号运算符逗号运算符多用于声明多个变量；但除此之外，逗号运算符还可以用于赋值。在用于赋值时，逗号运算符总会返回表达式中的最后一项，如下面的例子所示： 1var num = (5, 1, 4, 8, 0); // num 的值为 0 由于 0 是表达式中的最后一项，因此 num 的值就是 0。虽然逗号的这种使用方式并不常见，但这个例子可以帮我们理解逗号的这种行为。","categories":[{"name":"javascript","slug":"javascript","permalink":"http://example.com/categories/javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://example.com/tags/javascript/"}]},{"title":"javascript类型、值和变量","slug":"javascript类型、值和变量","date":"2017-04-23T00:08:27.000Z","updated":"2022-05-26T02:13:12.654Z","comments":true,"path":"2017/04/23/javascript类型、值和变量/","link":"","permalink":"http://example.com/2017/04/23/javascript%E7%B1%BB%E5%9E%8B%E3%80%81%E5%80%BC%E5%92%8C%E5%8F%98%E9%87%8F/","excerpt":"","text":"类型、值和变量JavaScript类型可以分为两类：原始类型和对象类型。 原始类型包括数值、字符串、布尔值、特殊值null、undefined。其中null和undefined不是数值、字符串或布尔值，通常被认为 是各自特殊类型的唯一成员。 对象是属性的集合，其中每个属性都有一个名字和一个值。 注意：任何不是数值、字符串、布尔值、符号、null和undefined的值都是对象。 在内存管理方面，js解析器会执行自动垃圾收集。当程序无法以任何方式引用这个值时，解释器会自动释放它占用的内存。 1）数值 整数 Number用于表示整数和近似实数。 Number 类型是 JavaScript 中最令人关注的数据类型，这种类型使用 IEEE 754 格式来表示整数和浮点数值（浮点数值在某些语言中也被称为双精度数值）。和其他编程语言不同，JavaScript 中的所有数字均用浮点数值表示。 在 JavaScript 中进行算术计算时，所有以八进制和十六进制表示的数值最终都将被转换成十进制数值。例如： 1234567var a = 10; // 十进制var b = 023; // 八进制var c = 0x12ac; // 十六进制0xff = 255；（15*16+15） // 十六进制0xbadcafe // =&gt;195939070 // 十六进制console.log(b); // 19console.log(c); // 4780 八进制第一位必须是0，后面跟八进制序列0到7，如果超出了范围，则忽略前导0，后面的数值当做十进制解析，例如：089会被解析为89。（八进制字面量在严格模式下是无效的，会抛出错误。） 十六进制前两位必须是 0x 或 0X，后跟十六进制序列09、af（10~15）（不区分大小写），如果超出了范围，则会报语法错误。 浮点数 所谓浮点数值，就是该数值中必须包含一个小数点，并且小数点后面必须至少有一位数字。虽然小数点前面可以没有整数，但我们不推荐这种写法。例如： 123var a = 1.1;var b = 0.1;var c = .1; // 有效，但不推荐 JavaScript 会不失时机的将浮点数转换成整数。例如： 12var a = 5.; // 解析成整数5var b = 5.0; // 解析成整数5 对于极大或者极小的数值，可采用科学技术法（也称e表示法）。JavaScript 会将那些小数点后面带有6个零以上的小于1的浮点数值转换为以e表示法表示的数值。例如： 123var a = 3.14e7; // 等于31400000var b = 3.14E-7; // 等于0.000000314console.log(0.0000003); // 3e-7 浮点数值的最高精度是17位小数，但在进行算术计算时其精确度远远不如整数，例如： 1console.log(0.1 + 0.2); // 0.30000000000000004 这个舍入误差会导致无法测试特定的浮点数值，因此，永远不要测试某个特定的浮点数值。 Js使用的IEEE~754浮点法是一种二进制表示法，这种表示法可以精确地表示如1&#x2F;2,1&#x2F;8,1&#x2F;1024等分数。然而我们常用的十进制 分数：1&#x2F;10,1&#x2F;100等等，二进制浮点表示法无法精确表示。 123456例如：let x = .3 - .2 ;//这个数值只能非常近似地表示0.1，但无法精确的表示。let y = .2 - .1;x ===y; ==&gt;falsex ===.1; ==&gt;falsey ===.1; ==&gt;true 正无穷、负无穷 由于内存限制，JavaScript 能表示的数值范围从 Number.MIN_VALUE 到 Number.MAX_VALUE，并将超出范围的数转换成 Number.POSITIVE_INFINITY 或 Number.NEGATIVE_INFINITY。0作为除数是不会报错的，正数除以0返回正无穷，负数除以0返回负无穷，0除以0返回NaN。例如： 123456789console.log(Number.MAX_VALUE); // 最大数 1.7976931348623157e+308console.log(Number.MIN_VALUE); // 最小数 5e-324console.log(Number.POSITIVE_INFINITY); // 正无穷 Infinityconsole.log(Number.NEGATIVE_INFINITY); // 负无穷 -Infinityconsole.log( 1 / 0); // Infinityconsole.log(-1 / 0); // -Infinity JavaScript 提供了 isFinite() 函数，来确定一个数是不是有穷的。例如： 12console.log(isFinite(100)); // trueconsole.log(isFinite(Infinity)); // false NaN NaN（not a number），是一个特殊的数值。之所以称它为「非数值」，是因为它不能参与算数运算，任何涉及 NaN 的操作都返回 NaN。并且 NaN 与任何值都不相等（包括自身）。例如： 12345678console.log(typeof NaN); // &quot;number&quot;console.log(0 / 0); // NaNconsole.log(NaN - NaN); // NaNconsole.log(Infinity - Infinity); // NaNvar a = NaN;console.log(a === a); // false JavaScript 提供了 isNaN() 函数，来确定一个数是不是 NaN。例如： 12345console.log(isNaN(100)); // falseconsole.log(isNaN(&quot;100&quot;)); // falseconsole.log(isNaN(true)); // falseconsole.log(isNaN(&quot;sss&quot;)); // trueconsole.log(isNaN(NaN)); // true Number()、parseInt()、parseFloat()转型函数 isNaN() 函数在接收到一个值之后，会尝试使用转型函数 Number() 将这个值转换为数值，转换规则如下： undefined 转换为 NaN； null 转换为 0； true 转换为 1、false 转换为 0； number 整数转换为十进制，小数不变； string 如果只包含十进制数和小数，则返回对应的数值，如果只包含八进制数，则忽略前导0返回剩余部分，如果只包含十六进制，则返回十进制数，空字符串转换为0，其它字符串转换为 NaN； 如果 object 具有 valueOf() 方法，且返回一个原始值（5种简单数据类型），则将这个原始值转换为数字，并返回这个数字；否则，如果 object 具有 toString() 方法，且返回一个原始值，则将这个原始值转换为数字，并返回这个数字；否则，抛出一个类型错误异常。 由于 Number() 转型函数在转换字符串时不够理想，因此还有两个专门用来转换字符串的函数 parseInt() 和 parseFloat() 函数。 parseInt() 函数会忽略字符串前面的空格，直至找到第一个非空格字符，只要第一个非空格字符不是数字或者正负号，一律返回 NaN， 如果第一个非空格字符是数字字符，parseInt() 会继续解析第二个字符，直到解析完所有后续字符或者遇到了一个非数字字符。例如： 123console.log(parseInt(&quot;&quot;)); // NaN（Number(&quot;&quot;)返回 0）console.log(parseInt(&quot;123S&quot;)); // 123console.log(parseInt(&quot;12.4&quot;)); // 12 parseFloat() 函数也会忽略字符串前面的空格，直至找到第一个非空格字符，只要第一个非空格字符不是数字或者正负号或者小数点，一律返回 NaN， 如果第一个非空格字符是上述字符之一，parseFloat() 会继续解析第二个字符，直到解析完所有后续字符或者遇到了一个非浮点数值。例如： 12console.log(parseFloat(&quot;098.2&quot;)); // 98.2console.log(parseFloat(&quot;123.23.23&quot;)); // 123.23 2）字符串字符串是16位值的不可修改的有序序列，其中每个值都表示一个Unicode字符。 在Js中可以使用单引号、双引号或者反引号(‘ ‘ ,” “,&#96;&#96;)包含起来来表示字符串，双引号和反引号可以出现在由单引号定界的字符 串中，同理由双引号和反引号定界的字符串里也可以包含另外两种引号。 12345&quot; &quot; //空字符串&#x27;testing&#x27;&quot;3.14&quot;&quot;Wouldn&#x27;t you prefer o&#x27;Reilly&#x27;s Books&quot;`&quot;she said &#x27;hi&#x27;&quot;,he said` 转义序列 12345678910\\0 Null字符\\b 退格符\\t 水平制表符\\n 换行符\\f 进制符\\r 回车符\\&quot; 双引号\\&#x27; 单引号\\\\ 反斜杠\\xnn 由2位16进制数字nn指定的Unicode字符 转义字符可出现在字符串中的任意位置，且长度为1。如要在字符串中显示 \\ ，则必须使用 \\ 进行转义。例如： 12console.log(&quot;\\n\\\\&quot;.length); // 2console.log(&quot;\\\\hello&quot;); // &quot;\\hello&quot;（长度为6） 大部分值都可以使用继承而来的 toString()方法转换为字符串，但 undefined 和 null 值没有这个方法。对数值使用 toString() 方法时，可以传入一个数字基数，以此输出对应进制的字符串值。例如： 1234567console.log(true.toString()); // &quot;true&quot;var num = 10;console.log(num.toString()); // &quot;10&quot;console.log(num.toString(2)); // &quot;1010&quot;console.log(num.toString(8)); // &quot;12&quot;console.log(num.toString(16)); // &quot;a&quot; 在不知道要转换的值是不是 undefined 或 null 的情况下，还可以使用转型函数 String()，这个函数能够将任何类型的值转换为字符串。String() 函数遵循下列转换规则： 如果值有 toString() 方法，则调用该方法（没有参数）并返回相应的结果； 如果值是 undefined，则返回 &quot;undefined&quot;； 如果值是 null，则返回 &quot;null&quot;。 12345var value;console.log(String(10)); // &quot;10&quot;console.log(String(true)); // &quot;true&quot;console.log(String(null)); // &quot;null&quot;console.log(String(value)); // &quot;undefined&quot; 3）布尔值Boolean 类型是 JavaScript 中使用得最多的一种类型，该类型只有两个字面值：true 和 false。需要注意的是，他们是区分大小写的，也就是说 True 和 False（以及其他的混合大小写形式）都不是 Boolean 值，只是标识符。 虽然 Boolean 类型的字面值只有两个，但 JavaScript 中所有类型的值都能使用 if 语句或 Boolean() 函数转换为对应的 Boolean 值，例如： 123456var message = &quot;Hello world!&quot;;if (message)&#123; console.log(&quot;Value is true.&quot;); // 被执行&#125;var messageAsBoolean = Boolean(message);console.log(messageAsBoolean); // true 下表给出了各种数据类型及其对应的转换规则。 数据类型 转换为true的值 转换为false的值 Undefined - undefined Null - null Boolean true false String 任何非空字符串 “”（空字符串） Number 任何非零数字值（包括无穷大） 0和NaN Object 任何对象 - 4）null和undefinedUndefined 类型只有1个值，即 undefined。使用 var 声明变量但未对其加以初始化时，这个变量的值就是 undefined，直接使用未声明的变量会产生错误。对未声明或已声明但未初始化的变量执行 typeof 运算符会返回 &quot;undefined&quot; 值，例如： 1234567var message; // 这个变量声明之后默认取得了 undefined 值// var age // 这个变量并没有声明console.log(message); // &quot;undefined&quot;console.log(age); // 产生错误console.log(typeof message); // &quot;undefined&quot;console.log(typeof age); // &quot;undefined&quot; Null 类型也只有1个值，即 null。它用来表示值的空缺。你可以认为 undefined 是表示系统级的、出乎意料的或类似错误的值的空缺，而 null 是表示程序级的、正常的或在意料之中的值的空缺。在下列场景中应当使用 null。 用来初始化一个变量，这个变量可能赋值为一个对象。 用来和一个已经初始化的变量比较，这个变量可以是也可以不是一个对象。 当函数的参数期望是对象时，作用参数传入。 当函数的返回值期望是对象时，作用返回值传出。 在下列场景中不应当使用 null。 不要使用 null 来检测是否传入了某个参数。 不要使用 null 来检测一个未初始化的变量。 5）全局对象全局对象的属性是全局性定义的标识符，可以在js程序的任何地方使用。js解释器启动后都会创建一个新的全局对象并为其添加一组初始的属性。 6）对象和数组JavaScript 中所有对象都继承自 Object 类型，每个对象都具有下列基本的属性和方法： constructor：保存着用于创建当前对象的函数（构造函数）。 hasOwnProperty()：用于检查给定的属性在当前对象实例中是否存在。 propertyIsEnumerable()：用于检查给定的属性是否能够使用for-in语句来枚举。 isPrototypeOf()：用于检查对象是否是传入对象的原型。 toString() 方法：返回对象的字符串表示。 toLocaleString()：返回对象的本地字符串表示。 valueOf()：返回对象的字符串、数值或布尔值表示（通常与toString()方法的返回值相同）。 Object 本质上是由一组无序的名值对组成，「名称」部分是一个 JavaScript 字符串，「值」部分可以是任何 JavaScript 的数据类型（包括对象和方法）。这使用户可以根据具体需求，创建出相当复杂的数据结构。 以下两种方法都可以创建一个空对象，这两种方法在语义上是相同的。第二种更方便的方法叫作「对象字面量」法。这也是 JSON 格式的核心语法，一般我们优先选择第二种方法。例如： 12var obj = new Object();var obj = &#123;&#125;; // 好的写法 「对象字面量」也可以用来在对象实例中定义一个对象： 12345678var obj = &#123; name: &quot;Carrot&quot;, &quot;for&quot;: &quot;Max&quot;, details: &#123; color: &quot;orange&quot;, size: 12 &#125;&#125; 对象的属性可以通过链式（chain）表示方法进行访问： 12obj.details.color; // orangeobj[&quot;details&quot;][&quot;size&quot;]; // 12 完成创建后，对象属性可以通过如下两种方式进行赋值和访问： 12345obj.name = &quot;Simon&quot; // 赋值var name = obj.name; // 访问obj[&quot;name&quot;] = &quot;Simon&quot;; // 赋值var name = obj[&quot;name&quot;]; // 访问 对象不同于原始值，对象是可修改的，即他们的值可以改变； 123456let object = &#123; x:1&#125;对象的属性访问：object.xlet arr = [1,2,3]数组的访问：arr[0] 对象不是按值比较的，两个不同的对象即使拥有完全相同的属性和值，它们也不相等。同样，两个不同的数组，即使每个元 素都相同，顺序也相同，它们也不相等。 1234let o = &#123;x:1&#125;,p = &#123;x:1&#125;o===p =&gt;falselet a = [],b = [];a===b =&gt;false 对象被称作引用类型，以区别于js的原始类型。对象值就是引用，对象是按引用比较的。两个对象值当且仅当它们引用同一个 底层对象时，才是相等的。 7）变量声明与赋值变量是通过var或let关键字声明的 1234let i;let sum;var i ;var sum; 也可以使用一条var&#x2F;let语句声明多个变量； 12let i,sum;var i,sum; 声明变量的同时也为其赋值是一个好的编程习惯； 12let msg = &quot;Hello World&quot;;let i = 0;j = 0;k = 0; 如果在var&#x2F;let语句中不为变量指定初始值，变量也会被声明，但在赋值之前它的值是undefined。 const是用来声明常量的，常量在声明是必须初始化且值不能改变，尝试给常量重新赋值会抛出TypeError 12const H0 = 74;const C = 299792.458 变量的作用域是程序源代码中的一个区域，在这个区域内变量有定义。通过let和const声明的变量和常量具有块作用域。这意味着它们只在let和const语句所在的代码块中有定义。 1234console.log(i);//抛出错误if(true)&#123; let i = 0;&#125; 在同一个作用域中使用多个let或const声明同一个名字是语法错误。在嵌套作用域中声明同名变量是合法的（最好不要这么做） 1234567const x = 1;if(x === 1)&#123; let x = 2; console.log(2)//打印2&#125;console.log(x);//打印1，回到全局作用域let x = 3;//报错 使用var和let声明的区别： 使用var声明的变量不具有块作用域，这种变量的作用域仅限于包含函数的函数体，无论它们在函数中嵌套的层次有多深。 如果在函数体外使用var声明，会声明一个全局变量。通过var声明的全局变量可以通过globalThis引用，因此，如果在函数外部写了var x &#x3D;2,则相当于globalThis.x &#x3D; 2; 使用var多次声明同名变量是合法的。 var声明变量的特性是作用域提升。在使用var声明变量时，该声明会被提高到包含函数的顶部。但变量的初始化仍然在代码所在位置完成，只有变量的定义转移到了函数顶部。","categories":[{"name":"javascript","slug":"javascript","permalink":"http://example.com/categories/javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://example.com/tags/javascript/"}]},{"title":"javascript词法结构","slug":"javascript词法结构","date":"2017-04-22T13:22:48.000Z","updated":"2022-05-26T02:13:17.088Z","comments":true,"path":"2017/04/22/javascript词法结构/","link":"","permalink":"http://example.com/2017/04/22/javascript%E8%AF%8D%E6%B3%95%E7%BB%93%E6%9E%84/","excerpt":"","text":"词法结构1）区分大小写JavaScript 是区分大小写的。也就是说，关键字、变量、函数名和所有的标识符（identifier）都必须采取一致的大小写形式。 比如，关键字 while 必须写成 while，而不能写成 While 或者 WHILE。同样，online、Online、OnLine、ONLINE 是4个不同的 变量名。 但需要注意的是，HTML 并不区分大小写。由于它和客户端 JavaScript 联系紧密，因此这点区别很容易混淆。许多客户端 JavaScript 对象和属性与他们所表示的 HTML 标签和属性名相同。在 HTML 中，这些标签和属性名可以使用大写也可以是小 写，而在 JavaScript 中则必须是小写。例如，在 HTML 中设置事件处理程序时，onclick 属性可以写成 onClick，但在 JavaScript 代码中，必须使用小写的 onclick。 1234var userName = &#x27;张三&#x27;;var username = &#x27;李四&#x27;;console.log(userName);console.log(username) 2）注释JavaScript 使用 C 风格的注释，包括单行注释和块级注释。单行注释以两个斜杠 // 开头，块级注释以一个斜杠和一个星号 /* 开头，以一个星号和一个斜杠 */ 结尾。下面都是合法的 JavaScript 注释： 12345// 这是单行注释/*** * 这是多行注释 * 这是多行注释***/ 虽然上面注释中的第二和第三行都以一个星号开头，但这不是必须的，纯粹是为了提高注释的可读性 3）字面量所谓字面量（也可称直接量，Literal values），就是程序中直接使用的数据值。字面量只代表自身，不存储在特定位置。 JavaScript 中的字面量有：字符串、数字、布尔值、对象、数组、函数、正则表达式，以及特殊的 null 值。 12345678910&quot;hello world&quot; // 字符串123 // 数字1.2 // 小数true // 布尔值false // 布尔值/javascript/gi // 正则表达式null // 空&#123; name: &#x27;stone&#x27;, age: 20&#125; // 对象[ 1, 2, 3, 4, 5, 6, 7, 8 ] // 数组function()&#123; console.log(&#x27;good&#x27;); &#125; // 函数 4）标识符标识符用于在js代码中命名常量，变量，属性，函数和类，以及某些循环提供标记。 标识符命名规则 由数字、字母、下划线或$（美元符）组成； 不能以数字开头；并且区分大小写； 不能用关键字，保留字命名； 1234567//正确的命名方式my_name;_username;$str//错误的命名方式.myname1user 5）关键字和保留字ECMAScript 3 描述了一组具有特定用途的关键字，这些关键字可用于表示控制语句的开始或结束，或者用于执行特定操作 等。按照规则，关键字是语言保留的，不能用作标识符。以下是 ECMAScript 3 的全部关键字： 123456break delete function return typeofcase do if switch varcatch else in this voidcontinue false instanceof throw whiledebugger finally new true withdefault for null try ECMAScript 3 还将 Java 的所有关键字都作为自己的保留字，保留字也是不能当初标识符。尽管保留字还没有任何特定的用途，但他们有可能在将来被用作关键字： 123456abstract double goto native staticboolean enum implements package superbyte export import private synchronizedchar extends int protected throwsclass final interface public transientconst float long short volatile ECMAScript 5 把非严格模式下的保留字缩减为： 12class enum extends superconst export import ECMAScript 5 在严格模式下的保留字为： 123implements package publicinterface private staticlet protected yield 注意，let 和 yield 是 ECMAScript 5 新增的保留字，其他保留字都是 ECMAScript 3 定义的。为了保证兼容性，任何时候都不建议使用 ECMAScript 5 新增的保留字 let 和 yield 。 ECMAScript 还预定义了很多全局变量和函数，也应当避免把它们用作标识符： 12345678arguments Error Math RegExpArray eval NaN StringBoolean EvalError Number SyntaxErrorDate Function Object TypeErrordecodeURI Infinity parseFloat undefineddecodeURIComponent isFinite parseInt URIErrorencodeURI isNaN RangeErrorencodeURIComponent JSON ReferenceError JavaScript 的具体实现可能定义独有的全局变量和函数，每一种特定的 JavaScript 运行环境都有自己的一个全局属性列表，这一点是需要牢记的。 6）可选的分号js使用分号(;)分割语句，这对于保持代码的清晰很重要：如果没有分隔符，一条语句的结尾可能是另一条语句的开头。 js中如果两条语句分别写在两行，通常可以省略它们之间的分号。 123例如：var a = 4;var b = 3; 像这种方式可以省略分号。 如果是下面这种情况，必须加分号 1var a = 4;b = 3; 7）严格模式在 ECMAScript 5 引入了严格模式（strict mode）的概念。严格模式是为 JavaScript 定义了一种不同的解析与执行模式。在严格模式下，ECMAScript 3 中的一些不确定的行为将得到处理，而且对某些不安全的操作也会抛出错误。要在整个脚本中启用严格模式，可以在顶部添加如下代码： 1&quot;use strict&quot;; 这行代码看起来像是字符串，而且也没有赋值给任何变量，但其实它是一个编译指示（pragma），用于告诉支持的 JavaScript 引擎切换到严格模式。这是为了不破坏 ECMAScript 3 语法而特意选定的语法。 在函数内部的第一行包含这条编译指示，也可以指定函数在严格模式下执行： 1234function doSomething()&#123; &quot;use strict&quot;; // 函数体&#125;","categories":[{"name":"javascript","slug":"javascript","permalink":"http://example.com/categories/javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://example.com/tags/javascript/"}]}],"categories":[{"name":"javascript","slug":"javascript","permalink":"http://example.com/categories/javascript/"},{"name":"vue","slug":"vue","permalink":"http://example.com/categories/vue/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://example.com/tags/javascript/"},{"name":"vue","slug":"vue","permalink":"http://example.com/tags/vue/"}]}