{"meta":{"title":"Valar Dohaeris","subtitle":"","description":"世上只有一种真正的英雄主义,那就是认清生活的真相后依然热爱生活","author":"烨钬","url":"http://example.com","root":"/"},"pages":[{"title":"分类","date":"2022-05-26T09:18:55.000Z","updated":"2022-05-26T09:20:04.365Z","comments":true,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""},{"title":"link","date":"2022-05-26T09:20:37.000Z","updated":"2022-05-26T09:20:52.753Z","comments":true,"path":"link/index.html","permalink":"http://example.com/link/index.html","excerpt":"","text":""},{"title":"标签页","date":"2022-05-26T09:17:40.000Z","updated":"2022-05-26T11:07:48.162Z","comments":true,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"数据分析（9）","slug":"数据分析（9）","date":"2021-05-30T07:53:51.000Z","updated":"2022-06-02T13:08:58.291Z","comments":true,"path":"2021/05/30/数据分析（9）/","link":"","permalink":"http://example.com/2021/05/30/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%EF%BC%889%EF%BC%89/","excerpt":"","text":"第9章 数据统计分析案例本章以案例为主，通过简单的知识讲解使读者了解数据统计分析中常用的分析方法，如对比分析，同比、定比和环比分析，贡献度分析，差异化分析，相关性分析和时间序列分析的概念。通过典型案例，将数据统计分析方法与前面学习的内容相结合，力求将所学内容应用到实践中。 9.1 对比分析9.1.1 什么是对比分析对比分析法是将两个或两个以上的数据进行比较，分析其中的差异，从而揭示这些事物代表的发展变化情况和规律性。特点：非常直观地看出事物某方面的变化或差距，而且可以准确、量化地表示出变化的差距是多少。对比分析法通常是把两个相互联系的指标数据进行比较，从数量上展示和说明研究对象规模的大小、水平的高低、速度的快慢，以及各种关系是否协调。对比分析一般来说有以下几种对比方法：纵向对比、横向对比、标准对比、实际与计划对比。 9.1.2 案例：对比分析各品牌销量表现TOP10案例位置：资源包\\MR\\Code\\09\\example\\01对比国产各品牌汽车2020年1月销量，效果如图9.1所示。程序代码如下： ​ 图9.1 对比分析各品牌销量表现TOP10 9.2 同比、定比和环比分析在数据分析中，有一个重要的分析方法，叫趋势分析法，即将两期或连续数期报告中某一指标进行对比，确定其增减变动的方向、数额和幅度，以确定该指标的变动趋势。趋势分析法中的指标，有同比分析、定比（定基比）分析和环比分析，以及同比增长率分析、定比（定基比）增长率分析和环比增长率分析。 9.2.1 同比、定比和环比概述首先了解一下同比、定比和环比的概念。 同比：本期数据与历史同期数据比较。例如，2021年11月份与2020年11月份相比较。 定比：本期数据与特定时期的数据比较。例如，2021年11月与2019年12月份相比较。 环比：本期数据与上期数据比较。例如，2021年11月份与2020年11月份相比较。 同比的好处是可以排除一部分季节因素；环比的好处是可以更直观地表明阶段性的变换，但是会受季节性因素影响；定比常用于财务数据分析。下面来看一个生活中经常出现的场景。 同比：去年这个这时候这条裙子我还能穿，现在穿不进去啦！ 定比：年龄，50岁是25岁的两倍。 环比：这个月好像比上个月胖了。下面简单介绍一下同比、定比和环比计算的公式。 1．同比同比的计算公式如下： 2．定比定比的计算公式如下： 3．环比环比增长率反映本期比上期增长了多少，公式如下： 环比发展速度是本期水平与前一期水平之比，反映前后两期的发展变化情况，公式如下： 9.2.2 案例1：京东电商单品销量同比增长情况分析案例位置：资源包\\MR\\Code\\09\\example\\02\\01下面分析2020年2月与2019年2月相比，京东电商《零基础学Python（全彩版）》一书销量同比增长情况，效果如图9.2所示。从分析结果得知：上海、武汉同比增长较小。 ​ 图9.2 同比分析程序代码如下： 9.2.3 案例2：单品销量定比分析案例位置：资源包\\MR\\Code\\09\\example\\02\\02下面实现京东电商《零基础学Python（全彩版）》一书2019年销量定比分析，以2019年1月为基期，基点为1，效果如图9.3所示。 ​ 图9.3 定比分析从图9.3中可以看到，6月开始呈现连续小幅度增长，到11月开始大幅度增长，定比指数较10月提高了3.028个点。程序代码如下： 9.2.4 案例3：单品销量环比增长情况分析案例位置：资源包\\MR\\Code\\09\\example\\02\\03下面分析京东电商《零基础学Python（全彩版）》一书2019年销量环比增长情况，效果如图9.4所示。 ​ 图9.4 环比分析程序代码如下： 实用技巧在使用Matplotlib绘制图表时，发现了一个警告Warining，如图9.5所示。 ​ 图9.5 警告信息完整警告信息如下：MatplotlibDeprecationWarning:Adding an axes using the same arguments as a previous axes currently reuses the earlier instance. In a future version, a new instance will always be created and returned. Meanwhile, this warning can be suppressed, and the future behavior ensured, by passing a unique label to each axes instance.“Adding an axes using the same arguments as a previous axes “解决方法：出现上述警告，原因是在创建画布fig&#x3D;plt.figure()后就设置了图表标题或坐标轴标签，将图表标题或坐标轴标签相关代码放置在定义子图ax&#x3D;fig.add_subplot(111)代码后就不会出现警告信息了。 9.3 贡献度分析（帕累托法则）9.3.1 什么是贡献度分析贡献度分析又称80&#x2F;20法则、二八法则、帕累托法则、帕累托定律、最省力法则或不平衡原则。该法则是由意大利经济学家“帕累托”提出的。80&#x2F;20法则认为：原因和结果、投入和产出、努力和报酬之间本来存在着无法解释的不平衡。例如，一个公司80%的利润常常来自20%的产品，那么使用贡献度分析就可以分析获利最高的20%的产品。下面简单介绍一下贡献率相关算法。 通过上述公式得出累计贡献率，当累计贡献率接近80%时（不一定正好是80%)，然后找到该产品在图表中相应的位置并进行标注。说明真正的比例不一定正好是80%:20%。80&#x2F;20法则表明在多数情况下该关系很可能是不平衡的，并且接近于80&#x2F;20。 9.3.2 案例：产品贡献度分析案例位置：资源包\\MR\\Code\\09\\example\\03下面分析淘宝电商全彩系列图书2018年上半年销售收入占比80%的产品。首先，使用9.3.1节中的公式计算产品累计贡献率，结果如图9.6所示。从图9.6中可以看出，到图书编号B13时，累计贡献率就已达到了0.817665（接近总销售收入的80%），其中共有10种产品，接下来在图表中进行标注，如图9.7所示。 ​ 图9.6 输出累计贡献率 ​ 图9.7 产品贡献度分析程序代码如下： 9.4 差异化分析9.4.1 差异化概述任何事物都存在差异，如同上课听讲，有人津津有味，有人昏昏欲睡。那么，通过差异化分析，比较不同事物之间在某个指标上存在的差异，根据差异定制不同的策略。对于产品而言，差异化分析是指企业在其提供给顾客的产品上，通过各种方法满足顾客的偏好，使顾客能够把它同其他竞争企业提供的同类产品有效地区别开来，从而使企业在市场竞争中占据有利的地位。比较常见的有性别差异、年龄差异。通过差异化分析比较不同性别之间在某个指标上存在的差异，通过分析结果对不同性别定制不同的方案。例如，分析不同性别的同学在学习成绩上的差异，了解男生和女生之间的这些差异，因材施教，定制不同的弥补弱项的方案。对于女生，可以有意识地培养她的思维能力；而对于男生，可以买些书籍，来增强他薄弱的方面。年龄差异化分析，了解不同年龄的需求，投其所好，使企业的利润最大化。例如，网购、自媒体、汽车、旅游等行业，通过年龄差异化分析，找出不同年龄段用户群体的喜好，从而增加产品销量。 9.4.2 案例：学生成绩性别差异分析案例位置：资源包\\MR\\Code\\09\\example\\04“女孩喜欢毛绒玩具，男孩喜欢车”这大概是天生的。科学研究表明，男孩和女孩的差别在相当程度上是由生理基础决定的。通过高科技扫描就可以发现，男孩和女孩的大脑都会有某些部位比对方相应的部位更发达、更忙碌。随着孩子的成长，这种天生的性别差异就会对孩子的学习有所影响，并且不断强化。而反过来，学习的本身也在改变着大脑的机能发育。因为当孩子玩耍和学习时，相对应的脑细胞就会更加活跃且随时更新，而那些不经常使用的部分将会逐渐退化萎缩。下面我们用数据说话，通过雷达图分析男生、女生各科成绩差异，效果如图9.8所示。 ​ 图9.8 男生、女生各科成绩差异分析从分析结果得知：男生数学和物理高于女生，而女生在英语和语文上略占优势。针对性别差异造成学习成绩的差距，应该采取因材施教，从而提高女生的数学和物理成绩 男生的语文和英语成绩。程序代码如下： 9.5 相关性分析9.5.1 相关性概述任何事物之间都存在一定的联系。例如，夏天温度的高低与空调的销量就存在相关性。当温度升高时，空调的销量也会相应提高。相关性分析是指对多个具备相关关系的数据进行分析，从而衡量数据之间的相关程度或密切程度。相关性可以应用到所有数据的分析过程中。如果一组数据的改变引发另一组数据朝相同方向变化，那么这两组数据存在正相关性，例如，身高与体重，一般个子高的人体重会重一些，个子矮的人体重会轻一些；如果一组数据的改变引发另一组数据朝相反方向变化，那么这两组数据存在负相关性，例如，运动与体重。 9.5.2 案例：广告展现量与费用成本相关性分析案例位置：资源包\\MR\\Code\\09\\example\\05为了促进销售，电商营销必然要投入广告，这样就会产生广告展现量和费用成本相关的数据。通常情况下，我们认为费用高，广告效果就好，它们之间必然存在联系，但仅通过主观判断没有说服力，无法证明数据之间关系的真实存在，也无法度量它们之间关系的强弱。因此，我们要通过相关性分析来找出数据之间的关系。下面来看一下费用成本与广告展现量相关数据情况（由于数据太多，只显示部分数据），如图9.9和图9.10所示。 ​ 图9.9 费用成本 ​ 图9.10 广告展现量相关性分析方法很多，简单的相关性分析方法是将数据进行可视化处理，单纯从数据的角度很难发现数据之间的趋势和联系，而将数据绘制成图表后就可以直观地看出数据之间的趋势和联系。下面通过散点图看一看广告展现量与费用成本的相关性，效果如图9.11所示。 ​ 图9.11 散点图首先对数据进行简单处理，由于“费用.xlsx”表中同一天会产生多个类型的费用，所以需要按天统计费用，然后将“展现量.xlsx”和“费用.xlsx”两张表的数据合并，最后绘制散点图，程序代码如下： 虽然图表清晰地展示了广告展现量与费用成本的相关性，但无法判断数据之间有什么关系，相关关系也没有准确地度量，并且数据超过两组时也无法完成各组数据的相关性分析。下面再介绍一种方法——相关系数方法。相关系数是反映数据之间关系密切程度的统计指标，相关系数的取值区间为1～-1。1表示数据之间完全正相关（线性相关）；-1表示数据之间完全负相关；0表示数据之间不相关。数据越接近0表示相关关系越弱，越接近1表示相关关系越强。计算相关系数需要一定的计算公式，而在Python中无须使用烦琐的公式，通过DataFrame对象提供的corr()函数就可以轻松实现，关键代码如下： data.corr()运行程序，输出结果如图9.12所示。 图9.12 各组数据的相关系数 从分析结果得知：“费用”与“费用”自身的相关性是1，与“展现量”“点击量”的相关系数分别是0.856013、0.858597；“展现量”与“展现量”自身的相关性是1，与“点击量”“订单金额”的相关系数分别是0.938554、0.728037。那么，除了“商品关注数”相关系数比较低，其他都很高，可以看出“费用”与“展现量”“点击量”等有一定的正相关性，而且相关性很强。相关系数的优点是可以通过数字对变量的关系进行度量，并且带有方向性，1表示正相关，-1表示负相关，越靠近0相关性越弱。缺点是无法利用这种关系对数据进行预测。 9.6 时间序列分析9.6.1 时间序列概述顾名思义，时间序列就是按照时间顺序排列的一组数据序列。时间序列分析就是找出数据变化发展的规律，从而预测未来的走势。时间序列分析有以下几种表现形式。 长期趋势变化：受某种因素的影响，数据依据时间变化，按某种规则稳步增长或下降。使用的分析方法有移动平均法、指数平滑法等。 季节性周期变化：受季节更替等因素影响，数据依据固定周期规则性的变化。季节性周期变化，不局限于自然季节，还包括月、周等短期周期。例如，空调、羽绒服、冷饮的销售，双十一、双十二流量在一周之内的波动等。采用的方法为季节指数。 循环变化：指一种较长时间的上、下起伏周期性波动，一般循环时间为2～15年。 随机性变化：由许多不确定因素引起的数据变化，在时间序列中无法预计。 9.6.2 案例：年增长趋势和季节性波动分析案例位置：资源包\\MR\\Code\\09\\example\\06下面分析淘宝店铺近3年增长趋势和季节性波动，如图9.13所示。从分析结果得出，近3年淘宝店铺收入呈现持续稳定增长趋势，但2019年有所下降，季节性波动比较明显，每年的第4季度是销售“旺季”。程序代码如下： ​ 图9.13 年增长趋势和季节性波动 9.7 小结本章通过常用的数据分析方法并结合图表，以案例的形式呈现，每一种分析方法都对应一个恰当的分析案例，一张贴切的图表，力求使读者能够真正理解数据分析，并将其应用到实际数据分析工作中。每一个案例都经过作者反复揣摩，希望能够对读者有所帮助。","categories":[{"name":"python","slug":"python","permalink":"http://example.com/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"http://example.com/tags/python/"}]},{"title":"数据分析（8）Numpy","slug":"数据分析（8）","date":"2021-05-30T06:53:51.000Z","updated":"2022-06-02T13:06:12.222Z","comments":true,"path":"2021/05/30/数据分析（8）/","link":"","permalink":"http://example.com/2021/05/30/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%EF%BC%888%EF%BC%89/","excerpt":"","text":"第8章图解数组计算模块NumPyNumPy为数据分析三剑客之一，主要用于数组计算、矩阵运算和科学计算。对于本章的学习，建议初学者灵活学习，重点掌握数组创建、数组的简单操作和计算即可。为了便于理解，本章运用了大量的示意图，用例简单，力求使您能够轻松地融入NumPy的学习中。通过典型案例，让您充分理解NumPy、应用NumPy。下面让我们揭开NumPy神秘的面纱，开启NumPy之旅。 8.1初识NumPy8.1.1NumPy概述NumPy（见图8.1），更像是一个魔方（见图8.2），它是Python数组计算、矩阵运算和科学计算的核心库，NumPy这个词来源于Numerical和Python两个单词。NumPy提供了一个高性能的数组对象，让我们轻松创建一维数组、二维数组和多维数组，以及大量的函数和方法，帮助我们轻松地进行数组计算，从而广泛地应用于数据分析、机器学习、图像处理和计算机图形学、数学任务等领域当中。 ​ 图8.1 NumPy ​ 图8.2 魔方NumPy的用途是以数组的形式对数据进行操作。机器学习中充斥了大量的数组运算，而NumPy使得这些操作变得简单！由于NumPy是C语言实现的，所以其运算速度非常快。具体功能如下。 有一个强大的n维数组对象ndarray。 广播功能函数。 线性代数、傅立叶变换、随机数生成、图形操作等功能。 整合C&#x2F;C++&#x2F;Fortran代码的工具。 8.1.2 安装NumPy模块安装NumPy有两种方法。 1．使用pip安装安装NumPy最简单的方法是使用pip工具，安装命令如下： pip install pip 2．在PyCharm开发环境中安装（1）运行PyCharm，选择File→Settings命令，打开Settings对话框，选择Project Interpreter选项，然后单击添加模块的按钮，如图8.3所示。 ​ 图8.3 单击添加模块的按钮（2）在搜索栏中输入需要添加的模块名称为numpy，然后选择需要安装的模块，如图8.4所示。单击Install Package按钮即可安装NumPy模块。 3．安装验证测试是否安装成功，程序代码如下： 01 from numpy import * #导入numpy库02 print(eye(4)) #生成对角矩阵运行程序，输出结果如下： 图8.4 在PyCharm开发环境中安装NumPy模块 8.1.3 数组相关概念学习NumPy前，我们先了解一下数组相关概念。数组可分为一维数组、二维数组、三维数组，其中三维数组是常见的多维数组，如图8.5所示。 ​ 图8.5 数组示意图1．一维数组一维数组很简单，基本和Python列表一样，区别在于数组切片针对的是原始数组（这就意味着，如果对数组进行修改，原始数组也会跟着更改）。2．二维数组二维数组本质是以数组作为数组元素的数组。二维数组包括行和列，类似于表格形状，又称为矩阵。3．三维数组三维数组是指维数为3的数组结构，也称矩阵列表。三维数组是最常见的多维数组，由于其可以用来描述三维空间中的位置或状态而被广泛使用。4．轴的概念 轴是NumPy里的axis，指定某个axis，就是沿着这个axis做相关操作，其中二维数组中两个axis的指向如图8.6所示。对于一维数组，情况有点特殊，它不像二维数组从上向下的操作，而是水平的，因此一维数组其axis&#x3D;0指向如图8.7所示。 ​ 图8.6 二维数组两个轴 ​ 图8.7 一维数组一个轴 8.2 创建数组8.2.1 创建简单的数组NumPy创建简单的数组主要使用array()函数，语法如下： numpy.array(object,dtype&#x3D;None,copy&#x3D;True,order&#x3D;’K’,subok&#x3D;False,ndmin&#x3D;0)参数说明： object：任何具有数组接口方法的对象。 dtype：数据类型。 copy：布尔型，可选参数，默认值为True，则object对象被复制；否则，只有当__array__返回副本，object参数为嵌套序列，或者需要副本满足数据类型和顺序要求时，才会生成副本。 order：元素在内存中的出现顺序，值为K、A、C、F。如果object参数不是数组，则新创建的数组将按行排列（C），如果值为F，则按列排列；如果object参数是一个数组，则C（按行）、F（按列）、A（原顺序）、K（元素在内存中的出现顺序）成立。 subok：布尔型。如果值为True，则将传递子类；否则返回的数组将强制为基类数组（默认值）。 ndmin：指定生成数组的最小维数。 【示例01】 演示如何创建数组。（示例位置：资源包\\MR\\Code\\08\\01）创建几个简单的数组，效果如图8.8所示。 ​ 图8.8 简单数组程序代码如下： 1．为数组指定数据类型【示例02】 为数组指定数据类型。（示例位置：资源包\\MR\\Code\\08\\02）NumPy支持比Python更多种类的数据类型，通过dtype参数可以指定数组的数据类型，程序代码如下： 运行程序，输出结果如下： [1. 2. 3.]float64&lt;class ‘numpy.float64’&gt; 2．数组的复制【示例03】 复制数组。（示例位置：资源包\\MR\\Code\\08\\03）当运算和处理数组时，为了不影响到原数组，就需要对原数组进行复制，而对复制后的数组进行修改删除等操作都不会影响到原数组。数组的复制可以通过copy参数实现，程序代码如下： 运行程序，输出结果如下： [1 2 3][3 2 1]数组n2是数组n1的副本，从运行结果得知：虽然修改了数组n2，但是数组n1没有发生变化。 3．通过ndmin参数控制最小维数数组可分为一维数组、二维数组和多维数组，通过ndmin参数可以控制数组的最小维数。无论给出的数据的维数是多少，ndmin参数都会根据最小维数创建指定维数的数组。 【示例04】 修改数组的维数。（示例位置：资源包\\MR\\Code\\08\\04）ndmin&#x3D;3，虽然给出的数组是一维的，但是同样会创建一个三维数组，程序代码如下：运行程序，输出结果如下： [[[1 2 3]]] 8.2.2 不同方式创建数组1．创建指定维度和数据类型未初始化的数组【示例05】 创建指定维度和未初始化的数组。（示例位置：资源包\\MR\\Code\\08\\05）创建指定维度和数据类型未初始化的数组主要使用empty()函数，程序代码如下： 01 import numpy as np02 n &#x3D; np.empty([2,3])03 print(n)运行程序，输出结果如下： [[2.22519099e-307 2.33647355e-307 1.23077925e-312][2.33645827e-307 2.67023123e-307 1.69117157e-306]]这里，数组元素为随机值，因为它们未被初始化。如果要改变数组类型，可以使用dtype参数，如整型，dtype&#x3D;int。 2．创建指定维度（以0填充）的数组【示例06】 创建指定维度（以0填充）的数组。（示例位置：资源包\\MR\\Code\\08\\06）创建指定维度并以0填充的数组，主要使用zeros()函数，程序代码如下： 01 import numpy as np02 n &#x3D; np.zeros(3)03 print(n)运行程序，输出结果如下： [0. 0. 0.]输出结果默认是浮点型（float）。 3．创建指定维度（以1填充）的数组【示例07】 创建指定维度并以1填充的数组。（示例位置：资源包\\MR\\Code\\08\\07）创建指定维度并以1填充的数组，主要使用ones()函数，程序代码如下： 01 import numpy as np02 n &#x3D; np.ones(3)03 print(n) 运行程序，输出结果如下： [1. 1. 1.] 4．创建指定维度和类型的数组并以指定值填充【示例08】 创建以指定值填充的数组。（示例位置：资源包\\MR\\Code\\08\\08）创建指定维度和类型的数组并以指定值填充，主要使用full()函数，程序代码如下： 01 import numpy as np02 n &#x3D; np.full((3,3), 8)03 print(n)运行程序，输出结果如下： [[8 8 8] [8 8 8] [8 8 8]] 8.2.3 从数值范围创建数组1．通过arange()函数创建数组arange()函数同Python内置range()函数相似，区别在于返回值，arange()函数返回值是数组，而range()函数返回值是列表。arange()函数的语法如下： arange([start,] stop[, step,], dtype&#x3D;None)参数说明： start：起始值，默认值为0。 stop：终止值（不包含）。 step：步长，默认值为1。 dtype：创建数组的数据类型，如果不设置数据类型，则使用输入数据的数据类型。 【示例09】 通过数值范围创建数组。（示例位置：资源包\\MR\\Code\\08\\09）使用arange()函数通过数值范围创建数组，程序代码如下： 01 import numpy as np02 n&#x3D;np.arange(1,12,2)03 print(n)运行程序，输出结果如下： [ 1 3 5 7 9 11] 2．使用linspace()函数创建等差数列首先简单了解一下等差数列，等差数列是指如果一个数列从第二项起，每一项与它的前一项的差等于同一个常数，那么这个数列就叫作等差数列。例如，一般成年男鞋的各种尺码，如图8.9所示。 ​ 图8.9 男鞋尺码对照表 马拉松赛前训练，一周每天的训练量（单位：m），如图8.10所示。 ​ 图8.10 训练计划在Python中创建等差数列可以使用NumPy的linspace()函数，该函数用于创建一个一维的等差数列的数组，它与arange()函数不同，arange()函数是从开始值到结束值的左闭右开区间（即包括开始值不包括结束值），第三个参数（如果存在）是步长；而linspace()函数是从开始值到结束值的闭区间（可以通过参数endpoint&#x3D;False，使结束值不是闭区间），并且第三个参数是值的个数。 知识胶囊本文经常会提到诸如“左闭右开区间”“左开右闭区间”“闭区间”等，这里简单介绍一下。“ 左闭右开区间”是指包括起始值但不包括终止值的一个数值区间； “左开右闭区间”是指不包括起始值但包括终止值的一个个数值区间； “闭区间”是指既包括起始值又包括终止值的一个数值区间。 linspace()函数语法如下： linspace(start,stop,num&#x3D;50,endpoint&#x3D;True,retstep&#x3D;False,dtype&#x3D;None)参数说明： start：序列的起始值。 stop：序列的终止值，如果endpoint参数的值为True，则该值包含于数列中。 num：要生成的等步长的样本数量，默认值为50。 endpoint：如果值为True，数列中包含stop参数的值；反之则不包含。默认值为True。 retstep：如果值为True，则生成的数组中会显示间距；反之则不显示。 dtype：数组的数据类型。 【示例10】 创建马拉松赛前训练等差数列数组。（示例位置：资源包\\MR\\Code\\08\\10）创建马拉松赛前训练等差数列数组，程序代码如下： 01 import numpy as np02 n1 &#x3D; np.linspace(7500,10000,6)03 print(n1)运行程序，输出结果如下： [ 7500. 8000. 8500. 9000. 9500. 10000.] 3．使用logspace()函数创建等比数列首先了解一下等比数列，等比数列是指从第二项起，每一项与它的前一项的比值等于同一个常数的一种数列。例如，在古印度，国王要重赏发明国际象棋的大臣，对他说：我可以满足你的任何要求，大臣说：请给我的棋盘的64个格子都放上小麦，第1个格子放1粒小麦，第2个格子放2粒小麦，第3个格子放4粒小麦，第4个格子放8粒小麦，如图8.11所示。后面每个格子里放的小麦数都是前一个格子里所放小麦数的2倍，直到第64个格子。在Python中创建等比数列可以使用NumPy的logspace()函数，语法如下： ​ 图8.11 棋盘 numpy.logspace(start, stop, num&#x3D;50, endpoint&#x3D;True, base&#x3D;10.0, dtype&#x3D;None)参数说明： start：序列的起始值。 stop：序列的终止值。如果endpoint参数值为True，则该值包含于数列中。 num：要生成的等步长的数据样本数量，默认值为50。 endpoint：如果值为True，则数列中包含stop参数值；反之则不包含。默认值为True。 base：对数log的底数。 dtype：数组的数据类型。 【示例11】 通过logspace()函数解决棋盘放置小麦的问题。（示例位置：资源包\\MR\\Code\\08\\11）通过logspace()函数计算棋盘中每个格子里放的小麦数是前一个格子里的2倍，直到第64个格子，每个格子里放多少小麦，程序代码如下： 01 import numpy as np02 n &#x3D; np.logspace(0,63,64,base&#x3D;2,dtype&#x3D;’int’)03 print(n)运行程序，输出结果如图8.12所示。 ​ 图8.12 每个格子里放的小麦数 上述举例出现一个问题：后面大数出现负数，而且都是一样的，这是由于程序中指定的数据类型是int，是32位的，数据范围为-2147483648～2147483647，而我们计算后的数据远远超出了这个范围，因此便出现了溢出现象。解决这一问题，需要指定数据类型为uint64（无符号整数，数据范围为0～18446744073709551615），关键代码如下： n &#x3D; np.logspace(0,63,64,base&#x3D;2,dtype&#x3D;’uint64’)运行程序，输出结果如图8.13所示。 ​ 图8.13 每个格子里放的小麦数以上就是每个格子里需要放的小麦数，可见发明国际象棋的大臣是多么聪明。说明关于NumPy数据类型的详细介绍可参见8.3.1节。 8.2.4 生成随机数组随机数组的生成主要使用NumPy的random模块，下面介绍几种常用的随机生成数组的函数。 1．rand()函数rand()函数用于生成(0,1)之间的随机数组，传入一个值随机生成一维数组，传入一对值则随机生成二维数组，语法如下： numpy.random.rand(d0,d1,d2,d3,…,dn)参数d0，d1，…，dn为整数，表示维度，可以为空。 【示例12】 随机生成0～1的数组。（示例位置：资源包\\MR\\Code\\08\\12）随机生成一维数组和二维数组，代码如下：运行程序，输出结果如下： 2．randn()函数randn()函数用于从正态分布中返回随机生成的数组，语法如下： numpy.random.randn(d0,d1,d2,d3,…,dn)参数d0，d1，…，dn为整数，表示维度，可以为空。 【示例13】 随机生成满足正态分布的数组。（示例位置：资源包\\MR\\Code\\08\\13）随机生成满足正态分布的数组，程序代码如下：运行程序，输出结果如下： 3．randint()函数randint()函数与NumPy的arange()函数类似。randint()函数用于生成一定范围内的随机数组，左闭右开区间，语法如下： numpy.random.randint(low,high&#x3D;None,size&#x3D;None) 参数说明： low：低值（起始值），整数，且当参数high不为空时，参数low应小于参数high；否则程序会出现错误。 high：高值（终止值），整数。 size：数组维数，整数或者元组，整数表示一维数组，元组表示多维数组。默认值为空，如果为空，则仅返回一个整数。 【示例14】 生成一定范围内的随机数组。（示例位置：资源包\\MR\\Code\\08\\14）生成一定范围内的随机数组，程序代码如下： 运行程序，输出结果如下： 4．normal()函数normal()函数用于生成正态分布的随机数，语法如下： numpy.random.normal(loc,scale,size)参数说明： loc：正态分布的均值，对应正态分布的中心。loc&#x3D;0说明是一个以y轴为对称轴的正态分布。 scale：正态分布的标准差，对应正态分布的宽度，scale值越大，正态分布的曲线越“矮胖”；scale值越小，曲线越“高瘦”。 size：表示数组维数。 【示例15】 生成正态分布的随机数组。（示例位置：资源包\\MR\\Code\\08\\15）生成正态分布的随机数组，程序代码如下： 01 import numpy as np02 n &#x3D; np.random.normal(0, 0.1, 10)03 print(n)运行程序，输出结果如下： [ 0.08530096 0.0404147 -0.00358281 0.05405901 -0.01677737 -0.02448481 0.13410224 -0.09780364 0.06095256 -0.0431846 ] 8.2.5 从已有的数组中创建数组1．asarray()函数asarray()函数用于创建数组，其与array()函数类似，语法如下： numpy.asarray(a,dtype&#x3D;None,order&#x3D;None)参数说明： a：可以是列表、列表的元组、元组、元组的元组、元组的列表或多维数组。 dtype：数组的数据类型。 order：值为C和F，分别代表按行排列和按列排列，即数组元素在内存中的出现顺序。 【示例16】 使用asarray()函数创建数组。（示例位置：资源包\\MR\\Code\\08\\16）使用asarray()函数创建数组，程序代码如下： 运行程序，输出结果如下： 2．frombuffer()函数NumPy的ndarray()数组对象不能像Python列表一样动态地改变其大小，在做数据采集时很不方便。下面介绍如何通过frombuffer()函数实现动态数组。frombuffer()函数接受buffer输入参数，以流的形式将读入的数据转换为数组。frombuffer()函数语法如下： numpy.frombuffer(buffer,dtype&#x3D;float,count&#x3D;-1,offset&#x3D;0)参数说明： buffer：实现了__buffer__方法的对象。 dtype：数组的数据类型。 count：读取的数据数量，默认值为-1，表示读取所有数据。 offset：读取的起始位置，默认值为0。 【示例17】 将字符串“mingrisoft”转换为数组。（示例位置：资源包\\MR\\Code\\08\\17）将字符串“mingrisoft”转换为数组，程序代码如下： 01 import numpy as np02 n&#x3D;np.frombuffer(b’mingrisoft’,dtype&#x3D;’S1’)03 print(n)关键代码解析：当buffer参数值为字符串时，Python 3默认字符串是Unicode类型，所以要转成Byte string类型，需要在原字符串前加上b。 3．fromiter()函数fromiter()函数用于从可迭代对象中建立数组对象，语法如下： numpy.fromiter(iterable,dtype,count&#x3D;-1) 参数说明： iterable：可迭代对象。 dtype：数组的数据类型。 count：读取的数据数量，默认值为-1，表示读取所有数据。 【示例18】 通过可迭代对象创建数组。（示例位置：资源包\\MR\\Code\\08\\18）通过可迭代对象创建数组，程序代码如下： 运行程序，输出结果如下： [0 2 4 6 8] 4．empty_like()函数empty_like()函数用于创建一个与给定数组具有相同维度和数据类型且未初始化的数组，语法如下： numpy.empty_like(prototype,dtype&#x3D;None,order&#x3D;’K’,subok&#x3D;True)参数说明： prototype：给定的数组。 dtype：覆盖结果的数据类型。 order：指定数组的内存布局。其中C（按行）、F（按列）、A（原顺序）、K（数据元素在内存中的出现顺序）。 subok：默认情况下，返回的数组被强制为基类数组。如果值为True，则返回子类。 【示例19】 创建未初始化的数组。（示例位置：资源包\\MR\\Code\\08\\19）下面使用empty_like()函数创建一个与给定数组具有相同维数、数据类型以及未初始化的数组，程序代码如下： 01 import numpy as np 02 n &#x3D; np.empty_like([[1, 2], [3, 4]])03 print(n)运行程序，输出结果如下： [[0 0] [0 0]] 5．zeros_like()函数【示例20】 创建以0填充的数组。（示例位置：资源包\\MR\\Code\\08\\20）zeros_like()函数用于创建一个与给定数组维度和数据类型相同，并以0填充的数组，程序代码如下： 01 import numpy as np02 n &#x3D; np.zeros_like([[0.1,0.2,0.3], [0.4,0.5,0.6]])03 print(n)运行程序，输出结果如下： [[0. 0. 0.] [0. 0. 0.]]说明参数说明请参见empty_like()函数。 6．ones_like()函数【示例21】 创建以1填充的数组。（示例位置：资源包\\MR\\Code\\08\\21）ones_like()函数用于创建一个与给定数组维度和数据类型相同，并以1填充的数组，程序代码如下： 01 import numpy as np02 n &#x3D; np.ones_like([[0.1,0.2,0.3], [0.4,0.5,0.6]]) 03 print(n)运行程序，输出结果如下： [[1. 1. 1.][1. 1. 1.]]说明参数说明请参见empty_like()函数。 7．full_like()函数full_like()函数用于创建一个与给定数组维度和数据类型相同，并以指定值填充的数组，语法如下： numpy.full_like(a, fill_value, dtype&#x3D;None, order&#x3D;’K’, subok&#x3D;True)参数说明： a：给定的数组。 fill_value：填充值。 dtype：数组的数据类型，默认值为None，则使用给定数组的数据类型。 order：指定数组的内存布局。其中C（按行）、F（按列）、A（原顺序）、K（数组元素在内存中的出现顺序）。 subok：默认情况下，返回的数组被强制为基类数组。如果值为True，则返回子类。 【示例22】 创建以指定值“0.2”填充的数组。（示例位置：资源包\\MR\\Code\\08\\22）创建一个与给定数组维度和数据类型相同，并以指定值“0.2”填充的数组，程序代码如下： 运行程序，输出结果如下： [1 1 1 1 1 1][0 0 0 0 0 0][0.2 0.2 0.2 0.2 0.2 0.2] 8.3 数组的基本操作8.3.1 数据类型在对数组进行基本操作前，首先了解一下NumPy的数据类型。NumPy的数据类型比Python数据类型增加了更多种类的数值类型，如表8.1所示。为了区别Python数据类型，像bool、int、float、complex、str等数据类型的名称末尾都加了短下画线“_”。 ​ 表8.1 NumPy数据类型表 每一种数据类型都有相应的数据转换函数。举例如下： np.int8(3.141) 结果为3。 np.float64(8)结果为8.0。 np.float(True)结果为1.0。 bool(1)结果为True。在创建ndarray数组时，可以直接指定数值类型，关键代码如下： a &#x3D; np.arange(8, dtype&#x3D;float)结果为[0. 1. 2. 3. 4. 5. 6. 7.]。 注意复数不能转换成为整数类型或者浮点数，例如以下的代码会出现错误提示： float(8+ 1j) 8.3.2 数组运算不用编写循环即可对数据执行批量运算，这就是NumPy数组运算的特点，NumPy称之为矢量化。大小相等的数组之间的任何算术运算NumPy都可以实现。本节主要介绍简单的数组运算，如加、减、乘、除、幂运算等。下面创建两个简单的NumPy数组，即n1和n2，数组n1包括元素1和2，数组n2包括元素3和4，如图8.14所示。接下来实现这两个数组的运算。 ​ 图8.14 数组示意图 1．加法运算例如，加法运算是数组中对应位置的元素相加（即每行对应相加），如图8.15所示。 ​ 图8.15 数组加法运算示意图 【示例23】 数组加法运算。（示例位置：资源包\\MR\\Code\\08\\23）在程序中直接将两个数组相加即可，即n1+n2，程序代码如下：运行程序，输出结果如下： [4 6] 2．减法、乘法和除法运算除了加法运算，还可以实现数组的减法、乘法和除法，如图8.16所示。 ​ 图8.16 数组的减法、乘法和除法运算示意图 【示例24】 数组的减法、乘法和除法运算。（示例位置：资源包\\MR\\Code\\06\\24）同样，在程序中直接将两个数组相减、相乘或相除即可，程序代码如下： 运行程序，输出结果如下： [-2 -2][3 8][0.33333333 0.5 ] 3．幂运算幂是数组中对应位置元素的幂运算，用两个“*”表示，如图8.17所示。 ​ 图8.17 数组幂运算示意图 【示例25】 数组的幂运算。（示例位置：资源包\\MR\\Code\\08\\25）从图8.17中得知：数组n1的元素1和数组n2的元素3，通过幂运算得到的是1的3次幂；数组n1的元素2和数组n2的元素4，通过幂运算得到的是2的4次幂，程序代码如下： 运行程序，输出结果如下： [ 1 16] 4．比较运算【示例26】 数组的比较运算。（示例位置：资源包\\MR\\Code\\08\\26）数组的比较运算是数组中对应位置元素的比较运算，比较后的结果是布尔值数组，程序代码如下： 运行程序，输出结果如下： [False False][False False] [ True True][ True True] 5．数组的标量运算首先了解两个概念，即标量和向量。标量其实就是一个单独的数；而向量是一组数，这组数是顺序排列的，这里我们理解为数组。那么，数组的标量运算也可以理解为是向量与标量之间的运算。例如，马拉松赛前训练，一周里每天的训练量以“米”（m）为单位，下面将其转换为以“千米”为单位，如图8.18所示。 ​ 图8.18 数组的标量运算示意图 【示例27】 数组的标量运算。（示例位置：资源包\\MR\\Code\\08\\27）在程序中，米转换为千米直接输入n1&#x2F;1000即可，程序代码如下： 运行程序，输出结果如下： [ 7500 8000 8500 9000 9500 10000][ 7.5 8. 8.5 9. 9.5 10. ]上述运算过程，在NumPy中叫作“广播机制”，它是一个非常有用的功能。 8.3.3 数组的索引和切片NumPy数组元素是通过数组的索引和切片来访问和修改的，因此索引和切片是NumPy中最重要、最常用的操作。 1．索引所谓数组的索引，即用于标记数组中对应元素的唯一数字，从0开始，即数组中的第一个元素的索引是0，以此类推。NumPy数组可以使用标准Python语法x[obj]的语法对数组进行索引，其中x是数组，obj是索引。 【示例28】 获取一维数组中的元素。（示例位置：资源包\\MR\\Code\\08\\28）获取一维数组n1中索引为0的元素，程序代码如下： 01 import numpy as np02 n1&#x3D;np.array([1,2,3]) #创建一维数组03 print(n1[0]) #输出一维数组的第一个元素运行程序，输出结果如下： 1 【示例29】 获取二维数组中的元素。（示例位置：资源包\\MR\\Code\\08\\29）再举一个例子，通过索引获取二维数组中的元素，程序代码如下： 01 import numpy as np02 n1&#x3D;np.array([[1,2,3],[4,5,6]]) #创建二维数组03 print(n1[1] [2]) #输出二维数组中第2行第3列的元素运行程序，输出结果如下： 6 2．切片式索引数组的切片可以理解为对数组的分割，按照等分或者不等分，将一个数组切割为多个片段，它与Python中列表的切片操作一样。NumPy中的切片用冒号分隔切片参数来进行切片操作，语法如下： [start:stop:step]参数说明： start：起始索引。 stop：终止索引。 step：步长。 【示例30】 实现简单的数组切片操作。（示例位置：资源包\\MR\\Code\\08\\30）实现简单的切片操作，对数组n1进行切片式索引操作，如图8.19所示。 ​ 图8.19 切片式索引示意图程序代码如下： 运行程序，输出结果如下： 12[1 2][2 3][1 2]切片式索引操作需要注意以下几点。（1）索引是左闭右开区间，如上述代码中的n1[0:2]，只能取到索引从0～1的元素，而取不到索引为2的元素。（2）当没有start参数时，代表从索引0开始取数，如上述代码中的n1[:2]。（3）start、stop和step这3个参数都可以是负数，代表反向索引。以step参数为例，如图8.20所示。 ​ 图8.20 反向索引示意图 【示例31】 常用的切片式索引操作。（示例位置：资源包\\MR\\Code\\08\\31）常用的切片式索引操作，程序代码如下： 运行程序，输出结果如下： 3．二维数组索引二维数组索引可以使用array[n,m]的方式，以逗号分隔，表示第n个数组的，第m个元素。 【示例32】 二维数组的简单索引操作。（示例位置：资源包\\MR\\Code\\08\\32）创建一个3行4列的二维数组，实现简单的索引操作，效果如图8.21所示。 ​ 图8.21 二维数组索引示意图程序代码如下： 运行程序，输出结果如下： [4 5 6 7]6[ 8 9 10 11]上述代码中，n[1]表示第2个数组，n[1,2]表示第2个数组第3个元素，它等同于n[1][2]，表示数组n中第2行第3列的值，实际上n[1] [2]是先索引第一个维度得到一个数组，然后在此基础上再索引。 4．二维数组切片式索引【示例33】 二维数组的切片操作。（示例位置：资源包\\MR\\Code\\08\\33）创建一个二维数组，实现各种切片式索引操作，效果如图8.22所示。 ​ 图8.22 二维数组切片式索引示意图 程序代码如下： 运行程序，输出结果如下： 8.3.4 数组重塑数组重塑实际是更改数组的形状，例如，将原来2行3列的数组重塑为3行4列的数组。在NumPy中主要使用reshape()方法，该方法用于改变数组的形状。 1．一维数组重塑一维数组重塑就是将数组重塑为多行多列的数组。 【示例34】 将一维数组重塑为二维数组。（示例位置：资源包\\MR\\Code\\08\\34）创建一个一维数组，然后通过reshape()方法将其改为2行3列的二维数组，程序代码如下： 运行程序，输出结果如下： 需要注意的是，数组重塑是基于数组元素不发生改变的情况，重塑后的数组所包含的元素个数必须与原数组元素个数相同，如果数组元素发生改变，程序就会报错。 【示例35】 将一行古诗转换为4行5列的二维数组。（示例位置：资源包\\MR\\Code\\08\\35）将一行20列的数据转换为4行5列的二维数组，效果如图8.23所示。 ​ 图8.23 数组重塑示意图程序代码如下： 运行程序，输出结果如下： 2．多维数组重塑多维数组重塑同样使用reshape()方法。 【示例36】 将2行3列的数组重塑为3行2列的数组。（示例位置：资源包\\MR\\Code\\08\\36）将2行3列的二维数组重塑为3行2列的二维数组，程序代码如下： 运行程序，输出结果如下： 3．数组转置数组转置是指数组的行列转换，可以通过数组的T属性和transpose()函数实现。 【示例37】 将二维数组中的行列转置。（示例位置：资源包\\MR\\Code\\08\\37）通过T属性将4行6列的二维数组中的行变成列，列变成行，程序代码如下： 运行程序，输出结果如下： 【示例38】 转换客户销售数据。（示例位置：资源包\\MR\\Code\\08\\38）上述举例可能不太直观，下面再举一个例子，转换客户销售数据，对比效果如图8.24所示。 ​ 图8.24 客户销售数据转换对比示意图程序代码如下： 运行程序，输出结果如下： transpose()函数也可以实现数组转置。例如，上述举例用transpose()函数实现，关键代码如下： 01 n &#x3D; np.array([[‘A’,100],[‘B’,200],[‘C’,300],[‘D’,400],[‘E’,500]])02 print(n.transpose()) #transpose()函数行列转置运行程序，输出结果如下： 8.3.5 数组的增、删、改、查数组增、删、改、查的方法有很多种，下面介绍几种常用的方法。 1．数组的增加数组数据的增加可以按照水平方向增加数据，也可以按照垂直方向增加数据。水平方向增加数据主要使用hstack()函数，垂直方向增加数据主要使用vstack()函数。 【示例39】 为数组增加数据。（示例位置：资源包\\MR\\Code\\08\\39）创建两个二维数组，然后实现数组数据的增加，程序代码如下： 运行程序，输出结果如下： 2．数组的删除数组的删除主要使用delete()方法。 【示例40】 删除指定的数组。（示例位置：资源包\\MR\\Code\\08\\40）删除指定的数组，程序代码如下： 运行程序，输出结果如下： 那么，对于不想要的数组或数组元素还可以通过索引和切片方法只选取需要的数组或数组元素。 3．数组的修改修改数组或数组元素时，直接为数组或数组元素赋值即可。 【示例41】 修改指定的数组。（示例位置：资源包\\MR\\Code\\08\\41）修改指定的数组，程序代码如下： 运行程序，输出结果如下： 4．数组的查询数组的查询同样可以使用索引和切片方法来获取指定范围的数组或数组元素，还可以通过where()函数查询符合条件的数组或数组元素。where()函数语法如下： numpy.where(condition,x,y)上述语法，第一个参数为一个布尔数组，第二个参数和第三个参数可以是标量也可以是数组。满足条件（参数condition），输出参数x，不满足条件输出参数y。 【示例42】 按指定条件查询数组。（示例位置：资源包\\MR\\Code\\08\\42）数组查询，大于5输出2，不大于5输出0，程序代码如下： 运行程序，输出结果如下： [0 1 2 3 4 5 6 7 8 9][0 0 0 0 0 0 2 2 2 2]如果不指定参数x和y，则输出满足条件的数组元素的坐 标。例如，上述举例不指定参数x和y，关键代码如下： 01 n2&#x3D;n1[np.where(n1&gt;5)]02 print(n2)运行程序，输出结果如下： [6 7 8 9] 8.4 NumPy矩阵的基本操作在数学中经常会看到矩阵，而在程序中常用的是数组，可以简单地理解为，矩阵是数学的概念，而数组是计算机程序设计领域的概念。在NumPy中，矩阵是数组的分支，数组和矩阵有些时候是通用的，二维数组也称矩阵。下面简单介绍矩阵的基本操作。 8.4.1 创建矩阵NumPy函数库中存在两种不同的数据类型（矩阵matrix和数组array），它们都可以用于处理行列表示的数组元素，虽然它们看起来很相似，但是在这两种数据类型上执行相同的数学运算，可能得到不同的结果。在NumPy中，矩阵应用十分广泛。例如，每个图像可以被看作像素值矩阵。假设一个像素值仅为0和1，那么5×5大小的图像就是一个5×5的矩阵，如图8.25所示；而3×3大小的图像就是一个3×3的矩阵，如图8.26所示。 ​ 图8.25 5×5矩阵示意图 ​ 图8.26 3×3矩阵示意图关于矩阵就简单了解到这里，下面介绍如何在NumPy中创建矩阵。 【示例43】 创建简单矩阵。（示例位置：资源包\\MR\\Code\\08\\43）使用mat()函数创建矩阵，程序代码如下： 运行程序，输出结果如下： 从运行结果得知：mat()函数创建的是矩阵类型，array()函数创建的是数组类型，而用mat()函数创建的矩阵才能进行一些线性代数的操作。 【示例44】 使用mat()函数创建常见的矩阵。（示例位置：资源包\\MR\\Code\\08\\44）下面使用mat()函数创建常见的矩阵。（1）创建一个3×3的0（零）矩阵，程序代码如下： 运行程序，输出结果如下： （2）创建一个2×4的1矩阵，程序代码如下： 运行程序，输出结果如下： （3）使用random模块的rand()函数创建一个3×3为0～1随机产生的二维数组，并将其转换为矩阵，程序代码如下： 01 import numpy as np 02 data1 &#x3D; np.mat(np.random.rand(3,3))03 print(data1)运行程序，输出结果如下： （4）创建一个1～8的随机整数矩阵，程序代码如下： 01 import numpy as np02 data1 &#x3D; np.mat(np.random.randint(1,8,size&#x3D;(3,5)))03 print(data1)运行程序，输出结果如下： （5）创建对角矩阵，程序代码如下： 运行程序，输出结果如下： （6）创建对角线矩阵，程序代码如下： 运行程序，输出结果如下： 说明mat()函数只适用于二维矩阵，维数超过2以后，mat() 函数就不适用了，从这一点来看array()函数更具通用性。 8.4.2 矩阵运算如果两个矩阵大小相同，我们可以使用算术运算符“+”“-”“*”“&#x2F;”对矩阵进行加、减、乘、除的运算。 【示例45】 矩阵加法运算。（示例位置：资源包\\MR\\Code\\08\\45）创建两个矩阵data1和data2，实现矩阵的加法运算，效果如图8.27所示。 ​ 图8.27 矩阵的加法运算示意图程序代码如下： 运行程序，输出结果如下： 【示例46】 矩阵减法、乘法和除法运算。（示例位置：资源包\\MR\\Code\\08\\46）除了加法运算，还可以实现矩阵的减法、乘法和除法运算。接下来实现上述矩阵的减法和除法运算，程序代码如下：运行程序，输出结果如下： 当对上述矩阵实现乘法运算时，程序出现了错误，原因是矩阵的乘法运算，要求左边矩阵的列和右边矩阵的行数要一致。由于上述矩阵data2只有一行，所以导致程序出错。 【示例47】 修改矩阵并进行乘法运算。（示例位置：资源包\\MR\\Code\\08\\47） 将矩阵data2改为2×2矩阵，再进行矩阵的乘法运算，程序代码如下： 运行程序，输出结果如下： 上述举例，是两个矩阵直接相乘，称之为矩阵相乘。矩阵相乘是第一个矩阵中与该元素行号相同的元素与第二个矩阵中与该元素列号相同的元素，两两相乘后再求和，运算过程如图8.28所示。例如，1×1+2×3&#x3D;7，是第一个矩阵第1行元素与第二个矩阵第1列元素，两两相乘求和得到的。 ​ 图8.28 矩阵相乘运算过程示意图数组运算和矩阵运算的一个关键区别是矩阵相乘使用的是点乘。点乘，也称点积，是数组中元素对应位置一一相乘之后求和的操作，在NumPy中专门提供了点乘方法，即dot()方法，该方法返回的是两个数组的点积。 【示例48】 数组相乘与数组点乘比较。（示例位置：资源包\\MR\\Code\\08\\48）数组相乘与数组点乘运算，程序代码如下： 运行程序，输出结果如下： 【示例49】 矩阵元素之间的相乘运算。（示例位置：资源包\\MR\\Code\\08\\49）要实现矩阵对应元素之间的相乘可以使用multiply()函数，程序代码如下： 运行程序，输出结果如下： 8.4.3 矩阵转换1．矩阵转置【示例50】 使用T属性实现矩阵转置。（示例位置：资源包\\MR\\Code\\08\\50）矩阵转置与数组转置一样使用T属性，程序代码如下： 01 import numpy as np02 n1 &#x3D; np.mat(‘1 3 3;4 5 6;7 12 9’) #创建矩阵，使用分号隔开数据03 print(‘矩阵转置结果为：\\n’,n1.T) #矩阵转置运行程序，输出结果如下： 2．矩阵求逆【示例51】 实现矩阵逆运算。（示例位置：资源包\\MR\\Code\\08\\51）矩阵要可逆，否则意味着该矩阵为奇异矩阵（即矩阵的行列式的值为0）。矩阵求逆主要使用I属性，程序代码如下： 01 import numpy as np02 n1 &#x3D; np.mat(‘1 3 3;4 5 6;7 12 9’) #创建矩阵，使用分号隔开数据03 print(‘矩阵的逆矩阵结果为：\\n’,n1.I) #逆矩阵运行程序，输出结果如下： 8.5 NumPy常用统计分析函数8.5.1 数学运算函数NumPy包含大量的数学运算的函数，包括三角函数、算术运算函数、复数处理函数等，如表8.2所示。 ​ 表8.2 数学运算函数 下面介绍几个常用的数学运算函数。 1．算术函数（1）加、减、乘、除NumPy算术函数包含简单的加、减、乘、除运算，如add()函数、subtract()函数、multiply()函数和divide()函数。这里要注意的是，数组必须具有相同的形状或符合数组广播规则。 【示例52】 数组加、减、乘、除运算。（示例位置：资源包\\MR\\Code\\08\\52）数组加、减、乘、除运算，程序代码如下： 运行程序，输出结果如下： （2）倒数reciprocal()函数用于返回数组中各元素的倒数。如4&#x2F;3的倒数是3&#x2F;4。 【示例53】 计算数组元素的倒数。（示例位置：资源包\\MR\\Code\\08\\53）计算数组元素的倒数，程序代码如下： 01 import numpy as np02 a &#x3D; np.array([0.25, 1.75, 2, 100])03 print(np.reciprocal(a))运行程序，输出结果如下： [4. 0.57142857 0.5 0.01 ] （3）求幂power()函数将第一个数组中的元素作为底数，计算它与第二个数组中相应元素的幂。 【示例54】 数组元素的幂运算。（示例位置：资源包\\MR\\Code\\08\\54）对数组元素幂运算，程序代码如下： 01 import numpy as np02 n1 &#x3D; np.array([10, 100, 1000])03 print(np.power(n1, 3))04 n2&#x3D; np.array([1, 2, 3])05 print(np.power(n1, n2))运行程序，输出结果如下： [ 1000 1000000 1000000000][ 10 10000 1000000000] （4）取余mod()函数用于计算数组之间相应元素相除后的余数。 【示例55】 对数组元素取余。（示例位置：资源包\\MR\\Code\\08\\55）对数组元素取余，程序代码如下： 01 import numpy as np02 n1 &#x3D; np.array([10, 20, 30])03 n2 &#x3D; np.array([4, 5, -8])04 print(np.mod(n1, n2))运行程序，输出结果如下： [ 2 0 -2] 知识胶囊下面重点介绍NumPy负数取余的算法，公式如下：r&#x3D;a-n*[a&#x2F;&#x2F;n]其中r为余数，a是被除数，n是除数，“&#x2F;&#x2F;”为运算取商时保留整数的下界，即偏向于较小的整数。根据负数取余的3种情况，举例如下：r&#x3D;30-(-8)(30&#x2F;&#x2F;(-8))&#x3D;30-(-8)(-4)&#x3D;30-32&#x3D;-2r&#x3D;-30-(-8)(-30&#x2F;&#x2F;(-8))&#x3D;-30-(-8)(3)&#x3D;-30-24&#x3D;-6r&#x3D;-30-(8)(-30&#x2F;&#x2F;(8))&#x3D;-30-(8)(-4)&#x3D;-30+32&#x3D;2 2．舍入函数（1）四舍五入around()函数四舍五入在NumPy中应用比较多，主要使用around()函数，该函数返回指定小数位数的四舍五入值，语法如下： numpy.around(a,decimals)参数说明： a：数组。 decimals：舍入的小数位数，默认值为0，如果为负，整数将四舍五入到小数点左侧的位置。 【示例56】 将数组中的一组数字四舍五入。（示例位置：资源包\\MR\\Code\\08\\56）将数组中的一组数字四舍五入，程序代码如下：运行程序，输出结果如下： [ 2. 7. 100. 0. 3. -2.][ 1.55 6.82 100. 0.12 3.14 -2.35][ 0. 10. 100. 0. 0. -0.] （2）向上取整ceil()函数ceil()函数用于返回大于或者等于指定表达式的最小整数，即向上取整。 【示例57】 对数组元素向上取整。（示例位置：资源包\\MR\\Code\\08\\57）对数组元素向上取整，程序代码如下：运行程序，输出结果如下： [-1. 2. -0. 1. 15.] （3）向下取整floor()函数floor()函数用于返回小于或者等于指定表达式的最大整数，即向下取整。 【示例58】 对数组元素向下取整。（示例位置：资源包\\MR\\Code\\08\\58） 对数组元素向下取整，程序代码如下： 01 import numpy as np02 n &#x3D; np.array([-1.8, 1.66, -0.2, 0.888, 15]) #创建数组03 print(np.floor(n)) #向下取整运行程序，输出结果如下： [-2. 1. -1. 0. 15.] 3．三角函数NumPy提供了标准的三角函数，即sin()函数、cos()函数和tan()函数。 【示例59】 计算数组的正弦值、余弦值和正切值。（示例位置：资源包\\MR\\Code\\08\\59）计算数组元素的正弦值、余弦值和正切值，程序代码如下： 运行程序，输出结果如下： arcsin()函数、arccos()函数和arctan()函数用于返回给定角度的sin、cos和tan的反三角函数。这些函数的结果可以通过degrees()函数将弧度转换为角度。 【示例60】 将弧度转换为角度。（示例位置：资源包\\MR\\Code\\08\\60）首先计算不同角度的正弦值，然后使用arcsin()函数计算角度的反正弦，返回值以弧度为单位，最后使用degrees()函数将弧度转换为角度来验证结果，程序代码如下： 运行程序，输出结果如下： arccos()函数和arctan()函数的用法与arcsin()函数的用法差不多，这里不再举例。 8.5.2 统计分析函数统计分析函数是对整个NumPy数组或某条轴的数据进行统计运算，函数介绍如表8.3所示。 ​ 表8.3 统计分析函数 下面介绍几个常用的统计函数。首先创建一个数组，如图8.29所示。 ​ 图8.29 数组示意图 1．求和sum()函数【示例61】 对数组元素求和。（示例位置：资源包\\MR\\Code\\08\\61）对数组元素求和、对数组元素按行和按列求和，程序代码如下： 运行程序，输出结果如下： 2．求平均值mean()函数【示例62】 对数组元素求平均值。（示例位置：资源包\\MR\\Code\\08\\62）对数组元素求平均值、对数组元素按行求平均值和按列求平均值，关键代码如下： 运行程序，输出结果如下： 3．求最大值max()函数和最小值min()函数【示例63】 对数组元素求最大值和最小值。（示例位置：资源包\\MR\\Code\\08\\63）对数组元素求最大值和最小值，关键代码如下： 运行程序，输出结果如下： 对二维数组求最大值在实际应用中非常广泛。例如，统计销售冠军。 4．求加权平均average()函数在日常生活中，常用平均数表示一组数据的“平均水平”。在一组数据里，一个数据出现的次数称为权。将一组数据与出现的次数相乘再平均就是“加权平均”。加权平均能够反映一组数据中各个数据的重要程度，以及对整体趋势的影响。加权平均在日常生活应用非常广泛，如考试成绩、股票价格、竞技比赛等。 【示例64】 计算电商各活动销售的加权平均价。（示例位置：资源包\\MR\\Code\\08\\64）某电商在开学季、6.18、双十一、双十二等活动价格均不同，下面计算加权平均价，程序代码如下： 运行程序，输出结果如下： 加权平均价：34.84920634920635 5．中位数median()函数中位数用来衡量数据取值的中等水平或一般水平，可以避免极端值的影响。在数据处理过程中，当数据中存在少量异常值时，它不受其影响，基于这一特点，一般使用中位数来评价分析结果。那么，什么是中位数？将各个变量值按大小顺序排列起来，形成一个数列，居于数列中间位置的那个数即为中位数。例如，1、2、3、4、5这5个数，中位数就是中间的数字3，而1、2、3、4、5、6这6个数，中位数则是中间两个数的平均值，即3.5。 知识胶囊中位数与平均数不同，它不受异常值的影响。例如，将1、2、3、4、5、6改为1、2、3、4、5、288，中位数依然是3.5。 【示例65】 计算电商活动价格的中位数。（示例位置：资源包\\MR\\Code\\08\\65）计算电商在开学季、6.18、双十一、双十二等活动价格的中位数，程序代码如下：运行程序，输出结果如下： 数组排序：[33.6 34.5 36. 37.8 39. 39.8]数组中位数为：36.9 6．方差、标准差方差、标准差的定义在第4章已经介绍过了，这里不再赘述，直接进入主题。 【示例66】 求数组的方差和标准差。（示例位置：资源包\\MR\\Code\\08\\66）在NumPy中实现方差和标准差，程序代码如下：运行程序，输出结果如下： 数组方差：5.168055555555551数组标准差：2.2733357771247853 8.5.3 数组的排序数组的排序是对数组元素进行排序。 1．sort()函数使用sort()函数进行排序，直接改变原数组，参数axis指定按行排序还是按列排序。 【示例67】 对数组元素按行和列排序。（示例位置：资源包\\MR\\Code\\08\\67）对数组元素排序，程序代码如下： 运行程序，输出结果如下： 2．argsort()函数使用argsort()函数对数组进行排序，返回升序排序之后数组值从小到大的索引值。 【示例68】 对数组元素升序排序。（示例位置：资源包\\MR\\Code\\08\\68）对数组元素排序，程序代码如下： 运行程序，输出结果如下： 升序排序后的索引值：[6 3 2 0 5 8 1 4 7]排序后的顺序重构原数组：[1 2 3 4 5 6 7 8 9] 3．lexsort()函数lexsort()函数用于对多个序列进行排序。可以把它当作是对电子表格进行排序，每一列代表一个序列，排序时优先照顾靠后的列。 【示例69】 通过排序解决成绩相同学生的录取问题。（示例位置：资源包\\MR\\Code\\08\\69）某重点高中，精英班录取学生按照总成绩录取。由于名额有限，因此当总成绩相同时，数学成绩高的优先录取；当总成绩和数学成绩都相同时，按照英语成绩高的优先录取。下面使用lexsort()函数对学生成绩进行排序，程序代码如下： 运行程序，输出结果如下： 上述举例，按照数学、英语和总分进行升序排序，总成绩620分的两名同学，按照数学成绩高的优先录取原则进行第一轮排序，总分615分的两名同学，同时他们的数学成绩也相同，则按照英语成绩高的优先录取原则进行第二轮排序。 8.6 综合应用8.6.1 案例1：NumPy实现正态分布案例位置：资源包\\MR\\Code\\08\\example\\01首先简单了解一下什么是正态分布。正态分布，也称“常态分布”，又名高斯分布，它在数据分析的许多方面有着重大的影响力。正态分布是应用最广泛、最常见的一种数据分布形式。正态分布像一只倒扣的钟，两头低，中间高，左右对称，大部分数据集中在平均值附近，小部分在两端。例如，学生成绩的分布，高分和低分的成绩一般是少数，分布在两端，而大部分成绩集中在中间，如图8.30所示。下面使用NumPy生成均值为0，标准差为0.1的一维正态分布样本1000个，并用图表显示出来，效果如图8.31所示。 ​ 图8.30 学生成绩正态分布示意图 ​ 图8.31 正态分布图 程序代码如下： 8.6.2 案例2：NumPy用于图像灰度处理案例位置：资源包\\MR\\Code\\08\\example\\02首先了解一下图像，图像其实是由若干像素组成，每一个像素都有明确的位置和被分配的颜色值，因此一张图像也就构成了一个像素矩阵。例如，一张灰度图片的像素块，如图8.32所示。 ​ 图8.32 灰度图片像素矩阵示意图从图8.32得知：灰度图的数据是一个二维数组，颜色取值为0～255，其中，0为黑色，255为白色。从0～255逐渐由暗色变为亮色。由此可见，图像灰度处理是不是就可以通过数组计算来实现呢？接下来，了解一个公式，RGB转换成灰度图像的常用公式： Gray &#x3D; R0.299 + G0.587 + B*0.114其中，Gray表示灰度值，R、G、B表示红、绿、蓝颜色值，0.299、0.587、0.114表示灰度公式的固定值。 下面使用NumPy结合Matplotlib实现图像的灰度处理，程序代码如下： 上述代码，显示灰度图时，需要在imshow()函数中设置参数cmap&#x3D;”gray”。运行程序，对比效果如图8.33和图8.34所示。 ​ 图8.33 原图 ​ 图8.34 灰度图像 8.7 小结通过本章的学习，能够掌握NumPy的常用操作，即从数组创建到数组的基本操作和运算。对于数据统计分析来说，这些内容已经足够了；而对于人工智能、机器学习，还需要更加深入地学习NumPy相关知识。另外，当数据量非常大时，NumPy可以带来百倍以上的速度提升。","categories":[{"name":"python","slug":"python","permalink":"http://example.com/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"http://example.com/tags/python/"}]},{"title":"数据分析（7）","slug":"数据分析（7）","date":"2021-05-30T05:53:51.000Z","updated":"2022-06-02T13:02:17.361Z","comments":true,"path":"2021/05/30/数据分析（7）/","link":"","permalink":"http://example.com/2021/05/30/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%EF%BC%887%EF%BC%89/","excerpt":"","text":"第七章 第三方可视化数据分析图表PyechartsEcharts是一个由百度开源的数据可视化工具，而Python是一门适用于数据处理和数据分析的语言，为了适应Python的需求，Pyecharts诞生了。本章以Pyecharts 1.7.1版本为主，介绍Pyecharts的安装、链式调用、Pyecharts图表的组成，以及如何绘制柱状图、折线图、面积图、饼形图、箱形图、散点图、词云图、热力图、水球图和日历图。此外，本章还通过综合应用介绍南丁格尔玫瑰图、双y轴可视化数据分析图表的实现，以及饼形图与环形图组合图表的实现。接下来，就让我们开启Pyecharts的旅程。 7.1 Pyecharts概述7.1.1 Pyecharts简介Pyecharts是一个用于生成Echarts图表的类库。Echarts是百度开源的一个数据可视化JS库。用Echarts生成的图可视化效果非常好，而Pyecharts则是专门为了与Python衔接，方便在Python中直接使用的可视化数据分析图表。使用Pyecharts可以生成独立的网页格式的图表，还可以在flask、django中直接使用，非常方便。Pyecharts的图表类型非常多且效果非常漂亮，例如图7.1、图7.2和图7.3所示的线性闪烁图、仪表盘图和水球图。Pyecharts的图表类型主要包括Bar（柱状图／条形图）、Boxplot（箱形图）、Funnel（漏斗图）、Gauge（仪表盘）、HeatMap（热力图）、Line（折线／面积图）、Line3D（3D折线图）、Liquid（水球图）、Map（地图）、Parallel（平行坐标系）、Pie（饼图）、Polar（极坐标系）、Radar（雷达图）、Scatter（散点图）和WordCloud（词云图）等。 ​ 图7.1 线性闪烁图 ​ 图7.2 仪表盘图 ​ 图7.3 水球图 7.1.2 安装Pyecharts在anaconda命令提示符窗口中安装Pyecharts库。在系统搜索框中输入anaconda prompt，单击Anaconda Prompt打开Anaconda Prompt命令提示符窗口，使用pip工具安装，命令如下： pip install pyecharts&#x3D;&#x3D;1.7.1安装成功后，将提示安装成功的字样，如“Successfully installed pyecharts-1.7.1”。说明由于Pyecharts各个版本的相关代码有一些区别，因此这里建议安装与笔者相同的版本，以免造成不必要的麻烦。那么，对于已经安装完成的Pyecharts，可以使用如下方法查看Pyecharts的版本，代码如下： import pyechartsprint(pyecharts.version)运行程序，控制台输出结果如下： 1.7.1 如果安装版本与笔者不同，建议卸载重新安装Pyecharts 1.7.1版本。 7.1.3 绘制第一张图表【示例01】 绘制简单的柱状图。（示例位置：资源包\\MR\\Code\\07\\01）下面使用Pyecharts绘制一张简单的柱状图，具体步骤如下。（1）从pyecharts.charts库中导入Bar模块，代码如下： from pyecharts.charts import Bar #从pyecharts.charts库中导入Bar模块 （2）创建一个空的Bar()对象，代码如下： bar &#x3D; Bar()（3）定义x轴和y轴数据，其中x轴为月份，y轴为销量。代码如下： 01 bar.add_xaxis([“1月”, “2月”, “3月”, “4月”, “5月”, “6月”])02 bar.add_yaxis(“零基础学Python”, [2567, 1888, 1359, 3400, 4050, 5500])03 bar.add_yaxis(“Python趣味案例编程”, [1567, 988, 2270,3900, 2750, 3600])（4）渲染图表到HTML文件中，并存放在程序所在目录下，代码如下： bar.render(“mycharts.html”)运行程序，在程序所在路径下生成一个名为mycharts.html的HTML文件，打开该文件，效果如图7.4所示。 ​ 图7.4 绘制第一张图表以上就是我们绘制的第一张Pyecharts图表。实用技巧Pyecharts 1.0以上版本对方法的链式调用对于方法的调用可分为单独调用和链式调用。单独调用就是常规的一个方法一个方法的调用。而链式调用的关键在于方法化，现在很多开源库或者代码都使用链式调用。链式调用将所有需要调用的方法写在一个方法里，这样使得我们的代码看上去更加简洁易懂。下面以本节的“第一张图表”为例，在调用Bar模块的各个方法时，将单独调用与链式调用进行简单对比，效果如图7.5所示。 ​ 图7.5 单独调用与链式调用对比从图7.5中可以看出，链式调用将所有需要调用的方法写在了一个方法里，这样的代码看上去更加简洁易懂。当然，如果不习惯使用链式调用，单独调用也可以。 7.2 Pyecharts图表的组成Pyecharts不仅具备Matplotlib图表的一些常用功能，而且还提供了独有的、别具特色的功能。主要包括主题风格的设置、提示框、视觉映射、工具箱和区域缩放等，如图7.6所示。这些功能使得Pyecharts能够绘制出各种各样、超乎想象的图表。 ​ 图7.6 Pyecharts图表的组成 7.2.1 主题风格Pyecharts内置提供了15种不同的主题风格，并提供了便捷的定制主题的方法。主要使用Pyecharts库的options模块，通过该模块的InitOpts()方法设置图表的主题风格。下面介绍InitOpts()方法的几个关键参数。 参数说明： width：字符型，图表画布宽度，以像素为单位，例如width&#x3D;’500px’。 height：字符型，图表画布高度，以像素为单位，例如height&#x3D;’300px’。 chart_id：图表的ID，图表的唯一标识，主要用于多张图表时以区分每张图表。 page_title：字符型，网页标题。 theme：图表主题，其参数值主要由ThemeType模块提供。 bg_color：字符型，图表背景颜色，例如bg_color&#x3D;’black’或bg_color&#x3D;’#fff’。 下面详细介绍一下ThemeType模块提供的15种图表主题风格，如表7.1所示。 ​ 表7.1 theme参数设置值 【示例02】 为图表更换主题。（示例位置：资源包\\MR\\Code\\07\\02）下面为“第一张图表”更换主题，具体步骤如下所示。（1）从pyecharts.charts库中导入Bar模块，代码如下： from pyecharts.charts import Bar（2）从pyecharts库中导入options模块，代码如下： from pyecharts import options as opts（3）从pyecharts.globals库中导入主题类型模块ThemeType，代码如下： from pyecharts.globals import ThemeType（4）设置画布大小、图表主题和图表背景颜色，代码如下： （5）渲染图表到HTML文件中，并存放在程序所在目录下，代码如下： bar.render(“mycharts1.html”)运行程序，在程序所在路径下生成一个名为mycharts1.html的HTML文件，打开该文件，效果如图7.7所示。 ​ 图7.7 主题风格 7.2.2 图表标题图表标题主要通过set_global_options()方法的title_opts参数进行设置，该参数值参考options模块的TitleOpts()方法，该方法可以实现主标题、副标题、距离设置以及文字样式等。TitleOpts()方法主要参数说明如下。 title：字符型，默认值为None。主标题文本，支持换行符“\\n”。 title_link：字符型，默认值为None。主标题跳转URL链接。 title_target：字符型，默认值为None。主标题跳转链接的方式，默认值为blank，表示在新窗口打开。可选参数self，表示在当前窗口打开。 subtitle：字符型，默认值为None。副标题文本，支持换行符“\\n”。 subtitle_link：字符型，默认值为None。副标题跳转URL链接。 subtitle_target：字符型，默认值为None。副标题跳转链接的方式，默认值为blank，表示在新窗口打开。可选参数self，表示在当前窗口打开。 pos_left：字符型，默认值为None。标题距左侧的距离，其值可以是像10这样的具体像素值，也可以是像10%这样的相对于容器的高宽的百分比，还可以是left、center或right，标题将根据相应的位置自动对齐。 pos_right：字符型，默认值为None。标题距右侧的距离，其值可以是像10这样的具体像素值，也可以是像10%这样的相对于容器的高宽的百分比。 pos_top：字符型，默认值为None。标题距顶端的距离，其值可以是像10这样的具体像素值，也可以是像10%这样的相对于容器的高宽的百分比，还可以是top、middle或bottom，标题将根据相应的位置自动对齐。 pos_bottom：字符型，默认值为None。标题距底端的距离，其值可以是像10这样的具体像素值，也可以是像10%这样的相对于容器的高宽的百分比。 padding：标题内边距，单位为像素。默认值为各方向（上右下左）内边距为5，接受数组分别设定上右下左边距，例如padding&#x3D;[10,4,5,90]。 item_gap：数值型，主标题与副标题之间的间距，例如item_gap&#x3D;3.5。 title_textstyle_opts：主标题文字样式配置项，参考options模块的TextStyleOpts()方法。主要包括颜色、字体样式、字体的粗细、字体的大小以及对齐方式等。例如，设置标题颜色为红色，字体大小为16，代码如下： title_textstyle_opts&#x3D;opts.TextStyleOpts(color&#x3D;’red’,font_size&#x3D;18) subtitle_textstyle_opts：副标题文字样式配置项。同上。 【示例03】 为图表设置标题。（示例位置：资源包\\MR\\Code\\07\\03）下面为“第一张图表”设置标题，具体步骤如下所示。（1）从pyecharts.charts库中导入Bar模块，代码如下： from pyecharts.charts import Bar（2）从pyecharts库中导入options模块，代码如下： from pyecharts import options as opts（3）从pyecharts.globals库中导入主题类型模块ThemeType，代码如下： from pyecharts.globals import ThemeType（4）生成图表，设置图表标题，包括主标题、主标题字体颜色和大小、副标题、标题内边距，以及主标题与副标题之间的间距。代码如下： （5）渲染图表到HTML文件中，并存放在程序所在目录下，代码如下： bar.render(“mycharts2.html”)运行程序，在程序所在路径下生成一个名为mycharts2.html的HTML文件，打开该文件，效果如图7.8所示。 ​ 图7.8 图表标题 7.2.3 图例设置图例主要通过set_global_opts()方法的legend_opts参数进行设置，该参数值参考options模块的LegendOpts()方法。LegendOpts()方法主要参数说明如下。 is_show：布尔值，是否显示图例，值为True显示图例，值为False则不显示图例。 pos_left：字符串或数字，默认值为None。图例离容器左侧的距离，其值可以是像10这样的具体像素值，也可以是10%，表示相对于容器高宽的百分比，还可以是left、center或right，图例将根据相应的位置自动对齐。 pos_right：字符串或数字，默认值为None。图例离容器右侧的距离，其值可以是像10这样的具体像素值，也可以是10%，表示相对于容器高宽的百分比。 pos_top：字符串或数字，默认值为None。图例离容器顶端的距离，其值可以是像10这样的具体像素值，也可以是10%，表示相对于容器高宽的百分比，还可以是top、middle或bottom，图例将根据相应的位置自动对齐。 pos_bottom：字符串或数字，默认值为None。图例离容器底端的距离，其值可以是像10这样的具体像素值，也可以是10%，表示相对于容器高宽的百分比。 orient：字符串，默认值为None。图例列表的布局朝向，其值为horizontal（横向）或vertical（纵向）。 align：字符串。图例标记和文本的对齐，其值为auto、left或right，默认值为auto（自动）。根据图表的位置和orient参数（图例列表的朝向）决定。 padding：整型，图例内边距，单位为像素（px），默认值为各方向内边距为5。 item_gap：图例之间的间隔。横向布局时为水平间隔，纵向布局时为纵向间隔。默认间隔为10。 item_width：图例标记的宽度。默认宽度为25。 item_height：图例标记的高度。默认高度为14。 textstyle_opts：图例的字体样式。参考options模块的TextStyleOpts()方法。主要包括颜色、字体样式、字体的粗细、字体的大小以及对齐方式等。 legend_icon：图例标记的样式。其值为circle（圆形）、rect（矩形）、roundRect（圆角矩形）、triangle（三角形）、diamond（菱形）、pin（大头针）、arrow（箭头）或none（无），也可以设置为图片。 【示例04】 为图表设置图例。（示例位置：资源包\\MR\\Code\\07\\04）下面为“第一张图表”设置图例，具体步骤如下所示。（1）从pyecharts.charts库中导入Bar模块，代码如下： from pyecharts.charts import Bar（2）从pyecharts库中导入options模块，代码如下： from pyecharts import options as opts（3）生成图表，设置图表标题和图例。其中图例主要包括图例离容器右侧的距离、图例标记的宽度和图例标记的样式，代码如下： 运行程序，在程序所在路径下生成一个名为mycharts3.html的HTML文件，打开该文件，效果如图7.9所示。 ​ 图7.9 图例 7.2.4 提示框提示框的设置主要通过set_global_opts()方法的tooltip_opts参数进行设置，该参数值参考options模块的TooltipOpts()方法。TooltipOpts()方法主要参数说明如下。 is_show：布尔值，是否显示提示框。 trigger：提示框触发的类型，可选参数。item数据项图形触发，主要在散点图和饼图等无类目轴的图表中使用。axis坐标轴触发，主要在柱状图和折线图等使用类目轴的图表中使用。None不触发，无提示框。 trigger_on：提示框触发的条件，可选参数。mousemove鼠标移动时触发，click鼠标单击时触发，mousemove|click鼠标移动和单击的同时触发，none鼠标不移动或不单击时触发。 axis_pointer_type：指示器类型，可选参数。其值如下。 line：直线指示器。 shadow：阴影指示器。 cross：十字线指示器。 none：无指示器。 background_color：提示框的背景颜色。 border_color：提示框边框的颜色。 border_width：提示框边框的宽度。 textstyle_opts：提示框中文字的样式。参考options模块的TextStyleOpts()方法。主要包括颜色、字体样式、字体的粗细、字体的大小以及对齐方式等。 【示例05】 为图表设置提示框。（示例位置：资源包\\MR\\Code\\07\\05）下面设置提示框的样式，具体步骤如下所示。（1）导入相关模块，代码如下： 01 from pyecharts import options as opts02 from pyecharts.charts import Bar03 from pyecharts.globals import ThemeType（2）设置图表标题和图例。其中图例主要包括图例离容器右侧的距离、图例标记的宽度和图例标记的样式，代码如下： （3）生成图表，设置提示框。鼠标单击时触发提示框，设置提示框为十字线指示器，设置背景色、边框宽度和边框颜色，代码如下： 运行程序，在程序所在路径下生成一个名为mycharts5.html的HTML文件，打开该文件，效果如图7.10所示。 ​ 图7.10 提示框 7.2.5 视觉映射视觉映射主要通过set_global_opts()方法的title_opts参数进行设置，该参数值参考options模块的VisualMapOpts()方法。VisualMapOpts()方法主要参数说明如下。 is_show：布尔型，是否显示视觉映射配置。 type_：映射过渡类型，可选参数，其值为color或size。 _ _min_：整型或浮点型，颜色条的最小值。 max_：整型或浮点型，颜色条的最大值。 range_text：颜色条两端的文本，例如，High或Low。 range_color：序列。颜色范围（过渡颜色），例如range_color&#x3D;[“#FFF0F5”, “#8B008B”]。 orient：颜色条放置方式，水平（horizontal）或者竖直（vertical）。 pos_left：颜色条离左侧的距离。 dimension：颜色条映射的维度。 is_piecewise：布尔型，是否分段显示数据。【示例06】 为图表添加视觉映射。（示例位置：资源包\\MR\\Code\\07\\06）下面为图表添加视觉映射，具体步骤如下所示。（1）导入相关模块，代码如下： 01 from pyecharts import options as opts 02 from pyecharts.charts import Bar（2）为柱状图添加数据，代码如下： （3）设置图表标题和视觉映射，并生成图表，代码如下： 运行程序，在程序所在路径下生成一个名为mycharts6.html的HTML文件，打开该文件，效果如图7.11所示。 ​ 图7.11 视觉映射 7.2.6 工具箱工具箱主要通过set_global_opts()方法的title_opts参数进行设置，该参数值参考options模块的ToolboxOpts()方法。ToolboxOpts()方法主要参数说明如下。 is_show：布尔值，是否显示工具箱。 orient：工具箱的布局朝向。可选参数，默认值为None，其值为horizontal（水平）或vertical（竖直）。 pos_left：工具箱离容器左侧的距离。 pos_right：工具箱离容器右侧的距离。 pos_top：工具箱离容器顶端的距离。 pos_bottom：工具箱离容器底端的距离。 feature：工具箱中每个工具的配置项。 【示例07】 为图表添加工具箱。（示例位置：资源包\\MR\\Code\\07\\07）下面为图表添加工具箱，具体步骤如下所示。（1）导入相关模块，代码如下： 01 from pyecharts import options as opts02 from pyecharts.charts import Bar（2）绘制柱状图，代码如下： （3）添加工具箱，并生成图表，代码如下： 运行程序，在程序所在路径下生成一个名为mycharts7.html的HTML文件，打开该文件，效果如图7.12所示。 ​ 图7.12 工具箱 7.2.7 区域缩放区域缩放工具条主要通过set_global_opts()方法的datazoom_opts参数进行设置，该参数值参考options模块的DataZoomOpts()方法。DataZooDataZoomOpts()方法主要参数说明如下。 is_show：布尔值，是否显示区域缩放工具条。 type_：区域缩放工具条的类型，可选参数，其值为slider或inside。 is_realtime：布尔值，是否实时更新图表。 range_start：数据窗口范围的起始百分比，其值为0～100，表示0%～100%。 range_end：数据窗口范围的结束百分比，其值为0～100，表示0%～100%。 start_value：数据窗口的起始数值。 end_value：数据窗口范围的结束数值。 orient：区域缩放工具条的布局方式。可选参数，默认值为None，其值为horizontal（水平）或vertical（竖直）。 pos_left：工具箱离容器左侧的距离。 pos_right：工具箱离容器右侧的距离。 pos_top：工具箱离容器顶端的距离。 pos_bottom：工具箱离容器底端的距离。 【示例08】 为图表添加区域缩放。（示例位置：资源包\\MR\\Code\\07\\08）下面为图表添加区域缩放工具条，具体步骤如下所示。（1）导入相关模块，代码如下： 01 from pyecharts import options as opts02 from pyecharts.charts import Bar（2）绘制柱状图，代码如下： （3）添加区域缩放工具条，并生成图表，代码如下： 运行程序，在程序所在路径下生成一个名为mycharts8.html的HTML文件，打开该文件，效果如图7.13所示。 ​ 图7.13 区域缩放 7.3 Pyecharts图表的绘制7.3.1 柱状图——Bar模块绘制柱状图／条形图主要使用Bar模块实现，主要方法介绍如下。 add_xaxis()：x轴数据。 add_yaxis()：y轴数据。 reversal_axis()：翻转x、y轴数据。 add_dataset()：原始数据。一般来说，原始数据表达的是二维表。 【示例09】 绘制多柱状图。（示例位置：资源包\\MR\\Code\\07\\09）上述内容简单介绍了柱状图的绘制，下面通过Pandas导入Excel文件中的数据，然后绘制多柱状图，分析近7年各个电商平台的销量情况，具体步骤如下所示。（1）导入相关模块，代码如下： 01 import pandas as pd02 from pyecharts.charts import Bar03 from pyecharts import options as opts04 from pyecharts.globals import ThemeType（2）导入Excel文件，代码如下： 01 #导入Excel文件02 df &#x3D; pd.read_excel(‘books.xlsx’,sheet_name&#x3D;’Sheet2’)03 #x轴和y轴数据04 x&#x3D;list(df[‘年份’])05 y1&#x3D;list(df[‘京东’])06 y2&#x3D;list(df[‘天猫’])07 y3&#x3D;list(df[‘自营’])（3）绘制多柱状图，代码如下：运行程序，对比效果如图7.14和图7.15所示。 ​ 图7.14 数据展示 ​ 图7.15 多柱状图展示 7.3.2 折线／面积图——Line模块绘制折线／面积图主要使用Line模块的add_xaxis()方法和add_yaxis()方法实现。下面介绍add_yaxis()方法的几个主要参数。 series_name：系列名称。用于提示文本和图例标签。 y_axis：y轴数据。 color：标签文本的颜色。 symbol：标记。包括circle、rect、roundRect、triangle、diamond、pin、arrow或none，也可以设置为图片。 symbol_size：标记大小。 is_smooth：布尔值，是否为平滑曲线。 is_step：布尔值，是否显示为阶梯图。 linestyle_opts：线条样式。参考series_options.LineStyleOpts。 areastyle_opts：填充区域配置项，主要用于绘制面积图。该参数值须参考options模块的AreaStyleOpts()方法，例如areastyle_opts&#x3D;opts.AreaStyleOpts(opacity&#x3D;1)。 【示例10】 绘制折线图。（示例位置：资源包\\MR\\Code\\07\\10）下面绘制折线图，分析近7年各个电商平台的销量情况，具体步骤如下所示。（1）导入相关模块，代码如下： 01 import pandas as pd02 from pyecharts.charts import Line（2）绘制折线图，代码如下：运行程序，在程序所在路径下生成myline1.html的HTML文件，打开该文件，效果如图7.16所示。 ​ 图7.16 折线图 注意 x轴数据必须为字符串，否则图表不显示。如果数据为其他类型，需要使用str()函数转换为字符串，如x_data&#x3D;[str(i) for i in x]。 【示例11】 绘制面积图。（示例位置：资源包\\MR\\Code\\07\\11）使用Line模块还可以绘制面积图，主要通过在add_yaxis()方法中指定areastyle_opts参数，该参数值由options模块的AreaStyleOpts()方法提供。下面绘制面积图，具体步骤如下所示。（1）导入相关模块，代码如下： 01 import pandas as pd02 from pyecharts.charts import Line03 from pyecharts import options as opts（2）绘制面积图，代码如下： 运行程序，在程序所在路径下生成myline2.html的HTML文件，打开该文件，效果如图7.17所示。 ​ 图7.17 面积图 7.3.3 饼形图——Pie模块绘制饼形图主要使用Pie模块的add()方法实现。下面介绍add()方法的几个主要参数。 series_name：系列名称。用于提示文本和图例标签。 data_pair：数据项，格式为[(key1, value1), (key2, value2)]。可使用zip()函数将可迭代对象打包成元组，然后再转换为列表。 color：系列标签的颜色。 radius：饼图的半径，数组的第一项是内半径，第二项是外半径。默认设置为百分比，相对于容器高宽中较小的一项的一半。 rosetype：是否展开为南丁格尔玫瑰图（也称南丁格尔的玫瑰），通过半径区分数据大小。其值为radius或area，radius表示通过扇区圆心角展现数据的百分比，通过半径展现数据的大小；area表示所有扇区圆心角相同，仅通过半径展现数据的大小。知识胶囊南丁格尔，英国护士和统计学家，出生于意大利的一个英国上流社会的家庭。南丁格尔被描述为“在统计的图形显示方法上，是一个真正的先驱”，她发展出极坐标图饼图的形式，或称为南丁格尔玫瑰图，相当于现代圆形直方图，以说明她在管理的野战医院内，病人死亡率在不同季节的变化。她使用极坐标图饼图，向不会阅读统计报告的国会议员，报告克里米亚战争的医疗条件。 is_clockwise：饼图的扇区是否以顺时针显示。 【示例12】 饼形图分析各地区销量占比情况。（示例位置：资源包\\MR\\Code\\07\\12）下面绘制饼形图，分析各地区销量占比情况，具体步骤如下所示。（1）导入相关模块，代码如下： 01 import pandas as pd02 from pyecharts.charts import Pie03 from pyecharts import options as opts（2）导入Excel文件，并将数据处理为列表加元组的形式，代码如下： （3）创建饼形图，代码如下： 运行程序，在程序所在路径下生成mypie1.html的HTML文件，打开该文件，效果如图7.18所示。 ​ 图7.18 饼形图 7.3.4 箱形图——Boxplot模块【示例13】 绘制简单的箱形图。（示例位置：资源包\\MR\\Code\\07\\13）绘制箱形图主要使用Boxplot模块的add_xaxis()方法和add_yaxis()方法实现。下面绘制一个简单的箱形图，程序代码如下： 运行程序，在程序所在路径下生成myboxplot.html的HTML文件，打开该文件，效果如图7.19所示。 ​ 图7.19 箱形图 7.3.5 涟漪特效散点图——EffectScatter模块【示例14】 绘制简单的散点图。（示例位置：资源包\\MR\\Code\\07\\14）绘制涟漪特效散点图主要使用EffectScatter模块的add_xaxis()方法和add_yaxis()方法实现。下面绘制一个简单的涟漪特效散点图，程序代码如下： 运行程序，在程序所在路径下生成myscatter.html的HTML文件，打开该文件，效果如图7.20所示。 ​ 图7.20 涟漪特效散点图 7.3.6 词云图——WordCloud模块绘制词云图主要使用WordCloud模块的add()方法实现。下面介绍add()方法的几个主要参数。 series_name：系列名称。用于提示文本和图例标签。 data_pair：数据项。格式为[(word1,count1), (word2, count2)]。可使用zip()函数将可迭代对象打包成元组，然后再转换为列表。 shape：字符型，词云图的轮廓。其值为circle、cardioid、diamond、triangle-forward、triangle、pentagon或star。 mask_image：自定义图片（支持的图片格式为jpg、jpeg、png和ico）。该参数支持base64（一种基于64个可打印字符来表示二进制数据的方法）和本地文件路径（相对或者绝对路径都可以）。 word_gap：单词间隔。 word_size_range：单词字体大小范围。 rotate_step：旋转单词角度。 pos_left：距离左侧的距离。 pos_top：距离顶部的距离。 pos_right：距离右侧的距离。 pos_bottom：距离底部的距离。 width：词云图的宽度。 height：词云图的高度。实现词云图首先需要通过jieba模块的TextRank算法从文本中提取关键词。TextRank是一种文本排序算法，是基于著名的网页排序算法PageRank改动而来。TextRank不仅能进行关键词提取，也能做自动文摘。根据某个词所连接的所有词汇的权重（权重是指某一因素或指标相对于某一事物的重要程度，这里指某个词在整段文字中的重要程度），重新计算该词汇的权重，然后把重新计算的权重传递下去，直到这种变化达到均衡态，权重数值不再发生改变。根据最后的权重值，取其中排列靠前的词汇作为关键词。 【示例15】 绘制词云图分析用户评论内容。（示例位置：资源包\\MR\\Code\\07\\15）接下来绘制词云图，分析用户的评论内容。具体步骤如下所示。（1）安装jieba模块，运行anaconda prompt（Anaconda），通过pip命令安装jieba模块，安装命令如下： pip install jieba（2）导入相关模块，代码如下： 01 from pyecharts.charts import WordCloud02 from jieba import analyse （3）使用TextRank算法从文本中提取关键词，代码如下： （4）关键词列表，代码如下： （5）绘制词云图，代码如下： 01 mywordcloud&#x3D;WordCloud()02 mywordcloud.add(‘’,list1,word_size_range&#x3D;[20,100])03 mywordcloud.render(‘wordclound.html’)运行程序，在程序所在路径下生成wordclound.html的HTML文件，打开该文件，效果如图7.21所示。 ​ 图7.21 词云图 7.3.7 热力图——HeatMap模块【示例16】 热力图统计双色球中奖号码出现的次数。（示例位置：资源包\\MR\\Code\\07\\16） 绘制热力图主要使用HeatMap模块的add_xaxis()方法和add_yaxis()方法。下面通过热力图统计2014—2019年双色球中奖号码出现的次数，具体步骤如下所示。（1）导入相关模块，代码如下： 01 import pyecharts.options as opts02 from pyecharts.charts import HeatMap03 import pandas as pd（2）导入Excel文件，并进行数据处理，代码如下： （3）将数据转换为HeatMap支持的列表格式，代码如下： （4）绘制热力图，代码如下： 运行程序，在程序所在路径下生成heatmap.html的HTML文件，打开该文件，效果如图7.22所示。 图7.22 热力图 7.3.8 水球图——Liquid模块【示例17】 绘制水球图。（示例位置：资源包\\MR\\Code\\07\\17）绘制水球图主要使用Liquid模块的add()方法实现。下面绘制一个简单的涟漪特效散点图，程序代码如下：运行程序，在程序所在路径下生成myliquid.html的HTML文件，打开该文件，效果如图7.23所示。 ​ 图7.23 水球图 7.3.9 日历图——Calendar模块【示例18】 绘制加班日历图。（示例位置：资源包\\MR\\Code\\07\\18）绘制日历图主要使用Calendar模块的add()方法实现。下面绘制一个简单日历图，通过该日历图分析6月份加班情况，程序代码如下： 运行程序，在程序所在路径下生成calendar.html的HTML文件，打开该文件，效果如图7.24所示。 ​ 图7.24 日历图 7.4 综合应用7.4.1 案例1：南丁格尔玫瑰图案例位置：资源包\\MR\\Code\\07\\example\\01下面使用Pie模块绘制南丁格尔玫瑰图，效果如图7.25所示。南丁格尔玫瑰图主要通过绘制饼形图实现，其中一个关键点是设置rosetype参数为area，具体实现步骤如下所示。（1）导入相关模块，代码如下： 01 import pandas as pd02 from pyecharts.charts import Pie 03 from pyecharts import options as opts ​ 图7.25 南丁格尔玫瑰图（2）导入Excel文件，并对数据进行处理，代码如下： （3）绘制南丁格尔玫瑰图，代码如下： 7.4.2 案例2：双y轴可视化数据分析图表的实现（柱形图+折线图）案例位置：资源包\\MR\\Code\\07\\example\\02 双y轴顾名思义就是两个y轴，下面实现柱形图+折线图双y轴图表的绘制，其中柱形图y轴表示月销量，折线图y轴表示3个平台的月平均销量，效果如图7.26所示。 ​ 图7.26 双y轴可视化数据分析图表实现双y轴可视化数据分析图表的两个关键点：一是使用Bar模块的extend_axis()方法扩展y轴；二是对add_yaxis()方法的yaxis_index参数进行设置，该参数用于指定y轴的索引值，从0开始。双y轴索引值分别为0和1。具体实现步骤如下所示。（1）导入相关模块，代码如下： 01 import pyecharts.options as opts02 from pyecharts.charts import Bar, Line03 import pandas as pd04 import numpy（2）导入Excel文件，代码如下： （3）创建颜色列表，代码如下： colors &#x3D; [“#5793f3”, “#FFD700”, “#675bba”]（4）求平均值并保留整数位，代码如下： y_average&#x3D;list(((df[‘京东’]+df[‘天猫’]+df[‘自营’])&#x2F;3).apply(numpy.round)) （5）绘制柱形图，代码如下： （6）绘制折线图，代码如下： 7.4.3 案例3：饼形图与环形图组合图表的实现案例位置：资源包\\MR\\Code\\07\\example\\03饼形图与环形图组合，其中饼形图展示“北上广”三大主要城市的销量情况，环形图展示其他省份的销量情况，效果如图7.27所示。 ​ 图7.27 饼形图与环形图组合图表绘制饼形图与环形图组合图表的一个关键点是创建两个饼形图，并设置不同的半径（radius参数），具体实现步骤如下所示。（1）导入相关模块，代码如下： 01 import pyecharts.options as opts 02 from pyecharts.charts import Pie（2）为饼形图和环形图添加数据，代码如下： （3）饼形图与环形图组合，代码如下： 知识胶囊下面介绍一下Pyecharts的文本标签配置项。 字体基本样式：fontStyle、fontWeight、fontSize、fontFamily。 文字颜色：color。 文字描边：textBorderColor、textBorderWidth。 文字阴影：textShadowColor、textShadowBlur、textShadowOffsetX、textShadowOffsetY。 文本块或文本片段大小：lineHeight、width、height、padding。 文本块或文本片段的对齐：align、verticalAlign。 文本块或文本片段的边框、背景（颜色或图片）：backgroundColor、borderColor、borderWidth、borderRadius。 文本块或文本片段的阴影：shadowColor、shadowBlur、shadowOffsetX、shadowOffsetY。 文本块的位置和旋转：position、distance、rotate。 7.5 小结相比Matplotlib和Searnborn，Pyecharts绘制出的图表更加令人惊叹，其动感效果更是Matplotlib和Searnborn无法比拟的，但也存在不足之处，其生成的图表为网页格式，不能够随时查看，需要打开文件进行浏览。Pyecharts更适合Web程序。Pyecharts还有很多功能，由于篇幅有限不能一一进行介绍，希望读者在学习过程中能够举一反三，绘制出更多精彩的数据分析图表。","categories":[{"name":"python","slug":"python","permalink":"http://example.com/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"http://example.com/tags/python/"}]},{"title":"数据分析（5）","slug":"数据分析（5）","date":"2021-05-30T04:53:51.000Z","updated":"2022-06-02T12:59:46.584Z","comments":true,"path":"2021/05/30/数据分析（5）/","link":"","permalink":"http://example.com/2021/05/30/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%EF%BC%885%EF%BC%89/","excerpt":"","text":"第五章 matplotlib可视化数据分析图表5.1数据分析图表的作用 上述举例同是“月销量分析”结果的呈现，您更青睐哪一种？显然，数据分析图表（见图5.2）更加直观、生动和具体，它将复杂的统计数字变得简单化、通俗化、形象化，使人一目了然，便于理解和比较。数据分析图表直观地展示统计信息，使我们能够快速了解数据变化趋势、数据比较结果以及所占比例等，它对数据分析、数据挖掘起到了关键性的作用。 5.2 如何选择适合的图表类型数据分析图表的类型包括条形图、柱状图、折线图、饼图、散点图、面积图、环形图、雷达图等。此外，通过图表的相互叠加还可以生成复合型图表。不同类型的图表适用不同的场景，可以按使用目的选择合适的图表类型。下面通过一张框架图来说明，如图5.3所示。 ​ 图5.3 图表分类框架图 5.3 图表的基本组成数据分析图表有很多种，但每一种图表的绝大组成部分是基本相同的，一张完整的图表一般包括画布、图表标题、绘图区、数据系列、坐标轴、坐标轴标题、图例、文本标签、网格线等，如图5.4所示。 ​ 图5.4 图表的基本组成部分下面详细介绍各个组成部分的功能。（1）画布：图中最大的白色区域，作为其他图表元素的容器。（2）图表标题：用来概况图表内容的文字，常用的功能有设置字体、字号及字体颜色等。（3）绘图区：画布中的一部分，即显示图形的矩形区域，可改变填充颜色、位置，以便图表展示更好的图形效果。（4）数据系列：在数据区域中，同一列（或同一行）数值数据的集合构成一组数据系列，也就是图表中相关数据点的集合。图表中可以有一组到多组数据系列，多组数据系列之间通常采用不同的图案、颜色或符号来区分。图5.4中，销售额就是数据系列。（5）坐标轴及坐标轴标题：坐标轴是标识数值大小及分类的垂直线和水平线，上面有标定数据值的标志（刻度）。一般情况下，水平轴（x轴）表示数据的分类；坐标轴标题用来说明坐标轴的分类及内容，分为水平坐标轴和垂直坐标轴。图5.4中，x轴的标题是“年份”，y轴的标题是“线上销售额（元）”。（6）图例：是指示图表中系列区域的符号、颜色或形状定义数据系列所代表的内容。图例由两部分构成，即图例标示和图例项。其中，图例标示，代表数据系列的图案，即不同颜色的小方块；图例项，与图例标示对应的数据系列名称。一种图例标示只能对应一种图例项。（7）文本标签：用于为数据系列添加说明文字。（8）网格线：贯穿绘图区的线条，类似标尺可以衡量数据系列数值的标准。常用的功能有设置网格线宽度、样式、颜色、坐标轴等。 5.4 Matplotlib概述众所周知，Python绘图库有很多，各有特点，而Maplotlib是最基础的Python可视化库。学习Python数据可视化，应首先从Maplotlib学起，然后再学习其他库作为拓展。 5.4.1 Matplotlib简介Matplotlib是一个Python 2D绘图库，常用于数据可视化。它能够以多种硬拷贝格式和跨平台的交互式环境生成出版物质量的图形。Matplotlib非常强大，绘制各种各样的图表游刃有余，它将容易的事情变得更容易，困难的事情变得可能。只需几行代码就可以绘制折线图（见图5.5和图5.6）、柱形图（见图5.7）、直方图（见图5.8）、饼形图（见图5.9）、散点图（见图5.10）等。 ​ 图5.5 折线图 ​ 图5.6 多折线图 ​ 图5.7 柱形图 ​ 图5.8 直方图 ​ 图5.9 饼形图 ​ 图5.10 散点图 Matpoltlib不仅可以绘制以上最基础的图表，还可以绘制一些高级图表，如双y轴可视化数据分析图表（见图5.11）、堆叠柱形图（见图5.12）、渐变饼形图（见图5.13）、等高线图（见图5.14）。 ​ 图5.11 双y轴可视化数据分析图表 ​ 图5.12 堆叠柱形图 ​ 图5.13 渐变饼形图 ​ 图5.14 等高线图不仅如此，Matplotlib还可以绘制3D图表。例如，三维柱形图（见图5.15）、三维曲面图（见图5.16）。 ​ 图5.15 三维柱形图 ​ 图5.16 三维曲面图 综上所述，只要熟练地掌握Matplotlib的函数，以及各项参数就能够绘制出各种出乎意料的图表，满足数据分析的需求。 5.4.2 安装Matplotlibpip install matplotlib 5.4.3 Matplotlib图表之初体验创建Matplotlib图表简单的只需两步。下面将绘制第一张图表。 【示例01】 绘制第一张图表。（示例位置：资源包\\MR\\Code\\05\\01）（1）引入pyplot模块。 （2）使用Matplotlib模块的plot()方法绘制图表。 （3）输出结果，如图5.19和图5.20所示。 ​ 图5.19 简单折线图 ​ 图5.20 简单散点图 程序代码如下： 01 import matplotlib.pyplot as plt02 plt.plot([1, 2, 3, 4,5]) 【示例02】 绘制散点图。（示例位置：资源包\\MR\\Code\\05\\02）将示例01的代码稍作改动以绘制散点图，程序代码如下： 01 import matplotlib.pyplot as plt02 plt.plot([1, 2, 3, 4,5], [2, 5, 8, 12,18], ‘ro’) 5.5 图表的常用设置本节主要介绍图表的常用设置，主要包括颜色设置、线条样式、标记样式、设置画布、坐标轴、添加文本标签、设置标题和图例、添加注释文本、调整图表与画布边缘间距，以及其他相关设置等。 5.5.1 基本绘图plot()函数Matplotlib基本绘图主要使用plot()函数，语法如下： matplotlib.pyplot.plot(x,y,format_string,**kwargs)参数说明： ** x：x轴数据。 y：y轴数据。 format_string：控制曲线格式的字符串，包括颜色、线条样式和标记样式。 kwargs：键值参数，相当于一个字典，比如输入参数为(1,2,3,4,k,a&#x3D;1,b&#x3D;2,c&#x3D;3)，*args&#x3D;(1,2,3,4,k)，**kwargs&#x3D;{‘a’:’1,’b’:2,’c’:3}。 【示例03】 绘制简单折线图。（示例位置：资源包\\MR\\Code\\05\\03）绘制简单的折线图，程序代码如下： 运行程序，输出结果如图5.21所示。 ​ 图5.21 简单折线图 【示例04】 绘制体温折线图。（示例位置：资源包\\MR\\Code\\05\\04）示例03中数据是通过range()函数随机创建的。下面导入Excel体温表，分析下14天基础体温情况，程序代码如下： 运行程序，输出结果如图5.22所示。 ​ 图5.22 体温折线图至此，您可能还是觉得图5.22中的图表不够完美，那么在接下来的学习中，我们将一步一步完善这张图表。下面介绍图表中线条颜色、线条样式和标记样式的设置。 1．颜色设置color参数可以设置线条颜色，通用颜色值如表5.1所示。 ​ 表5.1 通用颜色 其他颜色可以通过十六进制字符串指定，或者指定颜色名称，例如： 浮点形式的RGB或RGBA元组，例如(0.1, 0.2, 0.5)或(0.1, 0.2, 0.5, 0.3)。 十六进制的RGB或RGBA字符串，例如#0F0F0F或#0F0F0F0F。 0～1的小数作为灰度值，例如0.5。 {‘b’, ‘g’, ‘r’, ‘c’, ‘m’, ‘y’, ‘k’, ‘w’}，其中的一个颜色值。 X11&#x2F;CSS4规定中的颜色名称。 Xkcd中指定的颜色名称，例如xkcd:sky blue。 Tableau调色板中的颜色，例如{‘tab:blue’, ‘tab:orange’, ‘tab:green’, ‘tab:red’, ‘tab:purple’, ‘tab:brown’,’tab:pink’, ‘tab:gray’, ‘tab:olive’, ‘tab:cyan’}。 CN格式的颜色循环，对应的颜色设置代码如下： 01 from cycler import cycler02 colors&#x3D;[‘#1f77b4’, ‘#ff7f0e’, ‘#2ca02c’, ‘#d62728’, ‘#9467bd’, ‘#8c564b’, ‘#e377c2’,’#7f7f7f’, ‘#bcbd22’, ‘#17becf’]03 plt.rcParams[‘axes.prop_cycle’] &#x3D; cycler(color&#x3D;colors) 补充： matplotlib的依赖包cycler是matplotlib自主开发的属性组合包，功能与内置模块itertools很多函数非常相似，可用于创建特殊的迭代器。matpoltlib在属性设置底层中使用了cycler包，典型的案例就是在多数据系列绘图中循环使用颜色、线条等外观设置。使用cycler可以避免构造多重循环，更简便、灵活的组合属性。 plt（matplotlib.pyplot）使用rc配置文件来自定义图形的各种默认属性，称之为rc配置或rc参数。通过rc参数可以修改默认的属性，包括窗体大小、每英寸的点数、线条宽度、颜色、样式、坐标轴、坐标和网络属性、文本、字体等。rc参数存储在字典变量中，通过字典的方式进行访问。 序号 属性 说明1 plt.rcParams[’axes.unicode_minus’] &#x3D; False 字符显示2 plt.rcParams[’font.sans-serif’] &#x3D; ‘SimHei’ 设置字体线条样式：lines 3 plt.rcParams[’lines.linestyle’] &#x3D; ‘-.’ 线条样式4 plt.rcParams[’lines.linewidth’] &#x3D; 3 线条宽度5 plt.rcParams[’lines.color’] &#x3D; ‘blue’ 线条颜色6 plt.rcParams[’lines.marker’] &#x3D; None 默认标记7 plt.rcParams[’lines.markersize’] &#x3D; 6 标记大小8 plt.rcParams[’lines.markeredgewidth’] &#x3D; 0.5 标记附近的线宽横、纵轴：xtick、ytick 9 plt.rcParams[’xtick.labelsize’] 横轴字体大小10 plt.rcParams[’ytick.labelsize’] 纵轴字体大小11 plt.rcParams[’xtick.major.size’] x轴最大刻度12 plt.rcParams[’ytick.major.size’] y轴最大刻度figure中的子图：axes 13 plt.rcParams[’axes.titlesize’] 子图的标题大小14 plt.rcParams[’axes.labelsize’] 子图的标签大小图像、图片：figure、savefig 15 plt.rcParams[’figure.dpi’] 图像分辨率16 plt.rcParams[’figure.figsize’] 图像显示大小17 plt.rcParams[’savefig.dpi’] 图片像素 2．线条样式linestyle可选参数可以设置线条的样式，设置值如下，设置后的效果如图5.23所示。 “-”：实线，默认值。 “–”：双画线 “-.”：点画线。 “:”：虚线。 ​ 图5.23 线条样式 线条属性： 属性 描述 agg_filter a filter function, which takes a (m, n, 3) float array and a dpi value, and returns a (m, n, 3) array alpha float or None animated bool antialiased or aa bool clip_box Bbox clip_on bool clip_path Patch or (Path, Transform) or None color or c color contains unknown dash_capstyle {‘butt’, ‘round’, ‘projecting’} dash_joinstyle {‘miter’, ‘round’, ‘bevel’} dashes sequence of floats (on&#x2F;off ink in points) or (None, None) data (2, N) array or two 1D arrays drawstyle or ds {‘default’, ‘steps’, ‘steps-pre’, ‘steps-mid’, ‘steps-post’}, default: ‘default’ figure Figure fillstyle {‘full’, ‘left’, ‘right’, ‘bottom’, ‘top’, ‘none’} gid str in_layout bool label object linestyle or ls {’-’, ‘–’, ‘-.’, ‘:’, ‘’, (offset, on-off-seq), …} linewidth or lw float marker marker style string, Path or MarkerStyle markeredgecolor or mec color markeredgewidth or mew float markerfacecolor or mfc color markerfacecoloralt or mfcalt color markersize or ms float markevery None or int or (int, int) or slice or List[int] or float or (float, float) or List[bool] path_effects AbstractPathEffect picker unknown pickradius float rasterized bool or None sketch_params (scale: float, length: float, randomness: float) snap bool or None solid_capstyle {‘butt’, ‘round’, ‘projecting’} solid_joinstyle {‘miter’, ‘round’, ‘bevel’} transform matplotlib.transforms.Transform url str visible bool xdata 1D array ydata 1D array zorder float 3．标记样式marker可选参数可以设置标记样式，设置值如表5.2所示。 ​ 表5.2 标记设置 下面为“14天基础体温曲线图”设置颜色和样式，并在实际体温位置进行标记，主要代码如下： plt.plot(x,y,color&#x3D;’m’,linestyle&#x3D;’-‘,marker&#x3D;’o’,mfc&#x3D;’w’) markerfacecolor or mfc：填充颜色 运行程序，输出结果如图5.24所示。 ​ 图5.24 带标记的折线图 5.5.2 设置画布画布就像我们画画的画板一样，在Matplotlib中可以使用figure()方法设置画布大小、分辨率、颜色和边框等，语法如下： matpoltlib.pyplot.figure(num&#x3D;None, figsize&#x3D;None, dpi&#x3D;None, facecolor&#x3D;None, edgecolor&#x3D;None, frameon&#x3D;True)参数说明： num：图像编号或名称，数字为编号，字符串为名称，可以通过该参数激活不同的画布。 figsize：指定画布的宽和高，单位为英寸。 dpi：指定绘图对象的分辨率，即每英寸多少个像素，默认值为80。像素越大画布越大。 facecolor：背景颜色。 edgecolor：边框颜色。 frameon：是否显示边框，默认值为True，绘制边框；如果为False，则不绘制边框。 【示例05】 自定义画布。（示例位置：资源包\\MR\\Code\\05\\05）自定义一个5×3的黄色画布，主要代码如下： 01 import matplotlib.pyplot as plt02 fig&#x3D;plt.figure(figsize&#x3D;(5,3),facecolor&#x3D;’yellow’)运行程序，输出结果如图5.25所示。 ​ 图5.25 设置画布注意 注意 figsize&#x3D;(5,3)，因为实际画布大小是500×300，所以这里不要输入太大的数字。 5.5.3 设置坐标轴一张精确的图表，其中不免要用到坐标轴，下面介绍Matplotlib中坐标轴的使用。 1．x轴、y轴标题设置x轴和y轴标题主要使用xlabel()函数和ylabel()函数。 【示例06】 为体温折线图设置标题。（示例位置：资源包\\MR\\Code\\05\\06）设置x轴标题为“2020年2月”，y轴标题为“基础体温”，程序代码如下： 运行程序，输出结果如图5.26所示。 ​ 图5.26 带坐标轴标题的折线图实用技巧在本示例中，应注意两个问题，即中文乱码问题和符号不显示问题。它们在实际编程过程中经常出现。（1）解决中文乱码问题，代码如下： plt.rcParams[‘font.sans-serif’]&#x3D;[‘SimHei’] #解决中文乱码 （2）解决负号不显示问题，代码如下： plt.rcParams[‘axes.unicode_minus’] &#x3D; False #解决负号不显示 2．坐标轴刻度用matplotlib画二维图像时，默认情况下的横坐标（x轴）和纵坐标（y轴）显示的值有时可能达不到我们的需求，需要借助xticks()函数和yticks()函数分别对x轴和y轴的值进行设置。xticks()函数的语法如下： xticks(locs, [labels], **kwargs)参数说明： locs：数组，表示x轴上的刻度。例如，在“学生英语成绩分布图”中，x轴的刻度是2～14的偶数，如果想改变这个值，就可以通过locs参数设置。 labels：也是数组，默认值和locs相同。locs表示位置，而labels则决定该位置上的标签，如果赋予labels空值，则x轴将只有刻度而不显示任何值。 【示例07】 为折线图设置刻度1。（示例位置：资源包\\MR\\Code\\05\\07）在“14天基础体温折线图”中，x轴是从2～14的偶数，但实际日期是从1～14的连续数字，下面使用xticks()函数来解决这个问题，将x轴的刻度设置为1～14的连续数字，主要代码如下： plt.xticks(range(1,15,1)) 【示例08】 为折线图设置刻度2。（示例位置：资源包\\MR\\Code\\05\\08）在示例07中，日期看起来不是很直观。下面将x轴刻度标签直接改为日，主要代码如下： 运行程序，对比效果如图5.27和图5.28所示。接下来，设置y轴刻度，主要使用yticks()函数。例如，设置体温为35.4～38，主要代码如下： plt.yticks([35.4,35.6,35.8,36,36.2,36.4,36.6,36.8,37,37.2,37.4,37.6,37.8,38]) 3．坐标轴范围坐标轴范围是指x轴和y轴的取值范围。设置坐标轴范围主要使用xlim()函数和ylim()函数。 【示例09】 为折线图设置坐标范围。（示例位置：资源包\\MR\\Code\\05\\09）设置x轴（日期）范围为1～14，y轴（基础体温）范围为35～45，主要代码如下： 01 plt.xlim(1,14)02 plt.ylim(35,45) ​ 图5.27 更改x轴刻度 ​ 图5.28 x轴刻度为日运行程序，输出结果如图5.29所示。 4．网格线细节决定成败。很多时候为了图表的美观，不得不考虑细节。下面介绍图表细节之一——网格线，主要使用grid()函数，首先生成网格线，代码如下： plt.grid()grid()函数也有很多参数，如颜色、网格线的方向（参数axis&#x3D;’x’隐藏x轴网格线，axis&#x3D;’y’隐藏y轴网格线）、网格线样式和网格线宽度等。下面为图表设置网格线，主要代码如下： plt.grid(color&#x3D;’0.5’,linestyle&#x3D;’–’,linewidth&#x3D;1)运行程序，输出结果如图5.30所示。 ​ 图5.29 坐标轴范围 图5.30 带网格线的折线图实用技巧 网格线对于饼形图来说，直接使用并不显示，需要与饼形图的frame参数配合使用，设置该参数值为True。详见饼形图。 5.5.4 添加文本标签绘图过程中，为了能够更清晰、直观地看到数据，有时需要给图表中指定的数据点添加文本标签。下面介绍细节之二——文本标签，主要使用text()函数，语法如下： matplotlib.pyplot.text(x, y, s, fontdict&#x3D;None, withdash&#x3D;False, **kwargs)参数说明： ** x：x坐标轴的值。 y：y坐标轴的值。 s：字符串，注释内容。 ontdict：字典，可选参数，默认值为None。用于重写默认文本属性。 withdash：布尔型，默认值为False，创建一个TexWithDash实例，而不是Text实例。 kwargs：关键字参数。这里指通用的绘图参数，如字体大小fontsize&#x3D;12、垂直对齐方式horizontalalignment&#x3D;’center’（或简写为ha&#x3D;’center’）、水平对齐方式verticalalignment&#x3D;’center’（或简写为va&#x3D;’center’）。 【示例10】 为折线图添加基础体温文本标签。（示例位置：资源包\\MR\\Code\\05\\10）为图表中各个数据点添加文本标签，关键代码如下： 01 for a,b in zip(x,y):02 plt.text(a,b+3,’%.1f’%b,ha &#x3D; ‘center’,va &#x3D; ‘bottom’,fontsize&#x3D;9)运行程序，输出结果如图5.31所示。 ​ 图5.31 带文本标签的折线图在本示例代码中，首先，x、y是x轴和y轴的值，它代表了折线图在坐标中的位置，通过for循环找到每一个x、y值相对应的坐标赋值给a、b，再使用plt.text在对应的数据点上添加文本标签，而for循环也保证了折线图中每一个数据点都有文本标签。其中，a,b+3表示每一个数据点（x值对应y值加3）的位置处添加文本标签；%.1f’%b是对y值进行的格式化处理，保留小数点1位；ha&#x3D;’center’、va&#x3D;’bottom’代表水平对齐、垂直对齐的方式，fontsize则是字体大小。 5.5.5 设置标题和图例数据是一个图表所要展示的内容，而有了标题和图例则可以帮助我们更好地理解这个图表的含义和想要传递的信息。下面介绍图表细节之三——标题和图例。 1．图表标题为图表设置标题主要使用title()函数，语法如下： matplotlib.pyplot.title(label, fontdict&#x3D;None, loc&#x3D;’center’, pad&#x3D;None, **kwargs)参数说明： label：字符串，表示图表标题文本。 fontdict：字典，用来设置标题字体的样式。如{‘fontsize’: 20,’fontweight’:20,’va’: ‘bottom’,’ha’:’center’}。 loc：字符串，表示标题水平位置，参数值为center、left或right，分别表示水平居中、水平居左和水平居右，默认为水平居中。 pad：浮点型，表示标题离图表顶部的距离，默认值为None。 **kwargs：关键字参数，可以设置一些其他文本属性。例如，设置图表标题为“14天基础体温曲线图”，主要代码如下： plt.title(‘14天基础体温曲线图’,fontsize&#x3D;’18’) 2．图表图例为图表设置图例主要使用legend()函数。下面介绍图例相关的设置。（1）自动显示图例 plt.legend()（2）手动添加图例 plt.legend(‘基础体温’)注意当手动添加图例时，有时会出现文本显示不全，解决方法是在文本后面加一个逗号（,），主要代码如下： plt.legend((‘基础体温’,))（3）设置图例显示位置通过loc参数可以设置图例的显示位置，如在左下方显示，主要代码如下： plt.legend((‘基础体温’,),loc&#x3D;’upper right’,fontsize&#x3D;10)具体图例显示位置的设置如表5.3所示。 ​ 表5.3 图例位置参数设置值 上述参数可以设置大概的图例位置，如果这样可以满足需求，那么第二个参数不设置也可以。第二个参数bbox_to_anchor是元组类型，包括两个值：num1用于控制legend的左右移动，值越大越向右边移动；num2用于控制legend的上下移动，值越大，越向上移动。这两个值用于微调图例的位置。另外，通过该参数还可以设置图例位于图表外面，主要代码如下： plt.legend(bbox_to_anchor&#x3D;(1.05, 1), loc&#x3D;2, borderaxespad&#x3D;0)下面来看下设置标题和图例后的“14天基础体温曲线图”，效果如图5.32所示。 ​ 图5.32 14天基础体温曲线图 5.5.6 添加注释annotate()函数用于在图表上给数据添加文本注释，而且支持带箭头的画线工具，方便我们在合适的位置添加描述信息。 【示例11】 为图表添加注释。（示例位置：资源包\\MR\\Code\\05\\11）在“14天基础体温折线图”中用箭头指示最高体温，效果如图5.33所示。 ​ 图5.33 箭头指示最高体温主要代码如下： 01 plt.annotate(‘最高体温’, xy&#x3D;(9,37.1), xytext&#x3D;(10.5,37.1), 02 xycoords&#x3D;’data’,03 arrowprops&#x3D;dict(facecolor&#x3D;’r’, shrink&#x3D;0.05))下面介绍一下本示例中用到的几个主要参数。 xy：被注释的坐标点，二维元组，如(x,y)。 xytext：注释文本的坐标点（也就是本示例中箭头的位置），也是二维元组，默认与xy相同。 xycoords：是被注释点的坐标系属性，设置值如表5.4所示。 ​ 表5.4 xycoords参数设置值 arrowprops：箭头的样式，dict（字典）型数据。如果该属性非空，则会在注释文本和被注释点之间画一个箭头。arrowprops参数设置值如表5.5所示。 ​ 表5.5 arrowprops参数设置值说明 关于annotate()函数的内容还有很多，这里不再赘述，感兴趣的读者可以以上述举例为基础，尝试更多的属性和样式。 5.5.7 调整图表与画布边缘间距很多时候发现绘制出的图表出现显示不全的情况，其原因在于，x轴、y轴标题与画布边缘距离太近，如图5.34所示。这种情况可以使用subplots_adjust()函数来调整，该函数主要用于调整图表与画布的间距，也可以调整子图表的间距。语法如下： subplots_adjust(left&#x3D;None, bottom&#x3D;None,right&#x3D;None, top&#x3D;None,wspace&#x3D;None,hspace&#x3D;None)参数说明： left、bottom、right和top：这4个参数是用来调整上、下、左、右的空白，如图5.35所示。注意这里是从画布的左下角开始标记，取值为0～1。left和bottom值越小，则空白越少；而right和top值越大，则空白越少。 ​ 图5.34 显示不全的情况 ​ 图5.35 调整间距示意图 wspace和hspace：用于调整列间距和行间距。举个简单的例子，调整图表上、下、左、右的空白，主要代码如下： plt.subplots_adjust(left&#x3D;0.2, right&#x3D;0.9, top&#x3D;0.9, bottom&#x3D;0.2)如果只显示图片，坐标轴及标题都不显示，可以使用如下代码： plt.subplots_adjust(left&#x3D;0, bottom&#x3D;0, right&#x3D;1, top&#x3D;1,hspace&#x3D;0.1,wspace&#x3D;0.1) 5.5.8 其他设置1．坐标轴的刻度线（1）设置4个方向的坐标轴上的刻度线是否显示，主要代码如下： plt.tick_params(bottom&#x3D;False,left&#x3D;True,right&#x3D;True,top&#x3D;True)（2）设置x轴和y轴的刻度线显示方向，其中in表示向内，out表示向外，inout表示在中间，默认刻度线向外，主要代码如下： plt.rcParams[‘xtick.direction’] &#x3D; ‘in’ #x轴的刻度线向内显示plt.rcParams[‘ytick.direction’] &#x3D; ‘in’ #y轴的刻度线向内显示 2．坐标轴相关属性设置axis()：返回当前axes范围。 axis(v)：通过输入v &#x3D; [xmin, xmax, ymin, ymax]，设置x、y轴的取值范围。 axis(‘off’)：关闭坐标轴轴线及坐标轴标签。 axis(‘equal’)：使x、y轴长度一致。 axis(‘scaled’)：调整图框的尺寸（而不是改变坐标轴取值范围），使x、y轴长度一致。 axis(‘tight’)：改变x轴和y轴的限制，使所有数据被展示。如果所有的数据已经显示，它将移动到图形的中心而不修改（xmax～xmin）或（ymax～ymin）。 axis(‘image’)：缩放axis范围（limits），等同于对data缩放范围。 axis(‘auto’)：自动缩放。 axis(‘normal’)：不推荐使用。恢复默认状态，轴限的自动缩放以使数据显示在图表中。 5.6 常用图表的绘制本节介绍常用图表的绘制，主要包括绘制折线图、绘制柱形图、绘制直方图、绘制饼形图、绘制散点图、绘制面积图、绘制热力图、绘制箱形图、绘3D图表、绘制多个子图表以及图表的保存。对于常用的图表类型以绘制多种类型图表进行举例，以适应不同应用场景的需求。 5.6.1 绘制折线图折线图可以显示随时间而变化的连续数据，因此非常适用于显示在相等时间间隔下数据的趋势。如基础体温曲线图、学生成绩走势图、股票月成交量走势图，月销售统计分析图、微博、公众号、网站访问量统计图等都可以用折线图体现。在折线图中，类别数据沿水平轴均匀分布，所有值数据沿垂直轴均匀分布。Matplotlib绘制折线图主要使用plot()函数，相信通过前面的学习，您已经了解了plot()函数的基本用法，并能够绘制一些简单的折线图，下面尝试绘制多折线图。 【示例12】 绘制学生语数外各科成绩分析图。（示例位置：资源包\\MR\\Code\\05\\12）使用plot()函数绘制多折线图。例如，绘制学生语数外各科成绩分析图，程序代码如下： 运行程序，输出结果如图5.36所示。 ​ 图5.36 多折线图上述举例，用到了几个参数，下面进行说明。 mfc：标记的颜色。 ms：标记的大小。 mec：标记边框的颜色。 alpha：透明度，设置该参数可以改变颜色的深浅。 5.6.2 绘制柱形图柱形图，又称长条图、柱状图、条状图等，是一种以长方形的长度为变量的统计图表。柱形图用来比较两个或两个以上的数据（不同时间或者不同条件），只有一个变量，通常用于较小的数据集分析。Matplotlib绘制柱形图主要使用bar()函数，语法如下： matplotlib.pyplot.bar(x,height,width,bottom&#x3D;None,*,align&#x3D;’center’,data&#x3D;None,**kwargs)参数说明： ** x：x轴数据。 height：柱子的高度，也就是y轴数据。 width：浮点型，柱子的宽度，默认值为0.8，可以指定固定值。 bottom：标量或数组，可选参数，柱形图的y坐标，默认值为None。 *：星号本身不是参数。星号表示其后面的参数为命名关键字参数，命名关键字参数必须传入参数名；否则程序会出现错误。 align：对齐方式，如center（居中）和edge（边缘），默认值为center。 data：data关键字参数。如果给定一个数据参数，所有位置和关键字参数将被替换。 kwargs：关键字参数，其他可选参数，如color（颜色）、alpha（透明度）、label（每个柱子显示的标签）等。 【示例13】 4行代码绘制简单的柱形图。（示例位置：资源包\\MR\\Code\\05\\13）4行代码绘制简单的柱形图，程序代码如下： 01 import matplotlib.pyplot as plt02 x&#x3D;[1,2,3,4,5,6] 03 height&#x3D;[10,20,30,40,50,60]04 plt.bar(x,height)运行程序，输出结果如图5.37所示。 ​ 图5.37 简单柱形图bar()函数可以绘制出各种类型的柱形图，如基本柱形图、多柱形图、堆叠柱形图，只要将bar()函数的主要参数理解透彻，就会达到意想不到的效果。下面介绍几种常见的柱形图。 1．基本柱形图【示例14】 绘制2013—2019年线上图书销售额分析图。（示例位置：资源包\\MR\\Code\\05\\14）使用bar()函数绘制“2013—2019年线上图书销售额分析图”，程序代码如下： 运行程序，输出结果如图5.38所示。 ​ 图5.38 基本柱形图 本示例应用了前面所学习的知识，例如标题、图例、文本标签和坐标轴标签等。 2．多柱形图【示例15】 绘制各平台图书销售额分析图。（示例位置：资源包\\MR\\Code\\05\\15）对于线上图书销售额的统计，如果要统计各个平台的销售额，可以使用多柱形图，不同颜色的柱子代表不同的平台，如京东、天猫、自营等，程序代码如下： 在本示例中，柱形图中若显示n个柱子，则柱子宽度值需小于1&#x2F;n；否则柱子会出现重叠现象。运行程序，输出结果如图5.39所示。 ​ 图5.39 多柱形图 5.6.3 绘制直方图直方图，又称质量分布图，由一系列高度不等的纵向条纹或线段表示数据分布的情况。一般用横轴表示数据类型，纵轴表示分布情况。直方图是数值数据分布的精确图形表示，是一个连续变量（定量变量）的概率分布的估计。绘制直方图主要使用hist()函数，语法如下： matplotlib.pyplot.hist(x,bins&#x3D;None,range&#x3D;None, density&#x3D;None, bottom&#x3D;None, histtype&#x3D;’bar’, align&#x3D;’mid’, log&#x3D;False, color&#x3D;None, label&#x3D;None, stacked&#x3D;False, normed&#x3D;None)参数说明： x：数据集，最终的直方图将对数据集进行统计。 bins：统计数据的区间分布。 range：元组类型，显示的区间。 density：布尔型，显示频率统计结果，默认值为None。设置值为False，不显示频率统计结果；设置值为True，则显示频率统计结果。需要注意，频率统计结果&#x3D;区间数目&#x2F;(总数×区间宽度)。 histtype：可选参数，设置值为bar、barstacked、step或stepfilled，默认值为bar，推荐使用默认配置，其中step使用的是梯状，stepfilled则会对梯状内部进行填充，效果与bar类似。 align：可选参数，控制柱状图的水平分布，设置值为left、mid或right，默认值为mid，其中，left或者right会有部分空白区域，推荐使用默认值。 log：布尔型，默认值为False，即y坐标轴是否选择指数刻度。 stacked：布尔型，默认值为False，是否为堆积柱状图。 【示例16】 绘制简单直方图。（示例位置：资源包\\MR\\Code\\05\\16）绘制简单直方图，程序代码如下： 01 import matplotlib.pyplot as plt02 x&#x3D;[22,87,5,43,56,73,55,54,11,20,51,5,79,31,27]03 plt.hist(x, bins &#x3D; [0,25,50,75,100])运行程序，输出结果如图5.40所示。 ​ 图5.40 简单直方图 【示例17】 直方图分析学生数学成绩分布情况。（示例位置：资源包\\MR\\Code\\05\\17）再举一个例子，通过直方图分析学生数学成绩分布情况，程序代码如下： 运行程序，输出结果如图5.41所示。 图5.41 数学成绩分布直方图 上述举例，通过直方图可以清晰地看到高一数学成绩分布情况。基本呈现正态分布，两边低中间高，高分段学生缺失，说明试卷有难度。那么，通过直方图还可以分析以下内容。（1）对学生进行比较。呈正态分布的测验便于选拔优秀，甄别落后，通过直方图一目了然。（2）确定人数和分数线。测验成绩符合正态分布可以帮助等级评定时确定人数和估计分数段内的人数，确定录取分数线、各学科的优生率等。（3）测验试题难度。 5.6.4 绘制饼形图饼形图常用来显示各个部分在整体中所占的比例。例如，在工作中如果遇到需要计算总费用或金额的各个部分构成比例的情况，一般通过各个部分与总额相除来计算，而且这种比例表示方法很抽象，而通过饼形图将直接显示各个组成部分所占比例，一目了然。Matplotlib绘制饼形图主要使用pie()函数，语法如下： matplotlib.pyplot.pie(x,explode&#x3D;None,labels&#x3D;None,colors&#x3D;None,autopct&#x3D;None,pctdistance&#x3D;0.6,shadow&#x3D;False,labeldistance&#x3D;1.1,startangle&#x3D;None,radius&#x3D;None,counterclock&#x3D;True,wedgeprops&#x3D;None,textprops&#x3D;None,center&#x3D;(0, 0), frame&#x3D;False, rotatelabels&#x3D;False, hold&#x3D;None, data&#x3D;None)参数说明： x：每一块饼图的比例，如果sum(x)&gt;1会使用sum(x)归一化。 explode：每一块饼图离中心的距离。 labels：每一块饼图外侧显示的说明文字。 autopct：设置饼图百分比，可以使用格式化字符串或format()函数。如’%1.1f ‘保留小数点前后1位。 pctdistance：类似于labeldistance参数，指定百分比的位置刻度，默认值为0.6。 shadow：在饼图下面画一个阴影，默认值为False，即不画阴影。 labeldistance：标记的绘制位置，相对于半径的比例，默认值为1.1，如&lt;1则绘制在饼图内侧。 startangle：起始绘制角度，默认是从x轴正方向逆时针画起，如设置值为90则从y轴正方向画起。 radius：饼图半径，默认值为1。 counterclock：指定指针方向，布尔型，可选参数。默认值为True，表示逆时针；如果值为False，则表示顺时针。 wedgeprops：字典类型，可选参数，默认值为None。字典传递给wedge对象，用来画一个饼图。例如wedgeprops&#x3D;{‘linewidth’:2}设置wedge线宽为2。 textprops：设置标签和比例文字的格式，字典类型，可选参数，默认值为None。传递给text对象的字典参数。 center：浮点类型的列表，可选参数，默认值为(0,0)，表示图表中心位置。 frame：布尔型，可选参数，默认值为False，不显示轴框架（也就是网格）；如果值为True，则显示轴框架，与grid()函数配合使用。实际应用中建议使用默认设置，因为显示轴框架会干扰饼形图效果。 rotatelabels：布尔型，可选参数，默认值为False；如果值为True，则旋转每个标签到指定的角度。 【示例18】 绘制简单饼形图。（示例位置：资源包\\MR\\Code\\05\\18）绘制简单饼形图，程序代码如下： 01 import matplotlib.pyplot as plt02 x &#x3D; [2,5,12,70,2,9]03 plt.pie(x,autopct&#x3D;’%1.1f%%’)运行程序，输出结果如图5.42所示。饼形图也存在各种类型，主要包括基础饼形图、分裂饼形图、立体感带阴影的饼形图、环形图等。下面分别进行介绍。 1．基础饼形图【示例19】 通过饼形图分析各地区销量占比情况。（示例位置：资源包\\MR\\Code\\05\\19）下面通过饼形图分析2020年1月各地区销量占比情况，程序代码如下： 运行程序，输出结果如图5.43所示。 ​ 图5.42 简单饼形图 ​ 图5.43 基础饼形图 2．分裂饼形图分裂饼形图是将您认为主要的饼图部分分裂出来，以达到突出显示的目的。 【示例20】 绘制分裂饼形图。（示例位置：资源包\\MR\\Code\\05\\20）将销量占比最多的广东省分裂显示，效果如图5.44（a）所示。分裂饼形图可以同时分裂多块，效果如图5.44（b）所示。 ​ 图5.44 分裂饼形图分裂饼形图主要通过设置explode参数实现，该参数用于设置饼图距中心的距离，我们需要将哪块饼图分裂出来，就设置它与中心的距离即可。例如，图5.43中有10块饼图，我们将占比最多的“广东省”分裂出来，如图5.44（a）所示。广东省在第一位，那么就设置第一位距中心的距离为0.1，其他为0，关键代码如下： explode &#x3D; (0.1,0,0,0,0,0,0,0,0,0) 3．立体感带阴影的饼形图立体感带阴影的饼形图看起来更美观，效果如图5.45所示。立体感带阴影的饼形图主要通过shadow参数实现，设置该参数值为True即可，主要代码如下： shadow&#x3D;True 4．环形图【示例21】 环形图分析各地区销量占比情况。（示例位置：资源包\\MR\\Code\\05\\21）环形图是由两个及两个以上大小不一的饼图叠在一起，挖去中间的部分所构成的图形，效果如图5.46所示。 ​ 图5.45 立体感带阴影的饼形图 ​ 图5.46 环形图这里还是通过pie()函数实现，一个关键参数wedgeprops，字典类型，用于设置饼形图内、外边界的属性，如环的宽度，环边界颜色和宽度，主要代码如下： wedgeprops &#x3D; {‘width’: 0.4, ‘edgecolor’: ‘k’} 5．内嵌环形图【示例22】 内嵌环形图分析各地区销量占比情况。（示例位置：资源包\\MR\\Code\\05\\22）内嵌环形图实际是双环形图，效果如图5.47所示。 ​ 图5.47 内嵌环形图绘制内嵌环形图需要注意以下3点。（1）连续使用两次pie()函数。（2）通过wedgeprops参数设置环形边界。（3）通过radius参数设置不同的半径。另外，由于图例内容比较长，为了使图例能够正常显示，图例代码中引入了两个主要参数，即frameon和bbox_to_anchor。其中，frameon参数设置图例有无边框；bbox_to_anchor参数设置图例位置，主要代码如下： 5.6.5 绘制散点图散点图主要用来查看数据的分布情况或相关性，一般用在线性回归分析中，查看数据点在坐标系平面上的分布情况。散点图表示因变量随自变量而变化的大致趋势，据此可以选择合适的函数对数据点进行拟合。散点图与折线图类似，也是一个个点构成的。但不同之处在于，散点图的各点之间不会按照前后关系以线条连接起来。Matplotlib绘制散点图使用plot()函数和scatter()函数都可以实现，本节使用scatter()函数绘制散点图，scatter()函数专门用于绘制散点图，使用方式和plot()函数类似，区别在于前者具有更高的灵活性，可以单独控制每个散点与数据匹配，并让每个散点具有不同的属性。scatter()函数的语法如下： matplotlib.pyplot.scatter(x,y,s&#x3D;None,c&#x3D;None,marker&#x3D;None,cmap&#x3D;None,norm&#x3D;None,vmin&#x3D;None,vmax&#x3D;None,alpha&#x3D;None,linewidths&#x3D;None,verts&#x3D;None,edgecolors&#x3D;None,data&#x3D;None, **kwargs)参数说明： x，y：数据。 ​ s：标记大小，以平方磅为单位的标记面积，设置值如下。 ​ 数值标量：以相同的大小绘制所有标记。 ​ 行或列向量：使每个标记具有不同的大小。x、y和sz中的相应元素确定每个标记的位置和面积。sz的长度必须等于x和y的长度。 ​ []：使用36平方磅的默认面积。 c：标记颜色，可选参数，默认标记颜色为蓝色。 marker：标记样式，可选参数，默认值为’o’。 cmap：颜色地图，可选参数，默认值为None。 norm：可选参数，默认值为None vmin，vmax：标量，可选，默认值为None alpha：透明度，可选参数，0～1的数，表示透明度，默认值为None。 linewidths：线宽，标记边缘的宽度，可选参数，默认值为None。 verts：(x,y)的序列，可选参数，如果参数marker为None，这些顶点将用于构建标记。标记的中心位置为(0,0)。 edgecolors：轮廓颜色，与参数c类似，可选参数，默认值为None。 data：data关键字参数。如果给定一个数据参数，所有位置和关键字参数将被替换。 **kwargs：关键字参数，其他可选参数。 【示例23】 绘制简单散点图。（示例位置：资源包\\MR\\Code\\05\\23）绘制简单散点图，程序代码如下： 01 import matplotlib.pyplot as plt02 x&#x3D;[1,2,3,4,5,6]03 y&#x3D;[19,24,37,43,55,68]04 plt.scatter(x, y)运行程序，输出结果如图5.48所示。 【示例24】 散点图分析销售收入与广告费的相关性。（示例位置：资源包\\MR\\Code\\05\\24）接下来，绘制销售收入与广告费散点图，用以观察销售收入与广告费的相关性，主要代码如下： 运行程序，输出结果如图5.49所示 ​ 图5.48 简单散点图 ​ 图5.49 销售收入与广告费散点图 5.6.6 绘制面积图面积图用于体现数量随时间而变化的程度，也可用于引起人们对总值趋势的注意。例如，表示随时间而变化的利润的数据可以绘制在面积图中，以强调总利润。Matplotlib绘制面积图主要使用stackplot()函数，语法如下： matplotlib.pyplot.stackplot(x,*args,data&#x3D;None,**kwargs)参数说明： ** x：x轴数据。 args：当传入的参数个数未知时使用args。这里指y轴数据可以传入多个y轴。 data：data关键字参数。如果给定一个数据参数，所有位置和关键字参数将被替换。 kwargs：关键字参数，其他可选参数，如color（颜色）、alpha（透明度）等。 【示例25】 绘制简单面积图。（示例位置：资源包\\MR\\Code\\05\\25）绘制简单面积图，程序代码如下： 运行程序，输出结果如图5.50所示。面积图也有很多种，如标准面积图、堆叠面积图和百分比堆叠面积图等。下面主要介绍标准面积图和堆叠面积图。 1．标准面积图【示例26】 面积图分析线上图书销售情况。（示例位置：资源包\\MR\\Code\\05\\26）通过标准面积图分析2013—2019年线上图书销售情况，通过该图可以看出每一年线上图书销售的一个趋势，效果如图5.51所示。 ​ 图5.50 简单面积图 ​ 图5.51 标准面积图程序代码如下： 2．堆叠面积图【示例27】 堆叠面积图分析各平台图书销售情况。（示例位置：资源包\\MR\\Code\\05\\27）通过堆叠面积图分析2013—2019年线上各平台图书销售情况。堆叠面积图不仅可以看到各平台每年销售变化趋势，通过将各平台数据堆叠到一起还可以看到整体的变化趋势，效果如图5.52所示。实现堆叠面积图的关键在于增加y轴，通过增加多个y轴数据，形成堆叠面积图，主要代码如下： ​ 图5.52 堆叠面积图 5.6.7 绘制热力图热力图是通过密度函数进行可视化用于表示地图中点的密度的热图。它使人们能够独立于缩放因子感知点的密度。热力图可以显示不可点击区域发生的事情。利用热力图可以看数据表里多个特征两两的相似度。例如，以特殊高亮的形式显示访客热衷的页面区域和访客所在的地理区域的图示。热力图在网页分析、业务数据分析等其他领域也有较为广泛的应用。 【示例28】 绘制简单热力图。（示例位置：资源包\\MR\\Code\\05\\28）热力图是数据分析的常用方法，通过色差、亮度来展示数据的差异，易于理解。下面绘制简单热力图，程序代码如下： 01 import matplotlib.pyplot as plt02 X &#x3D; [[1,2],[3,4],[5,6],[7,8],[9,10]]03 plt.imshow(X)运行程序，输出结果如图5.53所示。 ​ 图5.53 简单热力图 上述代码中，plt.imshow(X)中传入的数组X&#x3D;[[1,2],[3,4],[5,6],[7,8],[9,10]]为颜色的对应值，按照矩阵X进行颜色分布，如左上角颜色为深蓝，其对应值为1，右下角颜色为黄色，其对应值为10，具体如下： [1,2] [深蓝,蓝色][3,4] [蓝绿,深绿][5,6] [海藻绿,春绿色][7,8] [绿色,浅绿色][9,10] [草绿色,黄色] 【示例29】 热力图对比分析学生各科成绩。（示例位置：资源包\\MR\\Code\\05\\29）根据学生成绩统计数据绘制热力图，通过热力图可清晰直观地对比每名学生各科成绩的高低。程序代码如下： 运行程序，输出结果如图5.54所示。 ​ 图5.54 学生成绩统计热力图从图5.54中可以看到，颜色以高亮显示的，成绩越高；反之，成绩越低。 5.6.8 绘制箱形图箱形图又称箱线图、盒须图或盒式图，它是一种用作显示一组数据分散情况下的资料的统计图。因形状像箱子而得名。箱形图最大的优点就是不受异常值的影响（异常值也称为离群值），可以以一种相对稳定的方式描述数据的离散分布情况，因此在各种领域也经常被使用。另外，箱形图也常用于异常值的识别。Matplotlib绘制箱形图主要使用boxplot()函数，语法如下： matplotlib.pyplot.boxplot(x,notch&#x3D;None,sym&#x3D;None,vert&#x3D;None,whis&#x3D;None,positions&#x3D;None,widths&#x3D;None,patch_artist&#x3D;None,meanline&#x3D;None,showmeans&#x3D;None,showcaps&#x3D;None,showbox&#x3D;None,showfliers&#x3D;None,boxprops&#x3D;None,labels&#x3D;None,flierprops&#x3D;None,medianprops&#x3D;None,meanprops&#x3D;None,capprops&#x3D;None,whiskerprops&#x3D;None)参数说明： x：指定要绘制箱形图的数据。 notch：是否以凹口的形式展现箱形图，默认非凹口。 sym：指定异常点的形状，默认为加号（+）显示。 vert：是否需要将箱形图垂直摆放，默认垂直摆放。 whis：指定上下限与上下四分位的距离，默认为1.5倍的四分位差。 positions：指定箱形图的位置，默认为[0,1,2,…]。 widths：指定箱形图的宽度，默认为0.5。 patch_artist：是否填充箱体的颜色。 meanline：是否用线的形式表示均值，默认用点来表示。 showmeans：是否显示均值，默认不显示。 showcaps：是否显示箱形图顶端和末端的两条线，默认显示。 showbox：是否显示箱形图的箱体，默认显示。 showfliers：是否显示异常值，默认显示。 boxprops：设置箱体的属性，如边框色、填充色等。 labels：为箱形图添加标签，类似于图例的作用。 filerprops：设置异常值的属性，如异常点的形状、大小、填充色等。 medianprops：设置中位数的属性，如线的类型、粗细等。 meanprops：设置均值的属性，如点的大小、颜色等。 capprops：设置箱形图顶端和末端线条的属性，如颜色、粗细等。 whiskerprops：设置须的属性，如颜色、粗细、线的类型等。 【示例30】 绘制简单箱形图。（示例位置：资源包\\MR\\Code\\05\\30）绘制简单箱形图，程序代码如下： 01 import matplotlib.pyplot as plt02 x&#x3D;[1,2,3,5,7,9]03 plt.boxplot(x)运行程序，输出结果如图5.55所示。 ​ 图5.55 简单箱形图 【示例31】 绘制多组数据的箱形图。（示例位置：资源包\\MR\\Code\\05\\31）上述举例是一组数据的箱形图，还可以绘制多组数据的箱形图，需要指定多组数据。例如，为三组数据绘制箱形图，程序代码如下： 01 import matplotlib.pyplot as plt02 x1&#x3D;[1,2,3,5,7,9]03 x2&#x3D;[10,22,13,15,8,19]04 x3&#x3D;[18,31,18,19,14,29]05 plt.boxplot([x1,x2,x3])运行程序，输出结果如图5.56所示。 ​ 图5.56 多组数据的箱形图箱形图将数据切割分离（实际上就是将数据分为4大部分），如图5.57所示。 ​ 图5.57 箱形图组成下面介绍箱形图每部分具体含义以及如何通过箱形图识别异常值。 下四分位 图5.57中的下四分位数指的是数据的25%分位点所对应的值（Q1）。计算分位数可以使用Pandas的quantile()函数。例如，Q1 &#x3D; df[‘总消费’].quantile(q &#x3D; 0.25)。 中位数 中位数即为数据的50%分位点所对应的值（Q2）。 上四分位数 上四分位数则为数据的75%分位点所对应的值（Q3）。 上限 上限的计算公式为Q3+1.5(Q3-Q1)。 下限 下限的计算公式为Q1-1.5(Q3-Q1)。其中，Q3-Q1表示四分位差。如果使用箱形图识别异常值，其判断标准是，当变量的数据值大于箱形图的上限或者小于箱线图的下限时，就可以将这样的数据判定为异常值。下面了解一下判断异常值的算法，如图5.58所示。 ​ 图5.58 异常值判断标准 【示例32】 通过箱形图判断异常值。（示例位置：资源包\\MR\\Code\\05\\32）通过箱形图查找客人总消费数据中存在的异常值，程序代码如下： 运行程序，输出结果如图5.59和图5.60所示。 ​ 图5.59 箱形图 ​ 图5.60 异常值 5.6.9 绘制3D图表3D图表有立体感也比较美观，看起来更加“高大上”。下面介绍两种3D图表，即三维柱形图和三维曲面图。 绘制3D图表，我们仍使用Matplotlib，但需要安装mpl_toolkits工具包，使用pip安装命令，语法如下： pip install –upgrade matplotlib安装好这个模块后，即可调用mpl_tookits下的mplot3d类进行3D图表的绘制。 1．3D柱形图【示例33】 绘制3D柱形图。（示例位置：资源包\\MR\\Code\\05\\33）绘制3D柱形图，程序代码如下： 运行程序，输出结果如图5.61所示。 2．3D曲面图【示例34】 绘制3D曲面图。（示例位置：资源包\\MR\\Code\\05\\34）绘制3D曲面图，程序代码如下： 运行程序，输出结果如图5.62所示。 ​ 图5.61 3D柱形图 ​ 图5.62 3D曲面图 5.6.10 绘制多个子图表Matplotlib可以实现在一张图上绘制多个子图表。Matplotlib提供了3种方法：一是subplot()函数；二是subplots()函数；三是add_subplot()函数，下面分别介绍。 1．subplot()函数subplot()函数直接指定划分方式和位置，它可以将一个绘图区域划分为n个子图，每个subplot()函数只能绘制一个子图。语法如下： matplotlib.pyplot.subplot(*args,**kwargs)参数说明： ** args：当传入的参数个数未知时使用args。 kwargs：关键字参数，其他可选参数。例如，绘制一个2×3的区域，subplot(2,3,3)，将画布分成2行3列在第3个区域中绘制，用坐标表示如下： (1,1),(1,2),(1,3) (2,1),(2,2),(2,3)如果行列的值都小于10，那么可以把它们缩写为一个整数，如subplot(233)。另外，subplot()函数在指定的区域中创建一个轴对象，如果新创建的轴和之前所创建的轴重叠，那么，之前的轴将被删除。 【示例35】 使用subplot()函数绘制多个子图的空图表。（示例位置：资源包\\MR\\Code\\05\\35）绘制一个2×3包含6个子图的空图表，程序代码如下： 运行程序，输出结果如图5.63所示。 ​ 图5.63 6个子图的空图表 【示例36】 绘制包含多个子图的图表。（示例位置：资源包\\MR\\Code\\05\\36）通过上述举例了解了subplot()函数的基本用法，接下来将前面所学的简单图表整合到一张图表上，结果如图5.64所示。 ​ 图5.64 多个子图程序代码如下： 上述举例，以下两个关键点一定要掌握。（1）每绘制一个子图表都要调用一次subplot()函数。（2）绘图区域位置编号。subplot()函数的前面两个参数指定的是一个画布被分割成的行数和列数，后面一个参数则指的是当前绘制区域位置编号，编号规则是行优先。例如，图5.64中有3个子图表，第1个子图表subplot(2,2,1)，即将画布分成2行2列，在第1个子图中绘制折线图；第2个子图表subplot(2,2,2)，将画布分成2行2列，在第2个子图中绘制散点图；第3个子图表subplot(2,1,2)，将画布分成2行1列，由于第1行已经占用了，所以在第2行也就是第3个子图中绘制柱形图。示意图如图5.65所示。 ​ 图5.65 多个子图示意图subplot()函数在画布中绘图时，每次都要调用它指定绘图区域非常麻烦，而subplots()函数则更直接，它会事先把画布区域分割好。下面介绍subplots()函数。 2．subplots()函数subplots()函数用于创建画布和子图，语法如下： matplotlib.pyplot.subplots(nrows,ncols,sharex,sharey,squeeze,subplot_kw,gridspec_kw,**fig_kw)参数说明： nrows和ncols：表示将画布分割成几行几列，例如，nrows&#x3D;2、ncols&#x3D;2表示将画布分割为2行2列，起始值均为0。当调用画布中的坐标轴时，ax[0,0]表示调用左上角的坐标，ax[1,1]表示调用右下角的坐标。 sharex和sharey：布尔值或者值为“none”“all”“row”“col”，默认值为False。用于控制x或y轴之间的属性共享。具体参数值说明如下。 ​ True或者“all”：表示x或y轴属性在所有子图中共享。 ​ False或者“none”：表示每个子图的x或y轴都是独立的部分。 ​ “row”：表示每个子图在一个x或y轴上共享行（row）。 ​ “col”：表示每个子图在一个x或y轴上共享列（column） squeeze：布尔值，默认值为True，额外的维度从返回的axes（轴）对象中挤出，对于n×1或1×n个子图，返回一个一维数组，对于n×m，n&gt;1和m&gt;1返回一个二维数组；如果值为False，则表示不进行挤压操作，返回一个元素为Axes实例的二维数组，即使它最终是1×1。 subplot_kw：字典类型，可选参数。把字典的关键字传递给add_subplot()函数来创建每个子图。 gridspec_kw：字典类型，可选参数。把字典的关键字传递给GridSpec()构造函数创建网格区域，然后将子图放在网格（grid）里。 **fig_kw：把所有详细的关键字参数传递给figure。 【示例37】 使用subplots()函数绘制多子图的空图表。（示例位置：资源包\\MR\\Code\\05\\37）绘制一个2×3包含6个子图的空图表，使用subplots()函数只需3行代码。 01 import matplotlib.pyplot as plt02 figure,axes&#x3D;plt.subplots(2,3)03 plt.show()上述代码中，figure和axes是两个关键点。 figure：绘制图表的画布。 axes：坐标轴对象，可以理解为在figure（画布）上绘制坐标轴对象，它帮我们规划出了一个个科学作图的坐标轴系统。通过图5.66中的示意图可以明白，外面的是画布（figure），里面带坐标轴的是坐标轴对象（axes）。 ​ 图5.66 坐标系统示意图 【示例38】 使用subplots()函数绘制多子图图表。（示例位置：资源包\\MR\\Code\\05\\38）使用subplots()函数将前面所学的简单图表整合到一张图表上，结果如图5.67所示。程序代码如下： ​ ​ 图5.67 多子图图表 3．add_subplot()函数【示例39】 使用add_subplot()函数绘制多子图图表。（示例位置：资源包\\MR\\Code\\05\\39）add_subplot()函数也可以实现在一张图上绘制多个子图表，用法与subplot()函数基本相同，先来看下列一段代码： 01 import matplotlib.pyplot as plt02 fig &#x3D; plt.figure() 03 ax1 &#x3D; fig.add_subplot(2,3,1)04 ax2 &#x3D; fig.add_subplot(2,3,2)05 ax3 &#x3D; fig.add_subplot(2,3,3)06 ax4 &#x3D; fig.add_subplot(2,3,4)07 ax5 &#x3D; fig.add_subplot(2,3,5)08 ax6 &#x3D; fig.add_subplot(2,3,6)上述代码同样是绘制一个2×3包含6个子图的空图表。首先创建figure实例（画布），然后通过ax1 &#x3D;fig.add_subplot(2,3,1)创建第1个子图表，返回Axes实例（坐标轴对象），第1个参数为行数，第2个参数为列数，第3个参数为子图表的位置。以上用3种方法实现了在一张图上绘制多个子图表，3种方法各有所长。subplot()函数和add_subplot()函数比较灵活，定制化效果比较好，可以实现子图表在图中的各种布局（如一张图上可以随意摆放3个或5个图表）；而subplots()函数较为不灵活，但它可以用较少的代码实现绘制多个子图表。 5.6.11 图表的保存实际工作中，有时需要将绘制的图表保存为图片放置到报告中。Matplotlib的savefig()函数可以实现这一功能，将图表保存为JPEG、TIFF或PNG格式的图片。例如，保存之前绘制的折线图，主要代码如下： plt.savefig(‘image.png’)需要注意的一个关键问题：保存代码必须在图表预览前，也就是plt.show()代码前；否则保存后的图片是白色，图表无法保存。运行程序，图表被保存在程序所在路径下，名为image.png，如图5.68所示。 ​ 图5.68 保存后的图表 5.7 综合应用5.7.1 案例1：双y轴可视化数据分析图表的实现案例位置：资源包\\MR\\Code\\05\\example\\01双y轴顾名思义就是两个y轴，其特点是通过双y轴可以看出发展情况的同时还可以看到其增长速度。对于产品而言，通过此图可以看到产品销量的同时还可以看到产品增长率，效果如图5.69所示。 ​ 图5.69 双y轴可视化数据分析图表双y轴可视化数据分析图表的实现主要使用add_suplot()函数和twinx()函数。twinx()函数表示共享x轴，那么也就是一个x轴、两个y轴，程序代码如下： 5.7.2 案例2：颜色渐变饼形图的实现案例位置：资源包\\MR\\Code\\05\\example\\03在绘制图表的过程中，每一次都苦于颜色设置问题，数据较多的情况下，不知道该如何配色，手动配色费时费力。下面绘制渐变颜色的饼形图，根据所占比例自动配置渐变色，占比越大颜色越深，占比越小颜色越浅，省去了手动配色的麻烦，而且占比情况一目了然，效果如图5.70所示。 ​ 图5.70 渐变色饼形图颜色渐变主要使用了Matplotlib内置颜色地图模块cm，在该模块中指定一组数据可以生成多种颜色，由浅入深。例如，渐变蓝色，cmap&#x3D;plt.cm.Blues。下面来绘制颜色渐变的饼形图，程序代码如下： 5.7.3 案例3：等高线图的实现案例位置：资源包\\MR\\Code\\05\\example\\04等高线图是在地理课中讲述山峰山谷时绘制的图形，在机器学习中也会被用在绘制梯度下降算法的图形中。等高线图实现结果如图5.71所示。 程序代码如下： 关键代码解析： 要画出等高线，核心函数是Matplotlib的contourf()函数，但该函数中参数x和y对应的值是二维数据，因此需要使用NumPy的meshgrid()函数将x和y值转换成二维数据，代码如下： np.meshgrid(x, y) 5.8 小结数据统计得再好都不如一张图表清晰、直观。本章用大量的举例详细地介绍了Matplotlib图表，其根本在于能够使读者全面透彻地了解和掌握最基础的图表，并应用到实际数据统计分析工作中，同时也为以后学习其他绘图库奠定坚实的基础。","categories":[{"name":"python","slug":"python","permalink":"http://example.com/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"http://example.com/tags/python/"}]},{"title":"数据分析（1-3）","slug":"数据分析（1-3）","date":"2021-05-30T02:53:51.000Z","updated":"2022-05-30T03:23:49.567Z","comments":true,"path":"2021/05/30/数据分析（1-3）/","link":"","permalink":"http://example.com/2021/05/30/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%EF%BC%881-3%EF%BC%89/","excerpt":"","text":"Python数据分析从入门到精通课程简介自然智能自然智能（Natural Intelligence，NI），指人通过大脑的运算和决策产生有价值的行为。这些行为包括了人的大脑思考及决策、耳朵听力及判断、眼睛视觉及判断、鼻子嗅觉及判断、皮肤触觉及判断等，体现在人行为的方方面面。 人工智能定义 百度百科：它是研究、开发用于模拟、延伸和扩展人的智能的理论、方法、技术及应用系统的一门新的技术科学。 人工智能（Artificial intelligence）简称AI。人工智能是计算机科学的一个分支，它企图了解智能的本质，并生产出一种新的能以人类智能相似的方式做出反应的智能机器，是研究、开发用于模拟、延伸和扩展人的智能的理论、方法、技术及应用系统的一门新的技术科学。 借用《计算机科学导论》作者贝赫鲁兹·佛罗赞（Behrouz Forouzan）的说法，人工智能是对程序系统的研究，该程序系统在一定程度上能模仿人类的活动，如感知，思考，学习和反应。 分类人工智能目前分为弱人工智能和强人工智能和超人工智能。 弱人工智能：弱人工智能（Artificial Narrow Intelligence &#x2F;ANI),只专注于完成某个特定的任务，例如语音识别、图象识别和翻译等，是擅长于单个方面的人工智能。它们只是用于解决特定的具体类的任务问题而存在，大都是统计数据，以此从中归纳出模型。由于弱人工智能智能处理较为单一的问题，且发展程度并没有达到模拟人脑思维的程度，所以弱人工智能仍然属于“工具”的范畴，与传统的“产品”在本质上并无区别。 强人工智能：强人工智能（Artificial General Intelligence &#x2F;AGI),属于人类级别的人工智能，在各方面都能和人类比肩，它能够进行思考、计划、解决问题、抽象思维、理解复杂理念、快速学习和从经验中学习等操作，并且和人类一样得心应手。 超人工智能：超人工智能（Artificial Super intelligence&#x2F;ASI），在几乎所有领域都比最聪明的人类大脑都聪明许多，包括科学创新、通识和社交技能。在超人工智能阶段，人工智能已经跨过“奇点”，其计算和思维能力已经远超人脑。此时的人工智能已经不是人类可以理解和想象。人工智能将打破人脑受到的维度限制，其所观察和思考的内容，人脑已经无法理解，人工智能将形成一个新的社会。 我们现阶段还处于若人工智能阶段。 机器学习机器学习（Machine Learning）简称ML。机器学习属于人工智能的一个分支，也是人工智能的和核心。机器学习理论主要是设计和分析一些让计算机可以自动”学习“的算法。 深度学习深度学习（Deep Learning）简称DL。最初的深度学习是利用深度神经网络来解决特征表达的一种学习过程。深度神经网络本身并不是一个全新的概念，可大致理解为包含多个隐含层的神经网络结构。为了提高深层神经网络的训练效果，人们对神经元的连接方法和激活函数等方面做出相应的调整。深度学习是机器学习研究中的一个新的领域，其动机在于建立、模拟人脑进行分析学习的神经网络，它模仿人脑的机制来解释数据，如图象、声音、文本。 区别与联系 数据分析机器学习是强大的数据分析工具 数据分析行业前景 就业岗位成为数据分析师 机器学习开发工程师 科学计算的科学家 学习重点Numpy、Pandas、Matplotlib, Scipy、Scikit-learn、pyecharts Numpy库和 工具anaconda 的下载和安装 官网：https://www.anaconda.com/products/individual 百度网盘：链接：https://pan.baidu.com/s/1VVwv3-AIr7c3S7juGpp8mQ提取码：v2bh 安装成功验证： 查看已经安装的安装包： pip list anaconda 安装工具包方法： pip install pip install 安装包名称 -i https://pypi.tuna.tsinghua.edu.cn/simple jupyter notebookJupyter Notebook将代码、说明文本、数学方程式、数据可视化图表等内容全部组合到一起显示在一个共享的文档中，可以实现一边写代码一边记录，而这些功能是Python自带的IDLE和集成开发环境PyCharm无法比拟的。 快捷键 Enter : 转入编辑模式 Shift-Enter : 运行本单元，选中下个单元 Ctrl-Enter : 运行本单元 Alt-Enter : 运行本单元，在其下插入新单元 Y : 单元转入代码状态 M :单元转入markdown状态 R : 单元转入raw状态 1 : 设定 1 级标题 2 : 设定 2 级标题 3 : 设定 3 级标题 4 : 设定 4 级标题 5 : 设定 5 级标题 6 : 设定 6 级标题 Up : 选中上方单元 K : 选中上方单元 Down : 选中下方单元 J : 选中下方单元 Shift-K : 扩大选中上方单元 Shift-J : 扩大选中下方单元 A : 在上方插入新单元 B : 在下方插入新单元 X : 剪切选中的单元 C : 复制选中的单元 Shift-V : 粘贴到上方单元 V : 粘贴到下方单元 Z : 恢复删除的最后一个单元 D,D : 删除选中的单元 Shift-M : 合并选中的单元 Ctrl-S : 文件存盘 S : 文件存盘 L : 转换行号 O : 转换输出 Shift-O : 转换输出滚动 Esc : 关闭页面 Q : 关闭页面 H : 显示快捷键帮助 I,I : 中断Notebook内核 0,0 : 重启Notebook内核 Shift : 忽略 Shift-Space : 向上滚动 Space : 向下滚动 spyder 变量浏览器窗口 创建项目 pycharm开发工具比较PyCharm、Jupyter Notebook和Spyder这3种开发工具，各有特点。 a.数据分析，建议使用Spyder和Jupyter Notebook b.复杂、大型项目，建议使用PyCharm c. 数据分析、复杂和大型项目，建议三者可以结合使用 第一章 了解数据分析一. 数据分析流程熟悉工具-明确目的-获取数据-数据处理-数据分析-验证结果-结果呈现-数据应用 1.熟悉工具2.明确目的在数据分析方面，首先要花一些时间搞清楚为什么要做数据分析、分析什么、想要达到什么效果。例如，为了评估产品改版后的效果比之前是否有所提升，或通过数据分析找到产品迭代的方向等。只有明确了分析目的，才能够找到适合的分析方法，也才能够有效地进行数据处理、数据分析和预测等后续工作。 3.获取数据数据的来源有很多，像我们熟悉的Excel数据、数据库中的数据、网站数据以及公开的数据集等。那么，获取数据之前首先要知道需要什么时间段的数据，哪张表中的数据，以及如何获得，是下载、复制还是爬取等。 4.数据处理 数据规约：在接近或保持原始数据完整性的同时将数据集规模减小，以提高数据处理的速度。例如，一张Excel表中包含近3年的几十万条数据，由于我们只分析近一年的数据，因此要一年的数据即可，这样做的目的就是减小数据规模，提高数据处理速度。 数据清洗：在获取到原始数据后，可能其中的很多数据都不符合数据分析的要求，那么就需要按照如下步骤进行处理。 ​ a.数据探索分析：分析数据的规律，通过一定的方法统计数据，通过统计结果判断数据是否存在缺失、异常等情况。例如，通过最小值判断数量、金额是否包含缺失数据，如果最小值为0，那么这部分数据就是缺失数据，以及通过判断数据是否存在空值来判断数据是否缺失。 ​ b.重复数据处理：对于重复的数据删除即可。 ​ c.缺失数据处理：对于缺失的数据，如果比例高于30%可以选择放弃这个指标，删除即可；如果低于30%可以将这部分缺失数据进行填充，以0或均值填充。 ​ d.异常数据处理：异常数据需要对具体业务进行具体分析和处理，对于不符合常理的数据可进行删除。例如，性别男或女，但是数据中存在其他值，以及年龄超出正常年龄范围，这些都属于异常数据。 数据加工：包括数据抽取、数据计算、数据分组和数据转换。 ​ a.数据抽取：是指选取数据中的部分内容。 ​ b.数据计算：是进行各种算术和逻辑运算，以便得到进一步的信息。 ​ c.数据分组：是按照有关信息进行有效的分组。 ​ d.数据转换：是指数据标准化处理，以适应数据分析算法的需要，常用的有z-score标准化，“最小、最大标准化”和“按小数定标标准化”等。经过上述标准化处理后，数据中各指标值将会处在同一个数量级别上，以便更好地对数据进行综合测评和分析。 5.数据分析数据分析过程中，选择适合的分析方法和工具很重要，所选择的分析方法应兼具准确性、可操作性、可理解性和可应用性。但对于业务人员（如产品经理或运营）来说，数据分析最重要的是数据分析思维。 6.验证结果通过数据分析我们会得到一些结果，但是这些结果只是数据的主观结果的体现，有些时候不一定完全准确，所以必须要进行验证。 例如，数据分析结果显示某产品点击率非常高，但实际下载量平平，那么这种情况，不要轻易定论，这种产品受欢迎，而要进一步验证，找到真正影响点击率的原因，这样才能做出更好的决策。 7.结果呈现现如今，企业越来越重视数据分析给业务决策带来的有效应用，而可视化是数据分析结果呈现的重要步骤。可视化是以图表方式呈现数据分析结果，这样的结果更清晰、更直观、更容易理解。 8.数据应用数据分析的结果并不仅仅是把数据呈现出来，而更应该关注的是通过分析这些数据，后面可以做什么？如何将数据分析结果应用到实际业务中才是学习数据分析的重点。数据分析结果的应用是数据产生实际价值的直接体现，而这个过程需要具有数据沟通能力、业务推动能力和项目工作能力。如果看了数据分析结果后并不知道做什么，那么这个数据分析就是失败的。 二.数据分析常用的工具excel 或者 python excel Excel具备多种强大功能，例如创建表格、数据透视表、VBA等，Excel的系统如此庞大，确保了大家可以根据自己的需求分析数据。但是在今天，大数据、人工智能时代，数据量很大的情况下Excel已经无法胜任，不仅处理起来很麻烦而且处理速度也会变慢。从数据分析的层面，Excel也只是停留在描述性分析，如对比分析、趋势分析、结构分析等。 python 虽然Excel已尽最大努力考虑到数据分析的大多数应用场景，但由于它是定制软件，很多东西都固化了，不能自由地修改。而Python非常的强大和灵活，可以编写代码来执行所需的任何操作，从专业和方便的角度来看，它比Excel更加强大。另外，Python可以实现Excel难以实现的应用场景。 a．专业的统计分析例如，正态分布、使用算法对聚类进行分类和回归分析等。这种分析就像用数据做实验一样。它可以帮助我们回答下面的问题。数据的分布是正态分布、三角分布还是其他类型的分布？离散情况如何？它是否在我们想要达到的统计可控范围内？不同参数对结果的影响是多少？b．预测分析例如，我们打算预测消费者的行为。他会在我们的商店停留多长时间？他会花多少钱？我们可以找出他的个人信用情况，并根据他的在线消费记录确定贷款金额。或者，我们可以根据他在网页上的浏览历史推送不同的产品。这也涉及当前流行的机器学习和人工智能概念。 综上所述，Python作为数据分析工具的首选，具有以下优势。 Python语言简单易学、数据处理简单高效，对于初学者来说更加容易上手。 Python第三方扩展库不断更新，可用范围越来越广。 在科学计算、数据分析、数学建模和数据挖掘方面占据越来越重要的地位。 可以和其他语言进行对接，兼容性稳定。当然，如果您既会Excel又会Python，那么绝对是职场的加分项！ 第二章 Pandas统计分析Pandas是Python的核心数据分析支持库，它提供了大量能使我们快速便捷地处理数据的函数和方法。由于Pandas相关知识非常多，本书将Pandas分为上、下两章进行讲解。本章开始Pandas入门内容，从安装开始，逐步介绍Pandas相关的入门知识，包括两个主要的数据结构，即Series对象和DataFrame对象，也包括如何导入外部数据、数据抽取，以及数据的增加、修改和删除，还包括数据清洗、索引设置、数据排序与排名等相关基础知识，这些都是在为后期数据处理和数据分析打下良好的基础。 一. Pandas概述Pandas是数据分析三大剑客之一，是Python的核心数据分析库，它提供了快速、灵活、明确的数据结构，能够简单、直观、快速地处理各种类型的数据，具体介绍如下所示。 Pandas能够处理以下类型的数据。 1.与SQL或Excel表类似的数据。 2.有序和无序（非固定频率）的时间序列数据。 3.带行、列标签的矩阵数据。 4.任意其他形式的观测、统计数据集。 Pandas提供的两个主要数据结构Series（一维数组结构）与DataFrame（二维数组结构），可以处理金融、统计、社会科学、工程等领域里的大多数典型案例，并且Pandas是基于NumPy开发的，可以与其他第三方科学计算库完美集成。Pandas的功能很多，它的优势如下。 list1&#x3D;[0,1,2,3,4,5] list2&#x3D;[[0,1,2,3,4,5],[0,1,2,3,4,5]] 1.处理浮点与非浮点数据里的缺失数据，表示为NaN。 2.大小可变，例如插入或删除DataFrame等多维对象的列。 3.自动、显式数据对齐，显式地将对象与一组标签对齐，也可以忽略标签，在Series、DataFrame计算时自动与数据对齐。 4.强大、灵活的分组统计（groupby）功能，即数据聚合、数据转换。 5.把Python和NumPy数据结构里不规则、不同索引的数据轻松地转换为DataFrame对象。 6.智能标签，对大型数据集进行切片、花式索引、子集分解等操作。 7.直观地合并（merge）、连接（join）数据集。 灵活地重塑（reshape）、透视（pivot）数据集。 8.成熟的导入、导出工具，导入文本文件（CSV等支持分隔符的文件）、Excel文件、数据库等来源的数据，导出Excel文件、文本文件等，利用超快的HDF5格式保存或加载数据。 9.时间序列：支持日期范围生成、频率转换、移动窗口统计、移动窗口线性回归、日期位移等时间序列功能。 例1.读取excel数据 123import pandas as pd #导入pandas 模块df=pd.read_excel(&#x27;data.xlsx&#x27;) #读取Excel 文件df1=df.head() #显示前5 条数据 二. seires 对象Pandas是Python数据分析重要的库，而Series和DataFrame是Pandas库中两个重要的对象，也是Pandas中两个重要的数据结构，如图所示。 本节将主要介绍Series对象。 2.1 图解Series对象Series是Python的Pandas库中的一种数据结构，它类似一维数组，由一组数据以及与这组数据相关的标签（即索引)组成，或者仅有一组数据没有索引也可以创建一个简单的Series。Series可以存储整数、浮点数、字符串、Python对象等多种类型的数据。例如，在成绩表（见图3)中包含了Series对象和DataFrame对象，其中“语文”“数学”“英语”3列中的每一列均是一个Series对象，而“语文”“数学”“英语”3列组成了一个DataFrame对象，如图4所示。 ​ 图3 ​ 图4 2.2 创建一个series对象创建Series对象主要使用Pandas的Series()方法，语法如下： 1s=pd.Series(data,index=index) 参数说明： data：表示数据，支持Python字典、多维数组、标量值（即只有大小，没有方向的量。也就是说，只是一个数值，如s&#x3D;pd.Series(5)）。 index：表示行标签（索引）。 返回值：Series对象。 说明当data参数是多维数组时，index长度必须与data长度一致。如果没有指定index参数，则自动创建数值型索引（从0～data数据长度-1）。 【示例02】 在成绩表添加一列“物理”成绩。（示例位置：资源包\\MR\\Code\\03\\02）创建一个Series对象，在成绩表中添加一列“物理”成绩。程序代码如下： 123import pandas as pds1=pd.Series([88,60,75])03 print(s1) 上述举例，如果通过Pandas模块引入Series对象，那么就可以直接在程序中使用Series对象了。主要代码如下： 12from pandas import Seriess1=Series([88,60,75]) 2.3 手动设置series索引创建Series对象时会自动生成整数索引，默认值从0开始至数据长度减1。例如，3.2.1节举例中使用的就是默认索引，如0、1、2。除了使用默认索引，还可以通过index参数手动设置索引。 【示例03】 手动设置索引。（示例位置：资源包\\MR\\Code\\03\\03）下面手动设置索引，将3.2.1节添加的“物理”成绩的索引设置为1、2、3，也可以是“明日同学”“高同学”“七月流火”。 程序代码如下： 运行程序，控制台输出结果如下： 说明上述结果中输出的dtype是DataFrame数据的数据类型，int为整型，后面的数字表示位数。 2.4 series 位置索引2.4.1 series位置索引位置索引是从0开始数，[0]是Series第一个数，[1]是Series第二个数，以此类推。 【示例04】 通过位置索引获取学生物理成绩。（示例位置：资源包\\MR\\Code\\03\\04）获取第一个学生的物理成绩。程序代码如下： 123import pandas as pds1=pd.Series([88,60,75])print(s1[0]) 运行程序，控制台输出结果如下： 88 注意Series不能使用[-1]定位索引。 2.4.2 series 标签索引Series标签索引与位置索引方法类似，用[ ]表示，里面是索引名称，注意index的数据类型是字符串，如果需要获取多个标签索引值，用[[ ]]表示（相当于[ ]中包含一个列表）。 【示例05】 通过标签索引获取学生物理成绩。（示例位置：资源包\\MR\\Code\\03\\05）通过标签索引“明日同学”和“七月流火”获取物理成绩，程序代码如下： 2.4.3 series 切片索引用标签索引做切片，包头包尾（即包含索引开始位置的数据，也包含索引结束位置的数据）。 【示例06】 通过切片获取数据。（示例位置：资源包\\MR\\Code\\03\\06）通过标签切片索引“明日同学”至“七月流火”获取数据。程序代码如下： 1print(s1[&#x27;明日同学&#x27;:&#x27;七月流火&#x27;]) #通过切片获取索引值 用位置索引做切片，和list列表用法一样，包头不包尾（即包含索引开始位置的数据，不包含索引结束位置的数据）。 【示例07】 通过位置切片获取数据。（示例位置：资源包\\MR\\Code\\03\\07）通过位置切片1～4获取数据，程序代码如下： 12s2=pd.Series([88,60,75,34,68])print(s2[1:4]) 运行程序，控制台输出结果如下： 1 602 753 34 2.4.5 获取series索引和值获取Series索引和值主要使用Series的index和values方法。 【示例08】 获取物理成绩的索引和值。（示例位置：资源包\\MR\\Code\\03\\08）下面使用Series的index和values方法获取物理成绩的索引和值，程序代码如下： 1234import pandas as pds1=pd.Series([88,60,75])print(s1.index)print(s1.values) 运行程序，控制台输出结果如下： RangeIndex(start&#x3D;0, stop&#x3D;3, step&#x3D;1)[88 60 75] 三. DataFrame对象DataFrame是Pandas库中的一种数据结构，它是由多种类型的列组成的二维表数据结构，类似于Excel、SQL或Series对象构成的字典。DataFrame是最常用的Pandas对象，它与Series对象一样支持多种类型的数据。 3.1 图解DataFrame对象DataFrame是一个二维表数据结构，由行、列数据组成的表格。DataFrame既有行索引也有列索引，它可以看作是由Series对象组成的字典，不过这些Series对象共用一个索引，如图3.11所示。 图3.11 DataFrame结构处理DataFrame表格数据时，用index表示行或用columns表示列更直观。用这种方式迭代DataFrame的列，代码更易读懂。 【示例09】 遍历DataFrame数据。（示例位置：资源包\\MR\\Code\\03\\09）遍历DataFrame数据，输出成绩表的每一列数据，程序代码如下： 运行程序，控制台输出结果如下： 从运行结果得知，上述代码返回的其实是Series，如图3.12所示。Pandas之所以提供多种数据结构，其目的就是为了代码易读、操作更加方便。 3.2 创建一个DataFrame对象创建DataFrame主要使用Pandas的DataFrame()方法，语法如下： 1pandas.DataFrame(data,index,columns,dtype,copy) 参数说明： data：表示数据，可以是ndarray数组、Series对象、列表、字典等。 index：表示行标签（索引）。 columns：列标签（索引）。 dtype：每一列数据的数据类型，其与Python数据类型有所不同，如object数据类型对应的是Python的字符型。 表3.1为Pandas数据类型与Python数据类型的对应表。 category作业，查询datetime64,timedela[ns],category Timedelta在pandas中是一个表示两个datetime值之间的差(如日,秒和微妙)的类型,2个Datetime数据运算相减得出的结果就是一个Timedelta数据类型 ​ 表3.1 数据类型对应表 copy：用于复制数据。 返回值：DataFrame。下面通过两种方法来创建DataFrame，即通过二维数组创建和通过字典创建。 1．通过二维数组创建DataFrame【示例10】 通过二维数组创建成绩表。（示例位置：资源包\\MR\\Code\\03\\10）通过二维数组创建成绩表，包括语文、数学和英语，程序代码如下： 运行程序，控制台输出结果如下： 2．通过字典创建DataFrame通过字典创建DataFrame，需要注意：字典中的value值只能是一维数组或单个的简单数据类型，如果是数组，要求所有数组长度一致；如果是单个数据，则每行都添加相同数据。 【示例11】 通过字典创建成绩表。（示例位置：资源包\\MR\\Code\\03\\11）通过字典创建成绩表，包括语文、数学、英语和班级，程序代码如下： 运行程序，控制台输出结果如下： 上述代码中，“班级”的value值是一个单个数据，所以每一行都添加了相同的数据“高一7班”。 3.3 DataFrame重要属性和函数DataFrame是Pandas一个重要的对象，它的属性和函数很多，下面先简单了解DataFrame的几个重要属性和函数。重要属性介绍如表3.2所示，重要函数介绍如表3.3所示。 ​ 表3.2 重要属性 ​ 表3.3 重要函数 3.4 导入外部数据数据分析首先就要有数据。那么，数据类型有多种，本节介绍如何导入不同类型的外部数据。 3.4.1 导入.xls或.xlsx文件导入.xls或.xlsx文件主要使用Pandas的read_excel()方法，语法如下： 1pandas.read_excel(io,sheet_name=0,header=0,names=None,index_col=None,usecols=None,squeeze=False,dtype=None,engine=None,converters=None,true_values=None,false_values=None,skiprows=None,nrow=None,na_values=None,keep_default_na=True,verbose=False,parse_dates=False,date_parser=None,thousands=None,comment=None,skipfooter=0,conver_float=True,mangle_dupe_cols=True,**kwds) 常用参数说明： io：字符串，.xls或.xlsx文件路径或类文件对象。 sheet_name：None、字符串、整数、字符串列表或整数列表，默认值为0。字符串用于工作表名称，整数为索引表示工作表位置，字符串列表或整数列表用于请求多个工作表，为None时获取所有工作表。参数值如表3.4所示。 ​ 表3.4 sheet_name参数值 header：指定作为列名的行，默认值为0，即取第一行的值为列名。数据为除列名以外的数据；若数据不包含列名，则设置header&#x3D;None。 names：默认值为None，要使用的列名列表。 index_col：指定列为索引列，默认值为None，索引0是DataFrame的行标签。 usecols：int、list列表或字符串，默认值为None。 如果为None，则解析所有列。 如果为int，则解析最后一列。 如果为list列表，则解析列号列表的列。 如果为字符串，则表示以逗号分隔的Excel列字母和列范围列表（例如“A:E”或“A,C,E:F”）。范围包括双方。 squeeze：布尔值，默认值为False，如果解析的数据只包含一列，则返回一个Series。 dtype：列的数据类型名称或字典，默认值为None。例如{‘a’:np.float64,’b’:np.int32}。 skiprows：省略指定行数的数据，从第一行开始。 skipfooter：省略指定行数的数据，从尾部数的行开始。 下面通过示例，详细介绍如何导入.xlsx文件。 1．常规导入导入Excel文件。【示例12】 （示例位置：资源包\\MR\\Code\\03\\12）导入“1月.xlsx”Excel文件，程序代码如下： 123import pandas as pddf=pd.read_excel(&#x27;1 月.xlsx&#x27;)df1=df.head() #输出前5 条数据 运行程序，输出前5条数据，结果如图3.13所示。图3.13 1月淘宝销售数据（前5条数据） 知识胶囊导入外部数据，必然要涉及路径问题，下面来了解一下相对路径和绝对路径。 相对路径：相对路径就是以当前文件为基准进行一级级目录指向被引用的资源文件。以下是常用的表示当前目录和当前目录的父级目录的标识符。 ..&#x2F;：表示当前文件所在目录的上一级目录。 .&#x2F;：表示当前文件所在的目录（可以省略）。 &#x2F;：表示当前文件的根目录（域名映射或硬盘目录）。 如果使用系统默认文件路径\\，那么，在Python中则需要在路径最前面加一个r，以避免路径里面的\\被转义。 绝对路径：绝对路径是文件真正存在的路径，是指从硬盘的根目录（盘符）开始，进行一级级目录指向文件。 2．导入指定的Sheet页一个Excel文件包含多个Sheet页，通过设置sheet_name参数就可以导入指定Sheet页的数据。 【示例13】 导入指定Sheet页的数据。（示例位置：资源包\\MR\\Code\\03\\13）一个Excel文件包含多家店铺的销售数据，导入其中一家店铺（莫寒）的销售数据，如图3.14所示。图3.14 原始数据 程序代码如下： 123import pandas as pddf=pd.read_excel(&#x27;1 月.xlsx&#x27;,sheet_name=&#x27;莫寒&#x27;)df1=df.head() #输出前5条数据 运行程序，输出前5条数据，结果如图3.15所示。除了指定Sheet页的名字，还可以指定Sheet页的顺序，从0开始。例如，sheet_name&#x3D;0表示导入第一个Sheet页的数据，sheet_name&#x3D;1表示导入第二个Sheet页的数据，以此类推。如果不指定sheet_name参数，则默认导入第一个Sheet页的数据。 3．通过行、列索引导入指定行、列数据DataFrame是二维数据结构，因此它既有行索引又有列索引。当导入Excel数据时，行索引会自动生成，如0、1、2；而列索引则默认将第0行作为列索引（如A,B,…,J）。DataFrame行、列索引的示意图如图3.16所示。 ​ ​ 图3.15 导入指定的Sheet页（前5条数据） ​ 图3.16 DataFrame行、列索引示意图 【示例14】 指定行索引导入Excel数据。（示例位置：资源包\\MR\\Code\\03\\14）如果通过指定行索引导入Excel数据，则需要设置index_col参数。下面将“买家会员名”作为行索引（位于第0列），导入Excel数据，程序代码如下： 123import pandas as pddf1=pd.read_excel(&#x27;1 月.xlsx&#x27;,index_col=0) #“买家会员名”为行索引df1=df1.head() #输出前5条数据 运行程序，输出结果如图3.17所示。 图3.17 通过指定行索引导入Excel数据如果通过指定列索引导入Excel数据，则需要设置header参数，主要代码如下： 1df2=pd.read_excel(&#x27;1月.xlsx&#x27;,header=1) #设置第1行为列索引 运行程序，输出结果如图3.18所示。如果将数字作为列索引，可以设置header参数为None，主要代码如下： 1df3=pd.read_excel(&#x27;1月.xlsx&#x27;,header=None) #列索引为数字 运行程序，输出结果如图3.19所示。 图3.18 通过指定列索引导入Excel数据 图3.19 指定列索引那么，为什么要指定索引呢？因为通过索引可以快速地检索数据，例如df3[0]，就可以快速检索到“买家会员名”这一列数据。 4.导入指定列数据一个Excel往往包含多列数据，如果只需要其中的几列，可以通过usecols参数指定需要的列，从0开始（表示第1列，以此类推）。 【示例15】 导入第1列数据。（示例位置：资源包\\MR\\Code\\03\\15）下面导入第1列数据（索引为0），程序代码如下： 123import pandas as pddf1=pd.read_excel(&#x27;1 月.xlsx&#x27;,usecols=[0]) #导入第1列df1.head() 运行程序，输出结果如图3.20所示。如果导入多列，可以在列表中指定多个值。例如，导入第1列和第4列，主要代码如下： 1df2=pd.read_excel(&#x27;1月.xlsx&#x27;,usecols=[0,3]) 也可以指定列名称，主要代码如下： 1df3=pd.read_excel(&#x27;1月.xlsx&#x27;,usecols=[&#x27;买家会员名&#x27;,&#x27;宝贝标题&#x27;]) 运行程序，输出结果如图3.21所示。 ​ 图3.20 导入第1列 ​ 图3.21 导入第1列和第4列数据 3.4.2 导入.csv文件导入.csv文件主要使用Pandas的read_csv()方法，语法如下： 常用参数说明： filepath_or_buffer：字符串，文件路径，也可以是URL链接。 sep、delimiter：字符串，分隔符。 header：指定作为列名的行，默认值为0，即取第1行的值为列名。数据为除列名以外的数据；若数据不包含列名，则设置header&#x3D;None。 names：默认值为None，要使用的列名列表。 index_col：指定列为索引列，默认值为None，索引0是DataFrame的行标签。 usecols：int、list列表或字符串，默认值为None。 如果为None，则解析所有列。 如果为int，则解析最后一列。 如果为list列表，则解析列号列表的列。 如果为字符串，则表示以逗号分隔的Excel列字母和列范围列表（例如“A:E”或“A,C,E:F”）。范围包括双方。 dtype：列的数据类型名称或字典，默认值为None。例如{‘a’:np.float64,’b’:np.int32}。 parse_dates：布尔类型值、int类型值的列表、列表或字典，默认值为False。可以通过parse_dates参数直接将某列转换成datetime64日期类型。例如，df1&#x3D;pd.read_csv(‘1月.csv’, parse_dates&#x3D;[‘订单付款时间’])。 ​ parse_dates为True时，尝试解析索引。 ​ parse_dates为int类型值组成的列表时，如[1,2,3]，则解析1、2、3列的值作为独立的日期列。 ​ parse_date为列表组成的列表，如[[1,3]]，则将1、3列合并，作为一个日期列使用。 ​ parse_date为字典时，如{‘总计’：[1, 3]}，则将1、3列合并，合并后的列名为“总计”。 encoding：字符串，默认值为None，文件的编码格式。Python常用的编码格式是UTF-8。 返回值：返回一个DataFrame。 【示例16】 导入.csv文件。（示例位置：资源包\\MR\\Code\\03\\16）导入.csv文件，程序代码如下： 123import pandas as pddf1=pd.read_csv(&#x27;1月.csv&#x27;**,encoding=**&#x27;gbk&#x27;) #导入.csv文件，并指定编码格式df1=df1.head() #输出前5条数据 运行程序，输出结果如图3.22所示。 ​ 图3.22 导入.csv文件 注意上述代码中指定了编码格式，即encoding&#x3D;’gbk’。Python常用的编码格式是UTF-8和gbk，默认编码格式为UTF-8。导入.csv文件时，需要通过encoding参数指定编码格式。当将Excel文件另存为.csv文件时，默认编码格式为gbk，此时当编写代码导入.csv文件时，就需要设置编码格式为gbk，与源文件编码格式保持一致；否则会提示错误。 3.4.3 导入.txt文本文件导入.txt文件同样使用Pandas的read_csv()方法，不同的是需要指定sep参数（如制表符\\t）。read_csv()方法读取.txt文件返回一个DataFrame，像表格一样的二维数据结构，如图3.23所示。 【示例17】 导入.txt文件。（示例位置：资源包\\MR\\Code\\03\\17）下面使用read_csv()方法导入1月.txt文件，主要代码如下： 123import pandas as pddf1=pd.read_csv(&#x27;1月.txt&#x27;,sep=&#x27;\\t&#x27;,encoding=&#x27;gbk&#x27;)print(df1.head()) 运行程序，输出结果如图3.24所示。 ​ 图3.23 .txt文件形式 ​ 图3.24 导入.txt文本 3.4.4 导入HTML网页导入HTML网页数据主要使用Pandas的read_html()方法，该方法用于导入带有table标签的网页表格数据，语法如下： 1pandas.read_html(io,match=&#x27;.+&#x27;,flavor=None,header=None,index_col=None,skiprows=None,attrs=None,parse_dates=False,thousands=&#x27;,&#x27;,encoding=None,decimal=&#x27;.&#x27;,converters=None,na_values=None,keep_default_na=True,displayed_only=True) 常用参数说明： io：字符串，文件路径，也可以是URL链接。网址不接受https，可以尝试去掉https中的s后爬取，如http://www.mingribook.com。 match：正则表达式，返回与正则表达式匹配的表格。 flavor：解析器默认为lxml。 header：指定列标题所在的行，列表list为多重索引。 index_col：指定行标题对应的列，列表list为多重索引。 encoding：字符串，默认为None，文件的编码格式。 返回值：返回一个DataFrame。使用read_html()方法前，首先要确定网页表格是否为table类型。例如，NBA球员薪资网页（http://www.espn.com/nba/salaries），右击该网页中的表格，在弹出的快捷菜单中选择“检查元素”命令，查看代码中是否含有表格标签…的字样，如图3.25所示。确定后才可以使用read_html()方法。 ​ 图3.25 …表格标签 【示例18】 导入NBA球员薪资数据。（示例位置：资源包\\MR\\Code\\03\\18）下面使用read_html()方法导入NBA球员薪资数据，程序代码如下： 运行程序，输出结果如图3.26所示。 ​ 图3.26 导入网页数据注意运行程序，如果出现ImportError: lxml not found, please install it错误提示信息，则需要安装lxml模块。 3.5 数据抽取数据分析过程中，并不是所有的数据都是我们想要的，此时可以抽取部分数据，主要使用DataFrame对象的loc属性和iloc属性，示意图如图3.27所示。 图3.27 loc属性和iloc属性示意图 对象的loc属性和iloc属性都可以抽取数据，区别如下。 loc属性：以列名（columns）和行名（index）作为参数，当只有一个参数时，默认是行名，即抽取整行数据，包括所有列，如df.loc[‘A’]。 iloc属性：以行和列位置索引（即0，1，2，…)作为参数，0表示第1行，1表示第2行，以此类推。当只有一个参数时，默认是行索引，即抽取整行数据，包括所有列。如抽取第1行数据，df.iloc[0]。 3.5.1 抽取一行数据抽取一行数据主要使用loc属性。【 示例19】 抽取一行考试成绩数据。（示例位置：资源包\\MR\\Code\\03\\19）抽取一行名为“明日”的考试成绩数据（包括所有列），程序代码如下： 运行程序，输出结果如图3.28所示。使用iloc属性抽取第1行数据，指定行索引即可，如df.iloc[0]，输出结果同图3.28一样。 [1,2,2,3] [[1,2,3,4]] ​ 图3.28 抽取一行数据 3.5.2 抽取多行数据1．抽取任意多行数据通过loc属性和iloc属性指定行名和行索引即可实现抽取任意多行数据。 【示例20】 抽取多行考试成绩数据。（示例位置：资源包\\MR\\Code\\03\\20）抽取行名为“明日”和“高袁圆”（即第1行和第3行数据）的考试成绩数据，可以使用loc属性，也可以使用iloc属性，其输出结果都是一样的，主要代码如下： 12df1=df.loc[[&#x27;明日&#x27;,&#x27;高袁圆&#x27;]]df1=df.iloc[[0,2]] 运行程序，输出结果如图3.29所示。 ​ 图3.29 抽取多行数据2．抽取连续任意多行数据在loc属性和iloc属性中合理地使用冒号（:），即可抽取连续任意多行数据。 【示例21】 抽取连续几个学生的考试成绩。（示例位置：资源包\\MR\\Code\\03\\21）抽取连续几个学生的考试成绩，主要代码如下： 运行程序，控制台输出结果如图3.30所示。 ​ 图3.30 抽取连续任意多行数据 3.5.3 抽取指定列数据抽取指定列数据，可以直接使用列名，也可以使用loc属性和iloc属性。1．直接使用列名【示例22】 抽取“语文”和“数学”的考试成绩。（示例位置：资源包\\MR\\Code\\03\\22）抽取列名为“语文”和“数学”的考试成绩数据，程序代码如下： 运行程序，输出结果如图3.31所示。 2．使用loc属性和iloc属性前面介绍loc属性和iloc属性均有两个参数：第一个参数代表行；第二个参数代表列。那么这里抽取指定列数据时，行参数不能省略。 【示例23】 抽取指定学科的考试成绩。（示例位置：资源包\\MR\\Code\\03\\23）下面使用loc属性和iloc属性抽取指定列数据，主要代码如下： 运行程序，控制台输出结果如图3.32所示。 ​ 图3.31 直接使用列名 ​ 图3.32 loc属性和iloc属性 3.5.4 抽取指定行、列数据抽取指定行、列数据主要使用loc属性和iloc属性，这两个方法的两个参数都指定就可以实现指定行、列数据的抽取。 【示例24】 抽取指定学科和指定学生的考试成绩。（示例位置：资源包\\MR\\Code\\03\\24）使用loc属性和iloc属性抽取指定行、列数据，程序代码如下： 运行程序，控制台输出结果如图3.33所示。 图3.33 抽取指定行、列数据 在上述结果中，第一个输出结果是一个数，不是数据，是由于“df.loc[‘七月流火’,’英语’]”没有使用方括号[]，导致输出的数据不是DataFrame类型。 3.5.5 按指定条件抽取数据DataFrame对象实现数据查询有以下3种方式。 取其中的一个元素.iat[x,x]。 基于位置的查询，如.iloc[]、iloc[2,1]。 基于行、列名称的查询，如.loc[x]。 【示例25】 抽取指定学科和指定分数的数据。（示例位置：资源包\\MR\\Code\\03\\25）抽取语文成绩大于105，数学成绩大于88的数据，程序代码如下： 运行程序，输出结果如图3.34所示。 ​ 图3.34 按指定条件抽取数据 3.6 数据的增加、修改和删除本节主要介绍如何操纵DataFrame对象中的各种数据。例如，数据的增加、修改和删除。 3.6.1 增加数据DataFrame对象增加数据主要包括列数据增加和行数据增加。首先看一下原始数据，如图3.35所示。 图3.35 原始数据 1．按列增加数据按列增加数据，可以通过以下3种方式实现。（1）直接为DataFrame对象赋值 【示例26】 增加一列“物理”成绩。（示例位置：资源包\\MR\\Code\\03\\26）增加一列“物理”成绩，程序代码如下： 运行程序，输出结果如图3.36所示。 ​ 图3.36 按列增加数据（2）使用loc属性在DataFrame对象的最后增加一列 【示例27】 使用loc属性增加一列“物理”成绩。（示例位置：资源包\\MR\\Code\\03\\27）使用loc属性在DataFrame对象的最后增加一列。例如，增加“物理”一列，主要代码如下： 1df.loc[:,&#x27;物理&#x27;] = [88,79,60,50] 在DataFrame对象最后增加一列“物理”，其值为等号右边数据。 （3）在指定位置插入一列在指定位置插入一列，主要使用insert()方法。 【示例28】 在第1列后面插入“物理”成绩。（示例位置：资源包\\MR\\Code\\03\\28）例如，在第1列后面插入“物理”，其值为wl的数值，主要代码如下： 12wl =[88,79,60,50]df.insert(1,&#x27;物理&#x27;,wl) 运行程序，输出结果如图3.37所示。 ​ 图3.37 使用insert()方法增加一列 2．按行增加数据按行增加数据，可以通过以下两种方式实现。（1）增加一行数据增加一行数据主要使用loc属性实现。 【示例29】 在成绩表中增加一行数据。（示例位置：资源包\\MR\\Code\\03\\29）在成绩表中增加一行数据，即“钱多多”同学的成绩，主要代码如下： 1df.loc[&#x27;钱多多&#x27;] = [100,120,99] （2）增加多行数据 增加多行数据主要使用字典结合**append()**方法实现。 【示例30】 在原有数据中增加几名同学的考试成绩。（示例位置：资源包\\MR\\Code\\03\\30）在原有数据中增加“钱多多”“童年”“无名”同学的考试成绩，主要代码如下： 12df_insert=pd.DataFrame(&#123;&#x27;语文&#x27;:[100,123,138],&#x27;数学&#x27;:[99,142,60],&#x27;英语&#x27;:[98,139,99]&#125;,index = [&#x27;钱多多&#x27;,&#x27;童年&#x27;,&#x27;无名&#x27;])df1 = df.append(df_insert) 运行程序，输出结果分别如图3.38和图3.39所示。 ​ 图3.38 增加一行数据 ​ 图3.39 增加多行数据 3.6.2 修改数据修改数据包括行、列标题和数据的修改，首先看一下原始数据，如图3.40所示。 ​ 图3.40 原始数据 1．修改列标题修改列标题主要使用DataFrame对象的cloumns属性，直接赋值即可。 【示例31】 修改“数学”的列名。（示例位置：资源包\\MR\\Code\\03\\31）将“数学”修改为“数学（上）”，主要代码如下： 1df.columns=[&#x27;语文&#x27;,&#x27;数学（上）&#x27;,&#x27;英语&#x27;] 上述代码中，即使只修改“数学”为“数学（上）”，但是也要将所有列的标题全部写上；否则将报错。下面再介绍一种方法，使用DataFrame对象的rename()方法修改列标题。 【示例32】 修改多个学科的列名。（示例位置：资源包\\MR\\Code\\03\\32）将“语文”修改为“语文（上）”、“数学”修改为“数学（上）”、“英语”修改为“英语（上）”，主要代码如下： 1df.rename(columns = &#123;&#x27;语文&#x27;:&#x27;语文（上）&#x27;,&#x27;数学&#x27;:&#x27;数学（上）&#x27;,&#x27;英语&#x27;:&#x27;英语（上）&#x27;&#125;,inplace = True) 上述代码中，参数inplace为True，表示直接修改df；否则，不修改df，只返回修改后的数据。运行程序，输出结果分别如图3.41和图3.42所示。 2．修改行标题修改行标题主要使用DataFrame对象的index属性，直接赋值即可。 【示例33】 将行标题统一修改为数字编号。（示例位置：资源包\\MR\\Code\\03\\33）将行标题统一修改为数字编号，主要代码如下： 1df.index=list(&#x27;1234&#x27;) ​ 图3.41 修改列标题1 ​ 图3.42 修改列标题2 使用DataFrame对象的rename()方法也可以修改行标题。例如，将行标题统一修改为数字编号，主要代码如下： 1df.rename(&#123;&#x27;明日&#x27;:1,&#x27;七月流火&#x27;:2,&#x27;高袁圆&#x27;:3,&#x27;二月二&#x27;:4&#125;,axis=0,inplace = True) 3．修改数据修改数据主要使用DataFrame对象的loc属性和iloc属性。 【示例34】 修改学生成绩数据。（示例位置：资源包\\MR\\Code\\03\\34）（1）修改整行数据例如，修改“明日”同学的各科成绩，主要代码如下： 1df.loc[&#x27;明日&#x27;]=[120,115,109] 如果各科成绩均加10分，可以直接在原有值上加10，主要代码如下： 1df.loc[&#x27;明日&#x27;]=df.loc[&#x27;明日&#x27;]+10 （2）修改整列数据例如，修改所有同学的“语文”成绩，主要代码如下： 1df.loc[:,&#x27;语文&#x27;]=[115,108,112,118] （3）修改某一数据 例如，修改“明日”同学的“语文”成绩，主要代码如下： 1df.loc[&#x27;明日&#x27;,&#x27;语文&#x27;]=115 （4）使用iloc属性修改数据通过iloc属性指定行、列位置实现修改数据，主要代码如下： 123df.iloc[0,0]=115 #修改某一数据df.iloc[:,0]=[115,108,112,118] #修改整列数据df.iloc[0,:]=[120,115,109] #修改整行数据 3.6.3 删除数据删除数据主要使用DataFrame对象的drop()方法。语法如下： 1DataFrame.drop(labels=None, axis=0, index=None, columns=None, level=None, inplace=False, errors=&#x27;raise&#x27;) 参数说明： labels：表示行标签或列标签。 axis：axis &#x3D; 0，表示按行删除； ​ axis &#x3D; 1，表示按列删除。默认值为0，即按行删除。 index：删除行，默认值为None。 columns：删除列，默认值为None。 level：针对有两级索引的数据。level &#x3D; 0，表示按第1级索引删除整行；level &#x3D; 1表示按第2级索引删除整行，默认值为None。 inplace：可选参数，对原数组做出修改并返回一个新数组。默认值为False，如果值为True，那么原数组直接就被替换。 errors：参数值为ignore或raise，默认值为raise，如果值为ignore（忽略），则取消错误。 1．删除行、列数据【示例35】 删除学生成绩数据。（示例位置：资源包\\MR\\Code\\03\\35）删除指定的学生成绩数据，主要代码如下： 2．删除特定条件的行删除满足特定条件的行，首先找到满足该条件的行索引，然后再使用drop()方法将其删除。 【示例36】 删除符合条件的学生成绩数据。（示例位置：资源包\\MR\\Code\\03\\36）删除“数学”成绩中包含88的行、“语文”成绩中小于110的行，主要代码如下： 12df.drop(index=df[df[&#x27;数学&#x27;].**isin**([88])].index[0],inplace=True) #删除“数学”成绩中包含88的行df.drop(index=df[df[&#x27;语文&#x27;]&lt;110].index[0],inplace=True) #删除“语文”成绩中小于110的行说明 以上代码中的方法都可以实现删除指定的行、列数据，读者选择一种即可。 3.7 数据清洗3.7.1 缺失值查看与处理缺失值是指由于某种原因导致数据为空，这种情况一般有不处理、删除、填充／替换、插值（以均值／中位数／众数等填补）这4种处理方式。 1．缺失值查看首先需要找到缺失值，主要使用DataFrame对象的info()方法。 【示例37】 查看数据概况。（示例位置：资源包\\MR\\Code\\03\\37）以淘宝销售数据为例，首先输出数据，然后使用info()方法查看数据，程序代码如下： 1234import pandas as pddf=pd.read_excel(&#x27;TB2018.xls&#x27;)print(df)print(df.info()) 运行程序，控制台输出结果如图3.43所示。 图3.43 缺失值查看在Python中，缺失值一般用NaN表示，如图3.43所示。通过info()方法可看到“买家会员名”“买家实际支付金额”“宝贝标题”“订单付款时间”的非空数量是10，而“宝贝总数量”和“类别”的非空数量是8，那么说明这两项存在空值。 【示例38】 判断数据是否存在缺失值。（示例位置：资源包\\MR\\Code\\03\\38）接下来，判断数据是否存在缺失值还可以使用isnull()方法和notnull()方法，主要代码如下： 12print(df.isnull())print(df.notnull()) 运行程序，控制台输出结果如图3.44所示。 ​ 图3.44 判断缺失值使用isnull()方法缺失值返回True，非缺失值返回False；而notnull()方法与isnull()方法正好相反，缺失值返回False，非缺失值返回True。如果使用df[df.isnull() &#x3D;&#x3D; False]， 则会将所有非缺失值的数据找出来，只针对Series对象。 2．缺失值删除处理通过前面的判断得知数据缺失情况，下面将缺失值删除，主要使用dropna()方法，该方法用于删除含有缺失值的行，主要代码如下： df1&#x3D;df.dropna()运行程序，输出结果如图3.45所示。说明有些时候数据可能存在整行为空的情况，此时可以在dropna()方法中指定参数how&#x3D;’all’，删除所有空行。 ​ 图3.45 缺失值删除处理1从运行结果得知：dropna()方法将所有包含缺失值的数据全部删除了。那么，此时如果我们认为有些数据虽然存在缺失值，但是不影响数据分析，那么可以使用以下方法处理。例如，上述数据中只保留“宝贝总数量”不存在缺失值的数据，而类别是否缺失不关注，则可以使用notnull()方法判断，主要代码如下： df2&#x3D;df[df[‘宝贝总数量’].notnull()]运行程序，输出结果如图3.46所示。 图3.46 缺失值删除处理2 3．缺失值填充处理对于缺失数据，如果比例高于30%可以选择放弃这个指标，做删除处理；低于30%尽量不要删除，而是选择将这部分数据填充，一般以0、均值、众数（大多数）填充。DataFrame对象中的fillna()函数可以实现填充缺失数据，pad&#x2F;ffill表示用前一个非缺失值去填充该缺失值；backfill&#x2F;bfill表示用下一个非缺失值填充该缺失值；None用于指定一个值去替换缺失值。 【示例39】 将NaN填充为0。（示例位置：资源包\\MR\\Code\\03\\39）对于用于计算的数值型数据如果为空，可以选择用0填充。例如，将“宝贝总数量”为空的数据填充为0，主要代码如下： df[‘宝贝总数量’] &#x3D; df[‘宝贝总数量’].fillna(0)运行程序，输出结果如图3.47所示。 ​ 图3.47 缺失值填充处理 3.7.2 重复值处理对于数据中存在的重复数据，包括重复的行或者几行中某几列的值重复一般做删除处理，主要使用DataFrame对象的drop_duplicates()方法。 【示例40】 处理淘宝电商销售数据中的重复数据。（示例位置：资源包\\MR\\Code\\03\\40）下面以“1月.xlsx”淘宝销售数据为例，对其中的重复数据进行处理。（1）判断每一行数据是否重复（完全相同），主要代码如下： 1df1.duplicated() 如果返回值为False表示不重复，返回值为True表示重复。（2）去除全部的重复数据，主要代码如下： 1df1.drop_duplicates() （3）去除指定列的重复数据，主要代码如下： 1df1.drop_duplicates([&#x27;买家会员名&#x27;]) （4）保留重复行中的最后一行，主要代码如下： 1df1.drop_duplicates([&#x27;买家会员名&#x27;],keep=&#x27;last&#x27;) 说明:以上代码中参数keep的值有3个。当keep&#x3D;’first’表示保留第一次出现的重复行，是默认值；当keep为另外两个取值，即last和False时，分别表示保留最后一次出现的重复行和去除所有重复行。（5）直接删除，保留一个副本，主要代码如下： 1df1.drop_duplicates([&#x27;买家会员名&#x27;,&#x27;买家支付宝账号&#x27;],inplace=Fasle) inplace&#x3D;True表示直接在原来的DataFrame上删除重复项，而默认值False表示删除重复项后生成一个副本。 3.7.3 异常值的检测与处理首先了解一下什么是异常值。在数据分析中异常值是指超出或低于正常范围的值，如年龄大于200、身高大于3米、宝贝总数量为负数等类似数据。那么这些数据如何检测呢？主要有以下几种方法。（1）根据给定的数据范围进行判断，不在范围内的数据视为异常值。（2）均方差。在统计学中，如果一个数据分布近似正态分布（数据分布的一种形式，正态分布的概率密度函数曲线呈钟形，两头低、中间高、左右对称，因此人们又经常称之为钟形曲线），那么大约68%的数据值会在均值的一个标准差范围内，大约95%会在两个标准差范围内，大约99.7%会在3个标准差范围内。（3）箱形图。箱形图是显示一组数据分散情况资料的统计图。它可以将数据通过四分位数的形式进行图形化描述。箱形图通过上限和下限作为数据分布的边界。任何高于上限或低于下限的数据都可以认为是异常值，如图3.48所示。 ​ 图3.48 箱形图说明有关箱形图的介绍以及如何通过箱形图识别异常值可参见第6章。了解了异常值的检测，接下来介绍如何处理异常值，主要包括以下几种处理方式。（1）最常用的方式是删除。（2）将异常值当缺失值处理，以某个值填充。（3）将异常值当特殊情况进行分析，研究异常值出现的原因。 3.8 索引设置索引能够快速查询数据，本节主要介绍索引的作用以及索引的应用。 3.8.1 索引的作用索引的作用相当于图书的目录，可以根据目录中的页码快速找到所需的内容。Pandas索引的作用如下。 更方便查询数据。 使用索引可以提升查询性能。 如果索引是唯一的，Pandas会使用哈希表优化，查找数据的时间复杂度为O(1)。 如果索引不是唯一的，但是有序，Pandas会使用二分查找算法，查找数据的时间复杂度为O(logN)。 如果索引是完全随机的，那么每次查询都要扫描数据表，查找数据的时间复杂度为O(N)。 自动的数据对齐功能，示意图如图3.49所示。 ​ 图3.49 自动数据对齐示意图实现上述效果，程序代码如下： 1234import pandas as pds1 = pd.Series([10,20,30],index= list(&quot;abc&quot;))s2 = pd.Series([2,3,4],index=list(&quot;bcd&quot;))print(s1 + s2) 基于分类数的索引，提升性能。 多维索引，用于groupby多维聚合结果等。 时间类型索引，强大的日期和时间的方法支持。 3.8.2 重新设置索引Pandas有一个很重要的方法是reindex()，它的作用是创建一个适应新索引的新对象。语法如下： 1DataFrame.reindex(labels = None,index = None,columns = None,axis = None,method = None,copy = True,level = None,fill_value = nan,limit = None,tolerance = None) 常用参数说明： labels：标签，可以是数组，默认值为None（无）。 index：行索引，默认值为None。 columns：列索引，默认值为None。 axis：轴，axis&#x3D;0表示行，axis&#x3D;1表示列。默认值为None。 method：默认值为None，重新设置索引时，选择插值（一种填充缺失数据的方法）方法，其值可以是None、bfill&#x2F;backfill（向后填充）、ffill&#x2F;pad（向前填充）等。 fill_value：缺失值要填充的数据。如缺失值不用NaN填充，而用0填充，则设置fill_value&#x3D;0即可。 1．对Series对象重新设置索引【示例41】 重新设置物理成绩的索引。（示例位置：资源包\\MR\\Code\\03\\41）在3.2.3节已经建立了一组学生的物理成绩，下面重新设置索引，程序代码如下： 1234import pandas as pds1=pd.Series([88,60,75],index=[1,2,3])print(s1)print(s1.reindex([1,2,3,4,5])) 运行程序，控制台输出结果对比如图3.50和图3.51所示。 ​ 图3.50 原数据 ​ 图3.51 重新设置索引从运行结果得知：reindex()方法根据新索引进行了重新排序，并且对缺失值自动填充NaN。如果不想用NaN填充，则可以为fill_value参数指定值，如0，主要代码如下： s1.reindex([1,2,3,4,5],fill_value&#x3D;0)而对于一些有一定顺序的数据，我们可能需要插值（插值是一种填充缺失数据的方法）来填充缺失的数据，可以使用method参数。 【示例42】 向前和向后填充数据。（示例位置：资源包\\MR\\Code\\03\\42）向前填充（和前面数据一样）、向后填充（和后面数据一样），主要代码如下： 12print(s1.reindex([1,2,3,4,5],method=&#x27;ffill&#x27;)) #向前填充print(s1.reindex([1,2,3,4,5],method=&#x27;bfill&#x27;)) #向后填充 2．对DataFrame对象重新设置索引对于DataFrame对象，reindex()方法用于修改行索引和列索引。 【示例43】 创建成绩表并重新设置索引。（示例位置：资源包\\MR\\Code\\03\\43）通过二维数组创建成绩表，程序代码如下： 通过reindex()方法重新设置行索引，主要代码如下： 1df.reindex([&#x27;mr001&#x27;,&#x27;mr002&#x27;,&#x27;mr003&#x27;,&#x27;mr004&#x27;,&#x27;mr005&#x27;]) 通过reindex()方法重新设置列索引，主要代码如下： 1df.reindex(columns=[&#x27;语文&#x27;,&#x27;物理&#x27;,&#x27;数学&#x27;,&#x27;英语&#x27;]) 通过reindex()方法重新设置行索引和列索引，主要代码如下： 1df.reindex(index=[&#x27;mr001&#x27;,&#x27;mr002&#x27;,&#x27;mr003&#x27;,&#x27;mr004&#x27;,&#x27;mr005&#x27;],columns=[&#x27;语文&#x27;,&#x27;物理&#x27;,&#x27;数学&#x27;,&#x27;英语&#x27;]) 运行程序，控制台输出结果分别为原始数据（见图3.52）、重新设置行索引（见图3.53）、重新设置列索引（见图3.54）、重新设置行、列索引（见图3.55）。 ​ 图3.52 原始数据 ​ 图3.53 重新设置行索引 ​ 图3.54 重新设置列索引 3.8.3 设置某列为行索引设置某列为行索引主要使用set_index()方法。 【示例44】 设置“买家会员名”为行索引。（示例位置：资源包\\MR\\Code\\03\\44）首先，导入“1月.xlsx”Excel文件，程序代码如下： 运行程序，输出结果如图3.56所示。此时默认行索引为0、1、2、3、4，下面将“买家会员名”作为行索引，主要代码如下： 1df2=df.set_index([&#x27;买家会员名&#x27;]) 运行程序，输出结果如图3.57所示。 ​ 图3.56 1月淘宝销售数据（部分数据） ​ 图3.57 设置“买家会员名”为索引如果在set_index()方法中传入参数drop&#x3D;True，则会删除“买家会员名”；如果传入drop&#x3D;False，则会保留“买家会员名”。默认为False。 3.8.4 数据清洗后重新设置连续的行索引在对Dataframe对象进行数据清洗后，例如去掉含NaN的行之后，发现行索引还是原来的行索引，对比效果如图3.58和图3.59所示。 ​ 图3.58 原数据 ​ 图3.59 数据清洗后还是原来的索引 【示例45】 删除数据后重新设置索引。（示例位置：资源包\\MR\\Code\\03\\45） 如果要重新设置索引可以使用reset_index()方法，在删除缺失数据后重新设置索引，主要代码如下： 1df2=df.dropna().reset_index(drop=True) 运行程序，输出结果如图3.60所示。 ​ 图3.60 数据清洗后重新设置连续的行索引另外，对于分组统计后的数据，有时也需要重新设置连续的行索引，方法同上。 3.9 数据排序与排名本节主要介绍数据的各种排序和排名方法。 3.9.1 数据排序DataFrame数据排序主要使用sort_values()方法，该方法类似于SQL中的ORDER BY。sort_values()方法可以根据指定行／列进行排序，语法如下： 1DataFrame.sort_values(by,axis=0,ascending=True,inplace=False,kind=&#x27;quicksort&#x27;,na_position=&#x27;last&#x27;,ignore_index=False) 参数说明： by：要排序的名称列表。 axis：轴，axis&#x3D;0表示行，axis&#x3D;1表示列。默认值为0，即按行排序。 ascending：升序或降序排序，布尔值，指定多个排序可以使用布尔值列表。默认值为True。 inplace：布尔值，默认值为False，如果值为True，则就地排序。 kind：指定排序算法，值为quicksort（快速排序）、mergesort（混合排序）或heapsort（堆排），默认值为quicksort。 na_position：空值（NaN）的位置，值为first空值在数据开头，值为last空值在数据最后，默认值为last。 ignore_index：布尔值，是否忽略索引，值为True标记索引（从0开始按顺序的整数值），值为False则忽略索引。 1．按一列数据排序【示例46】 按“销量”降序排序。（示例位置：资源包\\MR\\Code\\03\\46）按“销量”降序排序，排序对比效果如图3.61和图3.62所示。 ​ 图3.61 原始数据 ​ 图3.62 按“销量”降序排序实用技巧Spyder变量浏览窗口本身也支持数据排序，单击需要排序的列即可实现升序或降序排序。程序代码如下： 2．按多列数据排序多列排序是按照给定列的先后顺序进行排序的。 【示例47】 按照“图书名称”和“销量”降序排序。（示例位置：资源包\\MR\\Code\\03\\47）按照“图书名称”和“销量”降序排序，首先按“图书名称”降序排序，然后再按“销量”降序排序，排序后的效果如图3.63所示。 ​ 图3.63 按照“图书名称”和“销量”降序排序主要代码如下： 1df1=df.sort_values(by=[&#x27;图书名称&#x27;,&#x27;销量&#x27;]) 3．对统计结果排序【示例48】 对分组统计数据进行排序。（示例位置：资源包\\MR\\Code\\03\\48） 按“类别”分组统计销量并进行降序排序，统计排序后的效果如图3.64所示。 ​ 图3.64 按“类别”分组统计销量并降序排序主要代码如下： 123df1=df.groupby([&quot;类别&quot;])[&quot;销量&quot;].sum().reset_index()df2=df1.sort_values(by=&#x27;销量&#x27;,ascending=False) 4．按行数据排序【示例49】 按行数据排序。（示例位置：资源包\\MR\\Code\\03\\49）按行排序，主要代码如下： df&#x3D;dfrow.sort_values(by&#x3D;0,ascending&#x3D;True,axis&#x3D;1)注意按行排序的数据类型要一致，否则会出现错误提示。 3.9.2 数据排名排名是根据Series对象或DataFrame的某几列的值进行排名的，主要使用rank()方法，语法如下： DataFrame.rank(axis&#x3D;0,method&#x3D;’average’,numeric_only&#x3D;None,na_option&#x3D;’keep’,ascending&#x3D;True,pct&#x3D;False)参数说明： axis：轴，axis&#x3D;0表示行，axis&#x3D;1表示列。默认值为0，即按行排序。 method：表示在具有相同值的情况下所使用的排序方法。设置值如下。 average：默认值，平均排名。 min：最小值排名。 max：最大值排名。 first：按值在原始数据中的出现顺序分配排名。 dense：密集排名，类似最小值排名，但是排名每次只增加1，即排名相同的数据只占一个名次。 numeric_only：对于DataFrame对象，如果设置值为True，则只对数字列进行排序。 na_option：空值的排序方式，设置值如下。 keep：保留，将空值等级赋值给NaN值。 top：如果按升序排序，则将最小排名赋值给NaN值。 bottom：如果按升序排序，则将最大排名赋值给NaN值。 ascending：升序或降序排序，布尔值，指定多个排序可以使用布尔值列表。默认值为True。 pct：布尔值，是否以百分比形式返回排名。默认值为False。 1．顺序排名 【示例50】 对产品销量按顺序进行排名。（示例位置：资源包\\MRCode\\03\\50）下面对销量相同的产品，按照出现的顺序排名，程序代码如下： 程序运行结果如图3.65所示。2．平均排名 【示例51】 对产品销量进行平均排名。（示例位置：资源包\\MR\\Code\\03\\51）现在对销量相同的产品，按照顺序排名的平均值作为平均排名，主要代码如下： 01 df[‘平均排名’]&#x3D;df[‘销量’].rank(ascending&#x3D;False) 02 df1&#x3D;df[[‘图书名称’,’销量’,’平均排名’]]程序运行结果如图3.66所示。3．最小值排名排名相同的，按顺序排名取最小值作为排名，主要代码如下： df[‘最小值排名’]&#x3D;df[‘销量’].rank(method&#x3D;”min”,ascending&#x3D;False)4．最大值排名排名相同的，按顺序排名取最大值作为排名，主要代码如下： df[‘最大值排名’]&#x3D;df[‘销量’] rank(method&#x3D;”max”,ascending&#x3D;False) ​ 图3.65 销量相同按出现的先后顺序排名 ​ 图3.66 销量相同按顺序排名的平均值排名 3.10 小结本章介绍了Pandas数据处理的基本知识，从最初的数据来源开始（创建DataFrame数据或导入外部数据）到数据抽取、数据增删改操作、数据清洗、索引，再到数据排序，常用的数据处理操作基本都涉及了，通过本章的学习基本能够独立完成一些简单的数据处理工作。","categories":[{"name":"python","slug":"python","permalink":"http://example.com/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"http://example.com/tags/python/"}]},{"title":"vue响应式原理","slug":"vue响应式原理","date":"2021-05-25T09:28:36.000Z","updated":"2022-05-28T03:19:48.453Z","comments":true,"path":"2021/05/25/vue响应式原理/","link":"","permalink":"http://example.com/2021/05/25/vue%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8E%9F%E7%90%86/","excerpt":"","text":"数据驱动 数据响应式、双向绑定、数据驱动 数据响应式 数据模型仅仅是普通的 JavaScript 对象，而当我们修改数据时，视图会进行更新，避免了繁琐的 DOM 操作提高开发效率 双向绑定 数据改变，视图改变;视图改变，数据也随之改变 我们可以使用 v-model 在表单元素上创建双向数据绑定 数据驱动是Vue最独特的特性之一，MVVM表示的是Model-View-ViewModel 开发过程中仅需要关注数据本身，不需要关心数据是如何渲染到视图 Model：模型层，负责处理业务逻辑以及和服务器端进行交互 View：视图层：负责将数据模型转化为UI展示出来，可以简单的理解为HTML页面 ViewModel：视图模型层，用来连接Model和View，是Model和View之间的通信桥梁 数据响应式的核心原理Vue 2.x 核心是通过 ES5 的保护对象的 Object.defindeProperty 中的访问器属性中的 get 和 set 方法，data 中声明的属性都被添加了访问器属性，当读取 data 中的数据时自动调用 get 方法，当修改 data 中的数据时，自动调用 set 方法，检测到数据的变化，会通知观察者 Wacher，观察者 Wacher自动触发重新render 当前组件（子组件不会重新渲染）,生成新的虚拟 DOM 树，Vue 框架会遍历并对比新虚拟 DOM 树和旧虚拟 DOM 树中每个节点的差别，并记录下来，最后，加载操作，将所有记录的不同点，局部修改到真实 DOM树上 总结：Vue 采用数据劫持结合发布—订阅模式的方法，通过 Object.defineProperty() 来劫持各个属性的 setter，getter，在数据变动时发布消息给订阅者，触发相应的监听回调 Object.defineProperty()，那么它的用法是什么，以及优缺点是什么呢？ 可以检测对象中数据发生的修改 对于复杂的对象，层级很深的话，是不友好的，需要经行深度监听，这样子就需要递归到底，这也是它的缺点。 对于一个对象中，如果你新增加属性，删除属性，Object.defineProperty()是不能观测到的，那么应该如何解决呢？可以通过Vue.set()和Vue.delete()来实现。 1234567891011121314151617181920212223242526272829303132// 模拟 Vue 中的 data 选项 let data = &#123; msg: &#x27;hello&#x27;&#125;// 模拟 Vue 的实例 let vm = &#123;&#125;// 数据劫持:当访问或者设置 vm 中的成员的时候，做一些干预操作Object.defineProperty(vm, &#x27;msg&#x27;, &#123; // 可枚举(可遍历) enumerable: true, // 可配置(可以使用 delete 删除，可以通过 defineProperty 重新定义) configurable: true, // 当获取值的时候执行 get () &#123; console.log(&#x27;get: &#x27;, data.msg) return data.msg &#125;, // 当设置值的时候执行 set (newValue) &#123; console.log(&#x27;set: &#x27;, newValue) if (newValue === data.msg) &#123; return &#125; data.msg = newValue // 数据更改，更新 DOM 的值 document.querySelector(&#x27;#app&#x27;).textContent = data.msg &#125; &#125;)// 测试vm.msg = &#x27;Hello World&#x27; console.log(vm.msg) Vue 3.x Vue3.x改用Proxy替代Object.defineProperty。因为Proxy可以直接监听对象和数组的变化，并且有多达13种拦截方法。并且作为新标准将受到浏览器厂商重点持续的性能优化。 12345678910111213141516171819202122232425262728293031const data = [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;]const proxyData = new Proxy(data, &#123; get(target, key, receiver) &#123; // 只处理本身（非原型的）属性 const ownKeys = Reflect.ownKeys(target) if (ownKeys.includes(key)) &#123; console.log(&#x27;get&#x27;, key) // 监听 &#125; const result = Reflect.get(target, key, receiver) return result // 返回结果 &#125;, set(target, key, val, receiver) &#123; // 重复的数据，不处理 if (val === target[key]) &#123; return true &#125; const result = Reflect.set(target, key, val, receiver) console.log(&#x27;set&#x27;, key, val) // console.log(&#x27;result&#x27;, result) // true return result // 是否设置成功 &#125;, deleteProperty(target, key) &#123; const result = Reflect.deleteProperty(target, key) console.log(&#x27;delete property&#x27;, key) // console.log(&#x27;result&#x27;, result) // true return result // 是否删除成功 &#125;&#125;) Reflect作用： 和proxy能力一一对应 规范化，标准化，函数式 代替Object上的工具函数 12345678910const obj = &#123;a: 100, b: 200&#125;&#x27;a&#x27; in obj //trueReflect.has(obj,&#x27;a&#x27;) //truedelete obj.a //trueReflect.deleteProperty(obj,&#x27;a&#x27;) //trueObject.getOwnPropertyNames(obj) //[&quot;a&quot;,&quot;b&quot;]Reflect.owbKeys(obj) //[&quot;a&quot;,&quot;b&quot;] proxy创建响应式 Proxy只会代理对象的第一层，那么Vue3又是怎样处理这个问题的呢？ 判断当前Reflect.get的返回值是否为Object，如果是则再通过reactive方法做代理， 这样就实现了深度观测。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172// 创建响应式function reactive(target = &#123;&#125;) &#123; if (typeof target !== &#x27;object&#x27; || target == null) &#123; // 不是对象或数组，则返回 return target &#125; // 代理配置 const proxyConf = &#123; get(target, key, receiver) &#123; // 只处理本身（非原型的）属性 const ownKeys = Reflect.ownKeys(target) if (ownKeys.includes(key)) &#123; console.log(&#x27;get&#x27;, key) // 监听 &#125; const result = Reflect.get(target, key, receiver) // 深度监听 // 性能如何提升的？ return reactive(result) &#125;, set(target, key, val, receiver) &#123; // 重复的数据，不处理 if (val === target[key]) &#123; return true &#125; const ownKeys = Reflect.ownKeys(target) if (ownKeys.includes(key)) &#123; console.log(&#x27;已有的 key&#x27;, key) &#125; else &#123; console.log(&#x27;新增的 key&#x27;, key) &#125; const result = Reflect.set(target, key, val, receiver) console.log(&#x27;set&#x27;, key, val) // console.log(&#x27;result&#x27;, result) // true return result // 是否设置成功 &#125;, deleteProperty(target, key) &#123; const result = Reflect.deleteProperty(target, key) console.log(&#x27;delete property&#x27;, key) // console.log(&#x27;result&#x27;, result) // true return result // 是否删除成功 &#125; &#125; // 生成代理对象 const observed = new Proxy(target, proxyConf) return observed&#125;// 测试数据const data = &#123; name: &#x27;zhangsan&#x27;, age: 20, info: &#123; city: &#x27;beijing&#x27;, a: &#123; b: &#123; c: &#123; d: &#123; e: 100 &#125; &#125; &#125; &#125; &#125;&#125;const proxyData = reactive(data) Proxy 相比于 defineProperty 的优势 数组变化也能监听到 不需要深度遍历监听","categories":[{"name":"vue","slug":"vue","permalink":"http://example.com/categories/vue/"}],"tags":[{"name":"vue","slug":"vue","permalink":"http://example.com/tags/vue/"}]},{"title":"webpack中常见的Plugin","slug":"webpack中常见的Plugin","date":"2020-01-06T12:06:18.000Z","updated":"2022-05-31T13:53:04.801Z","comments":true,"path":"2020/01/06/webpack中常见的Plugin/","link":"","permalink":"http://example.com/2020/01/06/webpack%E4%B8%AD%E5%B8%B8%E8%A7%81%E7%9A%84Plugin/","excerpt":"","text":"一、是什么Plugin（Plug-in）是一种计算机应用程序，它和主应用程序互相交互，以提供特定的功能 是一种遵循一定规范的应用程序接口编写出来的程序，只能运行在程序规定的系统下，因为其需要调用原纯净系统提供的函数库或者数据 webpack中的plugin也是如此，plugin赋予其各种灵活的功能，例如打包优化、资源管理、环境变量注入等，它们会运行在 webpack 的不同阶段（钩子 &#x2F; 生命周期），贯穿了webpack整个编译周期 目的在于解决loader 无法实现的其他事 配置方式这里讲述文件的配置方式，一般情况，通过配置文件导出对象中plugins属性传入new实例对象。如下所示： 123456789const HtmlWebpackPlugin = require(&#x27;html-webpack-plugin&#x27;); // 通过 npm 安装const webpack = require(&#x27;webpack&#x27;); // 访问内置的插件module.exports = &#123; ... plugins: [ new webpack.ProgressPlugin(), new HtmlWebpackPlugin(&#123; template: &#x27;./src/index.html&#x27; &#125;), ],&#125;; 二、特性其本质是一个具有apply方法javascript对象 apply 方法会被 webpack compiler调用，并且在整个编译生命周期都可以访问 compiler对象 1234567891011const pluginName = &#x27;ConsoleLogOnBuildWebpackPlugin&#x27;;class ConsoleLogOnBuildWebpackPlugin &#123; apply(compiler) &#123; compiler.hooks.run.tap(pluginName, (compilation) =&gt; &#123; console.log(&#x27;webpack 构建过程开始！&#x27;); &#125;); &#125;&#125;module.exports = ConsoleLogOnBuildWebpackPlugin; compiler hook 的 tap方法的第一个参数，应是驼峰式命名的插件名称 关于整个编译生命周期钩子，有如下： entry-option ：初始化 option run compile： 真正开始的编译，在创建 compilation 对象之前 compilation ：生成好了 compilation 对象 make 从 entry 开始递归分析依赖，准备对每个模块进行 build after-compile： 编译 build 过程结束 emit ：在将内存中 assets 内容写到磁盘文件夹之前 after-emit ：在将内存中 assets 内容写到磁盘文件夹之后 done： 完成所有的编译过程 failed： 编译失败的时候 三、常见的Plugin常见的plugin有如图所示： loader和plugin有什么区别？ webapck默认只能打包JS和JOSN模块，要打包其它模块，需要借助loader，loader就可以让模块中的内容转化成webpack或其它laoder可以识别的内容。 loader就是模块转换化，或叫加载器。不同的文件，需要不同的loader来处理。 plugin是插件，可以参与到整个webpack打包的流程中，不同的插件，在合适的时机，可以做不同的事件。","categories":[{"name":"webpack","slug":"webpack","permalink":"http://example.com/categories/webpack/"}],"tags":[{"name":"webpack","slug":"webpack","permalink":"http://example.com/tags/webpack/"}]},{"title":"webpack中常见的Loader","slug":"webpack中常见的Loader","date":"2020-01-06T09:25:18.000Z","updated":"2022-05-31T09:32:57.762Z","comments":true,"path":"2020/01/06/webpack中常见的Loader/","link":"","permalink":"http://example.com/2020/01/06/webpack%E4%B8%AD%E5%B8%B8%E8%A7%81%E7%9A%84Loader/","excerpt":"","text":"一、是什么loader 用于对模块的”源代码”进行转换，在 import 或”加载”模块时预处理文件。 webpack做的事情，仅仅是分析出各种模块的依赖关系，然后形成资源列表，最终打包生成到指定的文件中。 在webpack内部中，任何文件都是模块，不仅仅只是js文件。 默认情况下，在遇到import或者require加载模块的时候，**webpack只支持对js 和 json 文件打包** 像css、sass、png等这些类型的文件的时候，webpack则无能为力，这时候就需要配置对应的loader进行文件内容的解析。 在加载模块的时候，执行顺序如下： 当 webpack 碰到不识别的模块的时候，webpack 会在配置的中查找该文件解析规则 关于配置loader的方式有三种： 配置方式（推荐）：在 webpack.config.js文件中指定 loader 内联方式：在每个 import 语句中显式指定 loader CLI 方式：在 shell 命令中指定它们 配置方式关于loader的配置，我们是写在module.rules属性中，属性介绍如下： rules是一个数组的形式，因此我们可以配置很多个loader 每一个loader对应一个对象的形式，对象属性test 为匹配的规则，一般情况为正则表达式 属性use针对匹配到文件类型，调用对应的 loader 进行处理 代码编写，如下形式： 12345678910111213141516171819module.exports = &#123; module: &#123; rules: [ &#123; test: /\\.css$/, use: [ &#123; loader: &#x27;style-loader&#x27; &#125;, &#123; loader: &#x27;css-loader&#x27;, options: &#123; modules: true &#125; &#125;, &#123; loader: &#x27;sass-loader&#x27; &#125; ] &#125; ] &#125;&#125;; 二、特性这里继续拿上述代码，来讲讲loader的特性 从上述代码可以看到，在处理css模块的时候，use属性中配置了三个loader分别处理css文件 因为loader支持链式调用，链中的每个loader会处理之前已处理过的资源，最终变为js代码。顺序为相反的顺序执行，即上述执行方式为sass-loader、css-loader、style-loader 除此之外，loader的特性还有如下： loader 可以是同步的，也可以是异步的 loader 运行在 Node.js 中，并且能够执行任何操作 除了常见的通过 package.json 的 main 来将一个 npm 模块导出为 loader，还可以在 module.rules 中使用 loader 字段直接引用一个模块 插件(plugin)可以为 loader 带来更多特性 loader 能够产生额外的任意文件 可以通过 loader 的预处理函数，为 JavaScript 生态系统提供更多能力。用户现在可以更加灵活地引入细粒度逻辑，例如：压缩、打包、语言翻译和更多其他特性 三、常见的loader在页面开发过程中，我们经常性加载除了js文件以外的内容，这时候我们就需要配置响应的loader进行加载 常见的loader如下： style-loader: 将css添加到DOM的内联样式标签style里 css-loader :允许将css文件通过require的方式引入，并返回css代码 less-loader: 处理less sass-loader: 处理sass postcss-loader: 用postcss来处理CSS autoprefixer-loader: 处理CSS3属性前缀，已被弃用，建议直接使用postcss file-loader: 分发文件到output目录并返回相对路径 url-loader: 和file-loader类似，但是当文件小于设定的limit时可以返回一个Data Url html-minify-loader: 压缩HTML babel-loader :用babel来转换ES6文件到ES 下面给出一些常见的loader的使用： css-loader分析 css 模块之间的关系，并合成⼀个 css 1npm install --save-dev css-loader 1234567891011121314151617rules: [ ..., &#123; test: /\\.css$/, use: &#123; loader: &quot;css-loader&quot;, options: &#123; // 启用/禁用 url() 处理 url: true, // 启用/禁用 @import 处理 import: true, // 启用/禁用 Sourcemap sourceMap: false &#125; &#125; &#125;] 如果只通过css-loader加载文件，这时候页面代码设置的样式并没有生效 原因在于，css-loader只是负责将.css文件进行一个解析，而并不会将解析后的css插入到页面中 如果我们希望再完成插入style的操作，那么我们还需要另外一个loader，就是style-loader style-loader把 css-loader 生成的内容，用 style 标签挂载到页面的 head 中 1npm install --save-dev style-loader 1234567rules: [ ..., &#123; test: /\\.css$/, use: [&quot;style-loader&quot;, &quot;css-loader&quot;] &#125;] 同一个任务的 loader 可以同时挂载多个，处理顺序为：从右到左，从下往上 less-loader开发中，我们也常常会使用less、sass、stylus预处理器编写css样式，使开发效率提高，这里需要使用less-loader 1npm install less-loader -D 1234567rules: [ ..., &#123; test: /\\.css$/, use: [&quot;style-loader&quot;, &quot;css-loader&quot;,&quot;less-loader&quot;] &#125;] raw-loader在 webpack中通过 import方式导入文件内容，该loader并不是内置的，所以首先要安装 1npm install --save-dev raw-loader 然后在 webpack.config.js 中进行配置 1234567891011module.exports = &#123; ..., module: &#123; rules: [ &#123; test: /\\.(txt|md)$/, use: &#x27;raw-loader&#x27; &#125; ] &#125;&#125; file-loader把识别出的资源模块，移动到指定的输出⽬目录，并且返回这个资源在输出目录的地址(字符串) 1npm install --save-dev file-loader 123456789101112131415161718rules: [ ..., &#123; test: /\\.(png|jpe?g|gif)$/, use: &#123; loader: &quot;file-loader&quot;, options: &#123; // placeholder 占位符 [name] 源资源模块的名称 // [ext] 源资源模块的后缀 name: &quot;[name]_[hash].[ext]&quot;, //打包后的存放位置 outputPath: &quot;./images&quot;, // 打包后文件的 url publicPath: &#x27;./images&#x27;, &#125; &#125; &#125;] url-loader可以处理理 file-loader 所有的事情，但是遇到图片格式的模块，可以选择性的把图片转成 base64 格式的字符串，并打包到 js 中，对小体积的图片比较合适，大图片不合适。 1npm install --save-dev url-loader 1234567891011121314151617181920rules: [ ..., &#123; test: /\\.(png|jpe?g|gif)$/, use: &#123; loader: &quot;url-loader&quot;, options: &#123; // placeholder 占位符 [name] 源资源模块的名称 // [ext] 源资源模块的后缀 name: &quot;[name]_[hash].[ext]&quot;, //打包后的存放位置 outputPath: &quot;./images&quot; // 打包后文件的 url publicPath: &#x27;./images&#x27;, // 小于 100 字节转成 base64 格式 limit: 100 &#125; &#125; &#125;]","categories":[{"name":"webpack","slug":"webpack","permalink":"http://example.com/categories/webpack/"}],"tags":[{"name":"webpack","slug":"webpack","permalink":"http://example.com/tags/webpack/"}]},{"title":"webpack原理","slug":"webpack原理","date":"2020-01-06T09:06:18.000Z","updated":"2022-05-31T09:26:01.807Z","comments":true,"path":"2020/01/06/webpack原理/","link":"","permalink":"http://example.com/2020/01/06/webpack%E5%8E%9F%E7%90%86/","excerpt":"","text":"一、背景Webpack 最初的目标是实现前端项目的模块化，旨在更高效地管理和维护项目中的每一个资源 模块化最早的时候，我们会通过文件划分的形式实现模块化，也就是将每个功能及其相关状态数据各自单独放到不同的JS 文件中 约定每个文件是一个独立的模块，然后再将这些js文件引入到页面，一个script标签对应一个模块，然后调用模块化的成员 12&lt;script src=&quot;module-a.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;module-b.js&quot;&gt;&lt;/script&gt; 但这种模块弊端十分的明显，模块都是在全局中工作，大量模块成员污染了环境，模块与模块之间并没有依赖关系、维护困难、没有私有空间等问题 项目一旦变大，上述问题会尤其明显 随后，就出现了命名空间方式，规定每个模块只暴露一个全局对象，然后模块的内容都挂载到这个对象中 12345window.moduleA = &#123; method1: function () &#123; console.log(&#x27;moduleA#method1&#x27;) &#125;&#125; 这种方式也并没有解决第一种方式的依赖等问题 再后来，我们使用立即执行函数为模块提供私有空间，通过参数的形式作为依赖声明，如下 12345678910111213// module-a.js(function ($) &#123; var name = &#x27;module-a&#x27; function method1 () &#123; console.log(name + &#x27;#method1&#x27;) $(&#x27;body&#x27;).animate(&#123; margin: &#x27;200px&#x27; &#125;) &#125; window.moduleA = &#123; method1: method1 &#125;&#125;)(jQuery) 上述的方式都是早期解决模块的方式，但是仍然存在一些没有解决的问题。例如，我们是用过script标签在页面引入这些模块的，这些模块的加载并不受代码的控制，时间一久维护起来也十分的麻烦 理想的解决方式是，在页面中引入一个JS入口文件，其余用到的模块可以通过代码控制，按需加载进来 除了模块加载的问题以外，还需要规定模块化的规范，如今流行的则是CommonJS、ES Modules 二、问题从后端渲染的JSP、PHP，到前端原生JavaScript，再到jQuery开发，再到目前的三大框架Vue、React、Angular 开发方式，也从javascript到后面的es5、es6、7、8、9、10，再到typescript，包括编写CSS的预处理器less、scss等 现代前端开发已经变得十分的复杂，所以我们开发过程中会遇到如下的问题： 需要通过模块化的方式来开发 使用一些高级的特性来加快我们的开发效率或者安全性，比如通过ES6+、TypeScript开发脚本逻辑，通过sass、less等方式来编写css样式代码 监听文件的变化来并且反映到浏览器上，提高开发的效率 JavaScript 代码需要模块化，HTML 和 CSS 这些资源文件也会面临需要被模块化的问题 开发完成后我们还需要将代码进行压缩、合并以及其他相关的优化 而webpack恰巧可以解决以上问题 三、是什么webpack 是一个用于现代JavaScript应用程序的静态模块打包工具 静态模块 这里的静态模块指的是开发阶段，可以被 webpack 直接引用的资源（可以直接被获取打包进bundle.js的资源） 当 webpack处理应用程序时，它会在内部构建一个依赖图，此依赖图对应映射到项目所需的每个模块（不再局限js文件），并生成一个或多个 bundle webpack的能力：编译代码能力，提高效率，解决浏览器兼容问题 模块整合能力，提高性能，可维护性，解决浏览器频繁请求文件的问题 万物皆可模块能力，项目维护性增强，支持不同种类的前端模块类型，统一的模块化方案，所有资源文件的加载都可以通过代码控制 四、原理简述核心概念 JavaScript 的 模块打包工具 (module bundler)。通过分析模块之间的依赖，最终将所有模块打包成一份或者多份代码包 (bundler)，供 HTML 直接引用。实质上，Webpack 仅仅提供了 打包功能 和一套 文件处理机制，然后通过生态中的各种 Loader 和 Plugin 对代码进行预编译和打包。因此 Webpack 具有高度的可拓展性，能更好的发挥社区生态的力量。 Entry: 入口文件，Webpack会从该文件开始进行分析与编译； Output: 出口路径，打包后创建 bundler的文件路径以及文件名； Module: 模块，在 Webpack 中任何文件都可以作为一个模块，会根据配置的不同的 Loader 进行加载和打包； Chunk: 代码块，可以根据配置，将所有模块代码合并成一个或多个代码块，以便按需加载，提高性能； Loader: 模块加载器，进行各种文件类型的加载与转换； Plugin: 拓展插件，可以通过 Webpack 相应的事件钩子，介入到打包过程中的任意环节，从而对代码按需修改； 工作流程 (加载 - 编译 - 输出) 读取配置文件，按命令 初始化 配置参数，创建 Compiler 对象； 调用插件的 apply 方法 挂载插件 监听，然后从入口文件开始执行编译； 按文件类型，调用相应的 Loader 对模块进行 编译，并在合适的时机点触发对应的事件，调用 Plugin 执行，最后再根据模块 依赖查找 到所依赖的模块，递归执行第三步； 将编译后的所有代码包装成一个个代码块 (Chuck)， 并按依赖和配置确定 输出内容。这个步骤，仍然可以通过 Plugin 进行文件的修改; 最后，根据 Output 把文件内容一一写入到指定的文件夹中，完成整个过程； 总结 初始化参数：从配置文件和 Shell 语句中读取与合并参数，得出最终的参数 开始编译：用上一步得到的参数初始化 Compiler 对象，加载所有配置的插件，执行对象的 run 方法开始执行编译 确定入口：根据配置中的 entry 找出所有的入口文件 编译模块：从入口文件出发，调用所有配置的 Loader 对模块进行翻译，再找出该模块依赖的模块，再递归本步骤直到所有入口依赖的文件都经过了本步骤的处理 完成模块编译：在经过第4步使用 Loader 翻译完所有模块后，得到了每个模块被翻译后的最终内容以及它们之间的依赖关系 输出资源：根据入口和模块之间的依赖关系，组装成一个个包含多个模块的 Chunk，再把每个 Chunk 转换成一个单独的文件加入到输出列表，这步是可以修改输出内容的最后机会 输出完成：在确定好输出内容后，根据配置确定输出的路径和文件名，把文件内容写入到文件系统","categories":[{"name":"webpack","slug":"webpack","permalink":"http://example.com/categories/webpack/"}],"tags":[{"name":"webpack","slug":"webpack","permalink":"http://example.com/tags/webpack/"}]},{"title":"http和https","slug":"http和https","date":"2019-06-06T09:26:15.000Z","updated":"2022-06-06T09:35:29.502Z","comments":true,"path":"2019/06/06/http和https/","link":"","permalink":"http://example.com/2019/06/06/http%E5%92%8Chttps/","excerpt":"","text":"一、HTTPHTTP (HyperText Transfer Protocol)，即超文本运输协议，是实现网络通信的一种规范 在计算机和网络世界有，存在不同的协议，如广播协议、寻址协议、路由协议等等…… 而HTTP是一个传输协议，即将数据由A传到B或将B传输到A，并且 A 与 B 之间能够存放很多第三方，如： A&lt;&#x3D;&gt;X&lt;&#x3D;&gt;Y&lt;&#x3D;&gt;Z&lt;&#x3D;&gt;B 传输的数据并不是计算机底层中的二进制包，而是完整的、有意义的数据，如HTML 文件, 图片文件, 查询结果等超文本，能够被上层应用识别 在实际应用中，HTTP常被用于在Web浏览器和网站服务器之间传递信息，以明文方式发送内容，不提供任何方式的数据加密 特点如下： 支持客户&#x2F;服务器模式 简单快速：客户向服务器请求服务时，只需传送请求方法和路径。由于HTTP协议简单，使得HTTP服务器的程序规模小，因而通信速度很快 灵活：HTTP允许传输任意类型的数据对象。正在传输的类型由Content-Type加以标记 无连接：无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间 无状态：HTTP协议无法根据之前的状态进行本次的请求处理 二、HTTPS在上述介绍HTTP中，了解到HTTP传递信息是以明文的形式发送内容，这并不安全。而HTTPS出现正是为了解决HTTP不安全的特性 为了保证这些隐私数据能加密传输，让HTTP运行安全的SSL/TLS协议上，即 HTTPS &#x3D; HTTP + SSL&#x2F;TLS，通过 SSL证书来验证服务器的身份，并为浏览器和服务器之间的通信进行加密 SSL 协议位于TCP/IP 协议与各种应用层协议之间，浏览器和服务器在使用 SSL 建立连接时需要选择一组恰当的加密算法来实现安全通信，为数据通讯提供安全支持 流程图如下所示： 首先客户端通过URL访问服务器建立SSL连接 服务端收到客户端请求后，会将网站支持的证书信息（证书中包含公钥）传送一份给客户端 客户端的服务器开始协商SSL连接的安全等级，也就是信息加密的等级 客户端的浏览器根据双方同意的安全等级，建立会话密钥，然后利用网站的公钥将会话密钥加密，并传送给网站 服务器利用自己的私钥解密出会话密钥 服务器利用会话密钥加密与客户端之间的通信 三、区别 HTTPS是HTTP协议的安全版本，HTTP协议的数据传输是明文的，是不安全的，HTTPS使用了SSL&#x2F;TLS协议进行了加密处理，相对更安全 HTTP 和 HTTPS 使用连接方式不同，默认端口也不一样，HTTP是80，HTTPS是443 HTTPS 由于需要设计加密以及多次握手，性能方面不如 HTTP HTTPS需要SSL，SSL 证书需要钱，功能越强大的证书费用越高 四、安全特性在上面，我们了解到HTTP在通信过程中，存在以下问题： 通信使用明文（不加密），内容可能被窃听 不验证通信方的身份，因此有可能遭遇伪装 而HTTPS的出现正是解决这些问题，HTTPS是建立在SSL之上，其安全性由SSL来保证 在采用SSL后，HTTP就拥有了HTTPS的加密、证书和完整性保护这些功能 SSL(Secure Sockets Layer 安全套接字协议),及其继任者传输层安全（Transport Layer Security，TLS）是为网络通信提供安全及数据完整性的一种安全协议 五、如何做SSL的实现这些功能主要依赖于三种手段： 对称加密：采用协商的密钥对数据加密 非对称加密：实现身份认证和密钥协商 摘要算法：验证信息的完整性 数字签名：身份验证 对称加密对称加密指的是加密和解密使用的秘钥都是同一个，是对称的。只要保证了密钥的安全，那整个通信过程就可以说具有了机密性 非对称加密非对称加密，存在两个秘钥，一个叫公钥，一个叫私钥。两个秘钥是不同的，公钥可以公开给任何人使用，私钥则需要保密 公钥和私钥都可以用来加密解密，但公钥加密后只能用私钥解 密，反过来，私钥加密后也只能用公钥解密 混合加密在HTTPS通信过程中，采用的是对称加密+非对称加密，也就是混合加密 在对称加密中讲到，如果能够保证了密钥的安全，那整个通信过程就可以说具有了机密性 而HTTPS采用非对称加密解决秘钥交换的问题 具体做法是发送密文的一方使用对方的公钥进行加密处理“对称的密钥”，然后对方用自己的私钥解密拿到“对称的密钥” 这样可以确保交换的密钥是安全的前提下，使用对称加密方式进行通信 举个例子网站秘密保管私钥，在网上任意分发公钥，你想要登录网站只要用公钥加密就行了，密文只能由私钥持有者才能解密。而黑客因为没有私钥，所以就无法破解密文 上述的方法解决了数据加密，在网络传输过程中，数据有可能被篡改，并且黑客可以伪造身份发布公钥，如果你获取到假的公钥，那么混合加密也并无多大用处，你的数据扔被黑客解决 因此，在上述加密的基础上仍需加上完整性、身份验证的特性，来实现真正的安全，实现这一功能则是摘要算法 摘要算法实现完整性的手段主要是摘要算法，也就是常说的散列函数、哈希函数 可以理解成一种特殊的压缩算法，它能够把任意长度的数据“压缩”成固定长度、而且独一无二的“摘要”字符串，就好像是给这段数据生成了一个数字“指纹” 摘要算法保证了“数字摘要”和原文是完全等价的。所以，我们只要在原文后附上它的摘要，就能够保证数据的完整性 比如，你发了条消息：“转账 1000 元”，然后再加上一个 SHA-2 的摘要。网站收到后也计算一下消息的摘要，把这两份“指纹”做个对比，如果一致，就说明消息是完整可信的，没有被修改 数字签名数字签名能确定消息确实是由发送方签名并发出来的，因为别人假冒不了发送方的签名 原理其实很简单，就是用私钥加密，公钥解密 签名和公钥一样完全公开，任何人都可以获取。但这个签名只有用私钥对应的公钥才能解开，拿到摘要后，再比对原文验证完整性，就可以像签署文件一样证明消息确实是你发的 和消息本身一样，因为谁都可以发布公钥，我们还缺少防止黑客伪造公钥的手段，也就是说，怎么判断这个公钥就是你的公钥 这时候就需要一个第三方，就是证书验证机构 CA验证机构数字证书认证机构处于客户端与服务器双方都可信赖的第三方机构的立场 CA 对公钥的签名认证要求包括序列号、用途、颁发者、有效时间等等，把这些打成一个包再签名，完整地证明公钥关联的各种信息，形成“数字证书” 流程如下图： 服务器的运营人员向数字证书认证机构提出公开密钥的申请 数字证书认证机构在判明提出申请者的身份之后，会对已申请的公开密钥做数字签名 然后分配这个已签名的公开密钥，并将该公开密钥放入公钥证书后绑定在一起 服务器会将这份由数字证书认证机构颁发的数字证书发送给客户端，以进行非对称加密方式通信 接到证书的客户端可使用数字证书认证机构的公开密钥，对那张证书上的数字签名进行验证，一旦验证通过，则证明： 认证服务器的公开密钥的是真实有效的数字证书认证机构 服务器的公开密钥是值得信赖的 六、总结可以看到，HTTPS与HTTP虽然只差一个SSL，但是通信安全得到了大大的保障，通信的四大特性都以解决，解决方式如下： 机密性：混合算法 完整性：摘要算法 身份认证：数字签名 不可否定：数字签名 同时引入第三方证书机构，确保公开秘钥的安全性","categories":[{"name":"http","slug":"http","permalink":"http://example.com/categories/http/"}],"tags":[{"name":"http","slug":"http","permalink":"http://example.com/tags/http/"}]},{"title":"浏览器缓存","slug":"浏览器缓存","date":"2019-05-30T02:53:51.000Z","updated":"2022-06-05T14:23:44.651Z","comments":true,"path":"2019/05/30/浏览器缓存/","link":"","permalink":"http://example.com/2019/05/30/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98/","excerpt":"","text":"我们经常需要对业务中的一些数据进行存储，通常可以分为 短暂性存储 和 持久性储存。 短暂性的时候，我们只需要将数据存在内存中，只在运行时可用 持久性存储，可以分为 浏览器端 与 服务器端 浏览器: cookie : 通常用于存储用户身份，登录状态等 http 中自动携带， 体积上限为 4K， 可自行设置过期时间 localStorage / sessionStorage: 长久储存&#x2F;窗口关闭删除， 体积限制为 4~5M indexDB 服务器: 分布式缓存 redis 数据库 提示：如果平常有遇到过缓存的坑或者很好的利用缓存，可以讲解一下自己的使用场景。如果没有使用注意过缓存问题你也可以尝试讲解一下和我们息息相关的Webpack构建（每一次构建静态资源名称的hash值都会变化），它其实就跟缓存相关 缓存分为强缓存和协商缓存。强缓存不过服务器，协商缓存需要过服务器，协商缓存返回的状态码是304。两类缓存机制可以同时存在，强缓存的优先级高于协商缓存。当执行强缓存时，如若缓存命中，则直接使用缓存数据库中的数据，不再进行缓存协商。 强缓存**Expires(HTTP1.0)**：Exprires的值为服务端返回的数据到期时间。当再次请求时的请求时间小于返回的此时间，则直接使用缓存数据。但由于服务端时间和客户端时间可能有误差，这也将导致缓存命中的误差。另一方面，Expires是HTTP1.0的产物，故现在大多数使用Cache-Control替代 缺点：使用的是绝对时间，如果服务端和客户端的时间产生偏差，那么会导致命中缓存产生偏差。 **Cache-Control(HTTP1.1)**：有很多属性，不同的属性代表的意义也不同 private：客户端可以缓存 public：客户端和代理服务器都可以缓存 max-age=t：缓存内容将在t秒后失效 no-cache：需要使用协商缓存来验证缓存数据 no-store：所有内容都不会缓存 请注意no-cache指令很多人误以为是不缓存，这是不准确的，no-cache的意思是可以缓存，但每次用应该去向服务器验证缓存是否可用。no-store才是不缓存内容。当在首部字段Cache-Control 有指定 max-age 指令时，比起首部字段 Expires，会优先处理 max-age 指令。命中强缓存的表现形式：Firefox浏览器表现为一个灰色的200状态码。Chrome浏览器状态码表现为200 (from disk cache)或是200 OK (from memory cache) 协商缓存 协商缓存需要进行对比判断是否可以使用缓存。浏览器第一次请求数据时，服务器会将缓存标识与数据一起响应给客户端，客户端将它们备份至缓存中。再次请求时，客户端会将缓存中的标识发送给服务器，服务器根据此标识判断。若未失效，返回304状态码，浏览器拿到此状态码就可以直接使用缓存数据了 Last-Modified：服务器在响应请求时，会告诉浏览器资源的最后修改时间 if-Modified-Since：浏览器再次请求服务器的时候，请求头会包含此字段，后面跟着在缓存中获得的最后修改时间。服务端收到此请求头发现有if-Modified-Since，则与被请求资源的最后修改时间进行对比，如果一致则返回304和响应报文头，浏览器只需要从缓存中获取信息即可 如果真的被修改：那么开始传输响应一个整体，服务器返回：200 OK 如果没有被修改：那么只需传输响应header，服务器返回：304 Not Modified Etag：服务器响应请求时，通过此字段告诉浏览器当前资源在服务器生成的唯一标识（生成规则由服务器决定） If-Match：条件请求，携带上一次请求中资源的ETag，服务器根据这个字段判断文件是否有新的修改 If-None-Match： 再次请求服务器时，浏览器的请求报文头部会包含此字段，后面的值为在缓存中获取的标识。服务器接收到次报文后发现If-None-Match则与被请求资源的唯一标识进行对比。 但是实际应用中由于Etag的计算是使用算法来得出的，而算法会占用服务端计算的资源，所有服务端的资源都是宝贵的，所以就很少使用Etag了 浏览器地址栏中写入URL，回车浏览器发现缓存中有这个文件了，不用继续请求了，直接去缓存拿（最快） F5就是告诉浏览器，别偷懒，好歹去服务器看看这个文件是否有过期了。于是浏览器就胆胆襟襟的发送一个请求带上If-Modify-since Ctrl+F5告诉浏览器，你先把你缓存中的这个文件给我删了，然后再去服务器请求个完整的资源文件下来。于是客户端就完成了强行更新的操作 缓存场景 对于大部分的场景都可以使用强缓存配合协商缓存解决，但是在一些特殊的地方可能需要选择特殊的缓存策 对于某些不需要缓存的资源，可以使用 Cache-control: no-store ，表示该资源不需要缓存 对于频繁变动的资源，可以使用 Cache-Control: no-cache 并配合 ETag 使用，表示该资源已被缓存，但是每次都会发送请求询问资源是否更新 对于代码文件来说，通常使用 Cache-Control: max-age=31536000 并配合策略缓存使用，然后对文件进行指纹处理，一旦文件名变动就会立刻下载新的文件 讲讲304 如果客户端发送了一个带条件的 GET 请求且该请求已被允许，而文档的内容(自 上次访问以来或者根据请求的条件)并没有改变，则服务器应当返回这个 304 状态码 强缓存、协商缓存什么时候用哪个 因为服务器上的资源不是一直固定不变的，大多数情况下它会更新，这个时候如果我们 还访问本地缓存，那么对用户来说，那就相当于资源没有更新，用户看到的还是旧的资 源;所以我们希望服务器上的资源更新了浏览器就请求新的资源，没有更新就使用本地 的缓存，以最大程度的减少因网络请求而产生的资源浪费。 缓存总结 缓存分为两种:强缓存和协商缓存，根据响应的 header 内容来决定。 获取资源形式 状态码 发送请求到服务器 强缓存 从缓存取 200(from cache) 否，直接从缓存取 协商缓存 从缓存取 304(not modified) 是，通过服务器来告知缓存是否可 用 强缓存相关字段有 expires，cache-control。如果 cache-control 与 expires 同时存在的话， cache-control 的优先级高于 expires。 协商缓存相关字段有 Last-Modified/If-Modified-Since，Etag/If-None-Match cookie和localSrorage、session、indexDB 的区别 特性 cookie localStorage sessionStorage indexDB 数据生命周期 一般由服务器生成，可以设置过期时间 除非被清理，否则一直存在 页面关闭就清理 除非被清理，否则一直存在 数据存储大小 4K 5M 5M 无限 与服务端通信 每次都会携带在 header 中，对于请求性能影响 不参与 不参与 不参与 从上表可以看到，cookie 已经不建议用于存储。如果没有大量数据存储需求的话，可以使用 localStorage和 sessionStorage 。对于不怎么改变的数据尽量使用 localStorage 存储，否则可以用 sessionStorage 存储。 对于 cookie，我们还需要注意安全性 属性 作用 value 如果用于保存用户登录态，应该将该值加密，不能使用明文的用户标识 http-only 不能通过 JS访问 Cookie，减少 XSS攻击 secure 只能在协议为 HTTPS 的请求中携带 same-site 规定浏览器不能在跨域请求中携带 Cookie，减少 CSRF 攻击","categories":[{"name":"http","slug":"http","permalink":"http://example.com/categories/http/"}],"tags":[{"name":"http","slug":"http","permalink":"http://example.com/tags/http/"}]},{"title":"react中的Hooks","slug":"react中的Hooks","date":"2018-10-19T06:03:59.000Z","updated":"2022-06-02T09:18:50.356Z","comments":true,"path":"2018/10/19/react中的Hooks/","link":"","permalink":"http://example.com/2018/10/19/react%E4%B8%AD%E7%9A%84Hooks/","excerpt":"","text":"一、是什么Hook 是 React 16.8 的新增特性。它可以让你在不编写 class 的情况下使用 state 以及其他的 React 特性 至于为什么引入hook，官方给出的动机是解决长时间使用和维护react过程中常遇到的问题，例如： 难以重用和共享组件中的与状态相关的逻辑 逻辑复杂的组件难以开发与维护，当我们的组件需要处理多个互不相关的 local state 时，每个生命周期函数中可能会包含着各种互不相关的逻辑在里面 类组件中的this增加学习成本，类组件在基于现有工具的优化上存在些许问题 由于业务变动，函数组件不得不改为类组件等等 在以前，函数组件也被称为无状态的组件，只负责渲染的一些工作 因此，现在的函数组件也可以是有状态的组件，内部也可以维护自身的状态以及做一些逻辑方面的处理 二、有哪些上面讲到，Hooks让我们的函数组件拥有了类组件的特性，例如组件内的状态、生命周期 最常见的hooks有如下： useState useEffect 其他 useState首先给出一个例子，如下： 123456789101112131415import React, &#123; useState &#125; from &#x27;react&#x27;;function Example() &#123; // 声明一个叫 &quot;count&quot; 的 state 变量 const [count, setCount] = useState(0); return ( &lt;div&gt; &lt;p&gt;You clicked &#123;count&#125; times&lt;/p &gt; &lt;button onClick=&#123;() =&gt; setCount(count + 1)&#125;&gt; Click me &lt;/button&gt; &lt;/div&gt; );&#125; 在函数组件中通过useState实现函数内部维护state，参数为state默认的值，返回值是一个数组，第一个值为当前的state，第二个值为更新state的函数 该函数组件等价于的类组件如下： 12345678910111213141516171819class Example extends React.Component &#123; constructor(props) &#123; super(props); this.state = &#123; count: 0 &#125;; &#125; render() &#123; return ( &lt;div&gt; &lt;p&gt;You clicked &#123;this.state.count&#125; times&lt;/p &gt; &lt;button onClick=&#123;() =&gt; this.setState(&#123; count: this.state.count + 1 &#125;)&#125;&gt; Click me &lt;/button&gt; &lt;/div&gt; ); &#125;&#125; 从上述两种代码分析，可以看出两者区别： state声明方式：在函数组件中通过 useState 直接获取，类组件通过constructor 构造函数中设置 state读取方式：在函数组件中直接使用变量，类组件通过this.state.count的方式获取 state更新方式：在函数组件中通过 setCount 更新，类组件通过this.setState() 总的来讲，useState 使用起来更为简洁，减少了this指向不明确的情况 useEffectuseEffect可以让我们在函数组件中进行一些带有副作用的操作 同样给出一个计时器示例： 1234567891011121314151617181920212223242526class Example extends React.Component &#123; constructor(props) &#123; super(props); this.state = &#123; count: 0 &#125;; &#125; componentDidMount() &#123; document.title = `You clicked $&#123;this.state.count&#125; times`; &#125; componentDidUpdate() &#123; document.title = `You clicked $&#123;this.state.count&#125; times`; &#125; render() &#123; return ( &lt;div&gt; &lt;p&gt;You clicked &#123;this.state.count&#125; times&lt;/p &gt; &lt;button onClick=&#123;() =&gt; this.setState(&#123; count: this.state.count + 1 &#125;)&#125;&gt; Click me &lt;/button&gt; &lt;/div&gt; ); &#125;&#125; 从上面可以看见，组件在加载和更新阶段都执行同样操作 而如果使用useEffect后，则能够将相同的逻辑抽离出来，这是类组件不具备的方法 对应的useEffect示例如下： 1234567891011121314import React, &#123; useState, useEffect &#125; from &#x27;react&#x27;;function Example() &#123; const [count, setCount] = useState(0); useEffect(() =&gt; &#123; document.title = `You clicked $&#123;count&#125; times`; &#125;); return ( &lt;div&gt; &lt;p&gt;You clicked &#123;count&#125; times&lt;/p &gt; &lt;button onClick=&#123;() =&gt; setCount(count + 1)&#125;&gt; Click me &lt;/button&gt; &lt;/div&gt; );&#125; useEffect第一个参数接受一个回调函数，默认情况下，useEffect会在第一次渲染和更新之后都会执行，相当于在componentDidMount和componentDidUpdate两个生命周期函数中执行回调 如果某些特定值在两次重渲染之间没有发生变化，你可以跳过对 effect 的调用，这时候只需要传入第二个参数，如下： 123useEffect(() =&gt; &#123; document.title = `You clicked $&#123;count&#125; times`;&#125;, [count]); // 仅在 count 更改时更新 上述传入第二个参数后，如果 count 的值是 5，而且我们的组件重渲染的时候 count 还是等于 5，React 将对前一次渲染的 [5] 和后一次渲染的 [5] 进行比较，如果是相等则跳过effects执行 回调函数中可以返回一个清除函数，这是effect可选的清除机制，相当于类组件中componentwillUnmount生命周期函数，可做一些清除副作用的操作，如下： 12345678910useEffect(() =&gt; &#123; function handleStatusChange(status) &#123; setIsOnline(status.isOnline); &#125; ChatAPI.subscribeToFriendStatus(props.friend.id, handleStatusChange); return () =&gt; &#123; ChatAPI.unsubscribeFromFriendStatus(props.friend.id, handleStatusChange); &#125;;&#125;); 所以， useEffect相当于componentDidMount，componentDidUpdate 和 componentWillUnmount 这三个生命周期函数的组合 其它 hooks在组件通信过程中可以使用useContext，refs学习中我们也用到了useRef获取DOM结构…… 还有很多额外的hooks，如： useContext: 获取 context 对象 useReducer: 类似于 Redux 思想的实现，但其并不足以替代 Redux，可以理解成一个组件内部的 redux: 并不是持久化存储，会随着组件被销毁而销毁； 属于组件内部，各个组件是相互隔离的，单纯用它并无法共享数据； 配合useContext的全局性，可以完成一个轻量级的 Redux；(easy-peasy) useCallback: 缓存回调函数，避免传入的回调每次都是新的函数实例而导致依赖组件重新渲染，具有性能优化的效果； useMemo: 用于缓存传入的 props，避免依赖的组件每次都重新渲染； useRef: 获取组件的真实节点； useLayoutEffect DOM更新同步钩子。用法与useEffect类似，只是区别于执行时间点的不同 useEffect属于异步执行，并不会等待 DOM 真正渲染后执行，而useLayoutEffect则会真正渲染后才触发； 可以获取更新后的 state； 注意 避免在 循环&#x2F;条件判断&#x2F;嵌套函数 中调用 hooks，保证调用顺序的稳定； 只有 函数定义组件 和 hooks 可以调用 hooks，避免在 类组件 或者 普通函数 中调用； 不能在useEffect中使用useState，React 会报错提示； 类组件不会被替换或废弃，不需要强制改造类组件，两种方式能并存； 三、解决什么通过对上面的初步认识，可以看到hooks能够更容易解决状态相关的重用的问题： 每调用useHook一次都会生成一份独立的状态 通过自定义hook能够更好的封装我们的功能 编写hooks为函数式编程，每个功能都包裹在函数中，整体风格更清爽，更优雅 hooks的出现，使函数组件的功能得到了扩充，拥有了类组件相似的功能，在我们日常使用中，使用hooks能够解决大多数问题，并且还拥有代码复用机制，因此优先考虑hooks","categories":[{"name":"react","slug":"react","permalink":"http://example.com/categories/react/"}],"tags":[{"name":"react","slug":"react","permalink":"http://example.com/tags/react/"}]},{"title":"react高阶函数","slug":"react高阶函数","date":"2018-10-11T02:03:59.000Z","updated":"2022-06-02T09:18:52.868Z","comments":true,"path":"2018/10/11/react高阶函数/","link":"","permalink":"http://example.com/2018/10/11/react%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0/","excerpt":"","text":"一、是什么高阶函数（Higher-order function），至少满足下列一个条件的函数 接受一个或多个函数作为输入 输出一个函数 在React中，高阶组件即接受一个或多个组件作为参数并且返回一个组件，本质也就是一个函数，并不是一个组件 1const EnhancedComponent = highOrderComponent(WrappedComponent); 上述代码中，该函数接受一个组件WrappedComponent作为参数，返回加工过的新组件EnhancedComponent 高阶组件的这种实现方式，本质上是一个装饰者设计模式 二、如何编写最基本的高阶组件的编写模板如下： 12345678910import React, &#123; Component &#125; from &#x27;react&#x27;;export default (WrappedComponent) =&gt; &#123; return class EnhancedComponent extends Component &#123; // do something render() &#123; return &lt;WrappedComponent /&gt;; &#125; &#125;&#125; 通过对传入的原始组件 WrappedComponent 做一些你想要的操作（比如操作 props，提取 state，给原始组件包裹其他元素等），从而加工出想要的组件 EnhancedComponent 把通用的逻辑放在高阶组件中，对组件实现一致的处理，从而实现代码的复用 所以，高阶组件的主要功能是封装并分离组件的通用逻辑，让通用逻辑在组件间更好地被复用 但在使用高阶组件的同时，一般遵循一些约定，如下： props 保持一致 你不能在函数式（无状态）组件上使用 ref 属性，因为它没有实例 不要以任何方式改变原始组件 WrappedComponent 不要透传不相关 props 属性给被包裹的组件 WrappedComponent 不要再 render() 方法中使用高阶组件 使用 compose 组合高阶组件 包装显示名字以便于调试 这里需要注意的是，高阶组件可以传递所有的props，但是不能传递ref 如果向一个高阶组件添加refs引用，那么ref 指向的是最外层容器组件实例的，而不是被包裹的组件，如果需要传递refs的话，则使用React.forwardRef，如下： 12345678910111213141516171819202122function withLogging(WrappedComponent) &#123; class Enhance extends WrappedComponent &#123; componentWillReceiveProps() &#123; console.log(&#x27;Current props&#x27;, this.props); console.log(&#x27;Next props&#x27;, nextProps); &#125; render() &#123; const &#123;forwardedRef, ...rest&#125; = this.props; // 把 forwardedRef 赋值给 ref return &lt;WrappedComponent &#123;...rest&#125; ref=&#123;forwardedRef&#125; /&gt;; &#125; &#125;; // React.forwardRef 方法会传入 props 和 ref 两个参数给其回调函数 // 所以这边的 ref 是由 React.forwardRef 提供的 function forwardRef(props, ref) &#123; return &lt;Enhance &#123;...props&#125; forwardRef=&#123;ref&#125; /&gt; &#125; return React.forwardRef(forwardRef);&#125;const EnhancedComponent = withLogging(SomeComponent); 三、应用场景通过上面的了解，高阶组件能够提高代码的复用性和灵活性，在实际应用中，常常用于与核心业务无关但又在多个模块使用的功能，如权限控制、日志记录、数据校验、异常处理、统计上报等 举个例子，存在一个组件，需要从缓存中获取数据，然后渲染。一般情况，我们会如下编写： 12345678910111213import React, &#123; Component &#125; from &#x27;react&#x27;class MyComponent extends Component &#123; componentWillMount() &#123; let data = localStorage.getItem(&#x27;data&#x27;); this.setState(&#123;data&#125;); &#125; render() &#123; return &lt;div&gt;&#123;this.state.data&#125;&lt;/div&gt; &#125;&#125; 上述代码当然可以实现该功能，但是如果还有其他组件也有类似功能的时候，每个组件都需要重复写componentWillMount中的代码，这明显是冗杂的 下面就可以通过高价组件来进行改写，如下： 1234567891011121314151617181920212223import React, &#123; Component &#125; from &#x27;react&#x27;function withPersistentData(WrappedComponent) &#123; return class extends Component &#123; componentWillMount() &#123; let data = localStorage.getItem(&#x27;data&#x27;); this.setState(&#123;data&#125;); &#125; render() &#123; // 通过&#123;...this.props&#125; 把传递给当前组件的属性继续传递给被包装的组件WrappedComponent return &lt;WrappedComponent data=&#123;this.state.data&#125; &#123;...this.props&#125; /&gt; &#125; &#125;&#125;class MyComponent2 extends Component &#123; render() &#123; return &lt;div&gt;&#123;this.props.data&#125;&lt;/div&gt; &#125;&#125;const MyComponentWithPersistentData = withPersistentData(MyComponent2) 再比如组件渲染性能监控，如下： 12345678910111213141516171819202122232425262728class Home extends React.Component &#123; render() &#123; return (&lt;h1&gt;Hello World.&lt;/h1&gt;); &#125;&#125;function withTiming(WrappedComponent) &#123; return class extends WrappedComponent &#123; constructor(props) &#123; super(props); this.start = 0; this.end = 0; &#125; componentWillMount() &#123; super.componentWillMount &amp;&amp; super.componentWillMount(); this.start = Date.now(); &#125; componentDidMount() &#123; super.componentDidMount &amp;&amp; super.componentDidMount(); this.end = Date.now(); console.log(`$&#123;WrappedComponent.name&#125; 组件渲染时间为 $&#123;this.end - this.start&#125; ms`); &#125; render() &#123; return super.render(); &#125; &#125;;&#125;export default withTiming(Home);","categories":[{"name":"react","slug":"react","permalink":"http://example.com/categories/react/"}],"tags":[{"name":"react","slug":"react","permalink":"http://example.com/tags/react/"}]},{"title":"react中受控组件和非受控组件","slug":"react中受控组件和非受控组件","date":"2018-10-03T13:03:59.000Z","updated":"2022-06-02T08:50:15.473Z","comments":true,"path":"2018/10/03/react中受控组件和非受控组件/","link":"","permalink":"http://example.com/2018/10/03/react%E4%B8%AD%E5%8F%97%E6%8E%A7%E7%BB%84%E4%BB%B6%E5%92%8C%E9%9D%9E%E5%8F%97%E6%8E%A7%E7%BB%84%E4%BB%B6/","excerpt":"","text":"一、受控组件受控组件，简单来讲，就是受我们控制的组件，组件的状态全程响应外部数据 举个简单的例子： 123456789class TestComponent extends React.Component &#123; constructor (props) &#123; super(props); this.state = &#123; username: &#x27;lindaidai&#x27; &#125;; &#125; render () &#123; return &lt;input name=&quot;username&quot; value=&#123;this.state.username&#125; /&gt; &#125;&#125; 这时候当我们在输入框输入内容的时候，会发现输入的内容并无法显示出来，也就是input标签是一个可读的状态 这是因为value被this.state.username所控制住。当用户输入新的内容时，this.state.username并不会自动更新，这样的话input内的内容也就不会变了 如果想要解除被控制，可以为input标签设置onChange事件，输入的时候触发事件函数，在函数内部实现state的更新，从而导致input框的内容页发现改变 因此，受控组件我们一般需要初始状态和一个状态更新事件函数 二、非受控组件非受控组件，简单来讲，就是不受我们控制的组件 一般情况是在初始化的时候接受外部数据，然后自己在内部存储其自身状态 当需要时，可以使用ref 查询 DOM并查找其当前值，如下： 1234567891011121314151617181920import React, &#123; Component &#125; from &#x27;react&#x27;;export class UnControll extends Component &#123; constructor (props) &#123; super(props); this.inputRef = React.createRef(); &#125; handleSubmit = (e) =&gt; &#123; console.log(&#x27;我们可以获得input内的值为&#x27;, this.inputRef.current.value); e.preventDefault(); &#125; render () &#123; return ( &lt;form onSubmit=&#123;e =&gt; this.handleSubmit(e)&#125;&gt; &lt;input defaultValue=&quot;lindaidai&quot; ref=&#123;this.inputRef&#125; /&gt; &lt;input type=&quot;submit&quot; value=&quot;提交&quot; /&gt; &lt;/form&gt; ) &#125;&#125; 三、应用场景大部分时候推荐使用受控组件来实现表单，因为在受控组件中，表单数据由React组件负责处理 如果选择非受控组件的话，控制能力较弱，表单数据就由DOM本身处理，但更加方便快捷，代码量少 针对两者的区别，其应用场景如下图所示：","categories":[{"name":"react","slug":"react","permalink":"http://example.com/categories/react/"}],"tags":[{"name":"react","slug":"react","permalink":"http://example.com/tags/react/"}]},{"title":"react中类组件和函数组件","slug":"react中类组件和函数组件","date":"2018-10-03T08:52:59.000Z","updated":"2022-06-02T08:46:06.771Z","comments":true,"path":"2018/10/03/react中类组件和函数组件/","link":"","permalink":"http://example.com/2018/10/03/react%E4%B8%AD%E7%B1%BB%E7%BB%84%E4%BB%B6%E5%92%8C%E5%87%BD%E6%95%B0%E7%BB%84%E4%BB%B6/","excerpt":"","text":"一、类组件类组件，顾名思义，也就是通过使用ES6类的编写形式去编写组件，该类必须继承React.Component 如果想要访问父组件传递过来的参数，可通过this.props的方式去访问 在组件中必须实现render方法，在return中返回React对象，如下： 12345678class Welcome extends React.Component &#123; constructor(props) &#123; super(props) &#125; render() &#123; return &lt;h1&gt;Hello, &#123;this.props.name&#125;&lt;/h1&gt; &#125;&#125; 二、函数组件函数组件，顾名思义，就是通过函数编写的形式去实现一个React组件，是React中定义组件最简单的方式 123function Welcome(props) &#123; return &lt;h1&gt;Hello, &#123;props.name&#125;&lt;/h1&gt;;&#125; 函数第一个参数为props用于接收父组件传递过来的参数 三、区别针对两种React组件，其区别主要分成以下几大方向： 编写形式 状态管理 生命周期 调用方式 获取渲染的值 编写形式两者最明显的区别在于编写形式的不同，同一种功能的实现可以分别对应类组件和函数组件的编写形式 函数组件： 123function Welcome(props) &#123; return &lt;h1&gt;Hello, &#123;props.name&#125;&lt;/h1&gt;;&#125; 类组件： 12345678class Welcome extends React.Component &#123; constructor(props) &#123; super(props) &#125; render() &#123; return &lt;h1&gt;Hello, &#123;this.props.name&#125;&lt;/h1&gt; &#125;&#125; 状态管理在hooks出来之前，函数组件就是无状态组件，不能保管组件的状态，不像类组件中调用setState 如果想要管理state状态，可以使用useState，如下： 12345678910const FunctionalComponent = () =&gt; &#123; const [count, setCount] = React.useState(0); return ( &lt;div&gt; &lt;p&gt;count: &#123;count&#125;&lt;/p &gt; &lt;button onClick=&#123;() =&gt; setCount(count + 1)&#125;&gt;Click&lt;/button&gt; &lt;/div&gt; );&#125;; 在使用hooks情况下，一般如果函数组件调用state，则需要创建一个类组件或者state提升到你的父组件中，然后通过props对象传递到子组件 生命周期在函数组件中，并不存在生命周期，这是因为这些生命周期钩子都来自于继承的React.Component 所以，如果用到生命周期，就只能使用类组件 但是函数组件使用useEffect也能够完成替代生命周期的作用，这里给出一个简单的例子： 123456const FunctionalComponent = () =&gt; &#123; useEffect(() =&gt; &#123; console.log(&quot;Hello&quot;); &#125;, []); return &lt;h1&gt;Hello, World&lt;/h1&gt;;&#125;; 上述简单的例子对应类组件中的componentDidMount生命周期 如果在useEffect回调函数中return一个函数，则return函数会在组件卸载的时候执行，正如componentWillUnmount 12345678const FunctionalComponent = () =&gt; &#123; React.useEffect(() =&gt; &#123; return () =&gt; &#123; console.log(&quot;Bye&quot;); &#125;; &#125;, []); return &lt;h1&gt;Bye, World&lt;/h1&gt;;&#125;; 调用方式如果是一个函数组件，调用则是执行函数即可： 123456// 你的代码 function SayHi() &#123; return &lt;p&gt;Hello, React&lt;/p &gt; &#125; // React内部 const result = SayHi(props) // » &lt;p&gt;Hello, React&lt;/p &gt; 如果是一个类组件，则需要将组件进行实例化，然后调用实例对象的render方法： 123456789// 你的代码 class SayHi extends React.Component &#123; render() &#123; return &lt;p&gt;Hello, React&lt;/p &gt; &#125; &#125; // React内部 const instance = new SayHi(props) // » SayHi &#123;&#125; const result = instance.render() // » &lt;p&gt;Hello, React&lt;/p &gt; 获取渲染的值首先给出一个示例 函数组件对应如下： 12345678910111213function ProfilePage(props) &#123; const showMessage = () =&gt; &#123; alert(&#x27;Followed &#x27; + props.user); &#125; const handleClick = () =&gt; &#123; setTimeout(showMessage, 3000); &#125; return ( &lt;button onClick=&#123;handleClick&#125;&gt;Follow&lt;/button&gt; )&#125; 类组件对应如下： 12345678910111213class ProfilePage extends React.Component &#123; showMessage() &#123; alert(&#x27;Followed &#x27; + this.props.user); &#125; handleClick() &#123; setTimeout(this.showMessage.bind(this), 3000); &#125; render() &#123; return &lt;button onClick=&#123;this.handleClick.bind(this)&#125;&gt;Follow&lt;/button&gt; &#125;&#125; 两者看起来实现功能是一致的，但是在类组件中，输出this.props.user，Props在 React中是不可变的所以它永远不会改变，但是 this 总是可变的，以便您可以在 render 和生命周期函数中读取新版本。 因此，如果我们的组件在请求运行时更新。this.props 将会改变。showMessage方法从“最新”的 props 中读取 user。 而函数组件，本身就不存在this，props并不发生改变，因此同样是点击，alert的内容仍旧是之前的内容。 小结两种组件都有各自的优缺点 函数组件语法更短、更简单，这使得它更容易开发、理解和测试 而类组件也会因大量使用 this而让人感到困惑","categories":[{"name":"react","slug":"react","permalink":"http://example.com/categories/react/"}],"tags":[{"name":"react","slug":"react","permalink":"http://example.com/tags/react/"}]},{"title":"react中key的作用","slug":"react中key的作用","date":"2018-10-03T03:52:59.000Z","updated":"2022-06-02T08:33:47.949Z","comments":true,"path":"2018/10/03/react中key的作用/","link":"","permalink":"http://example.com/2018/10/03/react%E4%B8%ADkey%E7%9A%84%E4%BD%9C%E7%94%A8/","excerpt":"","text":"一、是什么首先，先给出react组件中进行列表渲染的一个示例： 1234567891011121314151617181920const data = [ &#123; id: 0, name: &#x27;abc&#x27; &#125;, &#123; id: 1, name: &#x27;def&#x27; &#125;, &#123; id: 2, name: &#x27;ghi&#x27; &#125;, &#123; id: 3, name: &#x27;jkl&#x27; &#125;];const ListItem = (props) =&gt; &#123; return &lt;li&gt;&#123;props.name&#125;&lt;/li&gt;;&#125;;const List = () =&gt; &#123; return ( &lt;ul&gt; &#123;data.map((item) =&gt; ( &lt;ListItem name=&#123;item.name&#125;&gt;&lt;/ListItem&gt; ))&#125; &lt;/ul&gt; );&#125;; 然后在输出就可以看到react所提示的警告信息： 1Each child in a list should have a unique &quot;key&quot; prop. 根据意思就可以得到渲染列表的每一个子元素都应该需要一个唯一的key值 在这里可以使用列表的id属性作为key值以解决上面这个警告 123456789const List = () =&gt; &#123; return ( &lt;ul&gt; &#123;data.map((item) =&gt; ( &lt;ListItem name=&#123;item.name&#125; key=&#123;item.id&#125;&gt;&lt;/ListItem&gt; ))&#125; &lt;/ul&gt; );&#125;; 二、作用跟Vue一样，React 也存在 Diff算法，而元素key属性的作用是用于判断元素是新创建的还是被移动的元素，从而减少不必要的元素渲染 因此key的值需要为每一个元素赋予一个确定的标识 如果列表数据渲染中，在数据后面插入一条数据，key作用并不大，如下： 123456789101112131415161718this.state = &#123; numbers:[111,222,333]&#125;insertMovie() &#123; const newMovies = [...this.state.numbers, 444]; this.setState(&#123; movies: newMovies &#125;)&#125;&lt;ul&gt; &#123; this.state.movies.map((item, index) =&gt; &#123; return &lt;li&gt;&#123;item&#125;&lt;/li&gt; &#125;) &#125;&lt;/ul&gt; 前面的元素在diff算法中，前面的元素由于是完全相同的，并不会产生删除创建操作，在最后一个比较的时候，则需要插入到新的DOM树中 因此，在这种情况下，元素有无key属性意义并不大 下面再来看看在前面插入数据时，使用key与不使用key的区别： 123456insertMovie() &#123; const newMovies = [000 ,...this.state.numbers]; this.setState(&#123; movies: newMovies &#125;)&#125; 当拥有key的时候，react根据key属性匹配原有树上的子元素以及最新树上的子元素，像上述情况只需要将000元素插入到最前面位置 当没有key的时候，所有的li标签都需要进行修改 同样，并不是拥有key值代表性能越高，如果说只是文本内容改变了，不写key反而性能和效率更高 主要是因为不写key是将所有的文本内容替换一下，节点不会发生变化 而写key则涉及到了节点的增和删，发现旧key不存在了，则将其删除，新key在之前没有，则插入，这就增加性能的开销 三、总结良好使用key属性是性能优化的非常关键的一步，注意事项为： key 应该是唯一的 key不要使用随机值（随机数在下一次 render 时，会重新生成一个数字） 使用 index 作为 key值，对性能没有优化 react判断key的流程具体如下图：","categories":[{"name":"react","slug":"react","permalink":"http://example.com/categories/react/"}],"tags":[{"name":"react","slug":"react","permalink":"http://example.com/tags/react/"}]},{"title":"react通信方式","slug":"react通信方式","date":"2018-10-03T01:52:59.000Z","updated":"2022-06-02T08:31:07.343Z","comments":true,"path":"2018/10/03/react通信方式/","link":"","permalink":"http://example.com/2018/10/03/react%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F/","excerpt":"","text":"一、是什么我们将组件间通信可以拆分为两个词： 组件 通信 组件是vue中最强大的功能之一，同样组件化是React的核心思想 相比vue，React的组件更加灵活和多样，按照不同的方式可以分成很多类型的组件 而通信指的是发送者通过某种媒体以某种格式来传递信息到收信者以达到某个目的，广义上，任何信息的交通都是通信 组件间通信即指组件通过某种方式来传递信息以达到某个目的 二、如何通信组件传递的方式有很多种，根据传送者和接收者可以分为如下： 父组件向子组件传递 子组件向父组件传递 兄弟组件之间的通信 父组件向后代组件传递 非关系组件传递 父组件向子组件传递由于React的数据流动为单向的，父组件向子组件传递是最常见的方式 父组件在调用子组件的时候，只需要在子组件标签内传递参数，子组件通过props属性就能接收父组件传递过来的参数 123456789function EmailInput(props) &#123; return ( &lt;label&gt; Email: &lt;input value=&#123;props.email&#125; /&gt; &lt;/label&gt; );&#125;const element = &lt;EmailInput email=&quot;123124132@163.com&quot; /&gt;; 子组件向父组件传递子组件向父组件通信的基本思路是，父组件向子组件传一个函数，然后通过这个函数的回调，拿到子组件传过来的值 父组件对应代码如下： 123456789101112131415161718192021222324class Parents extends Component &#123; constructor() &#123; super(); this.state = &#123; price: 0 &#125;; &#125; getItemPrice(e) &#123; this.setState(&#123; price: e &#125;); &#125; render() &#123; return ( &lt;div&gt; &lt;div&gt;price: &#123;this.state.price&#125;&lt;/div&gt; &#123;/* 向子组件中传入一个函数 */&#125; &lt;Child getPrice=&#123;this.getItemPrice.bind(this)&#125; /&gt; &lt;/div&gt; ); &#125;&#125; 子组件对应代码如下： 123456789101112131415class Child extends Component &#123; clickGoods(e) &#123; // 在此函数中传入值 this.props.getPrice(e); &#125; render() &#123; return ( &lt;div&gt; &lt;button onClick=&#123;this.clickGoods.bind(this, 100)&#125;&gt;goods1&lt;/button&gt; &lt;button onClick=&#123;this.clickGoods.bind(this, 1000)&#125;&gt;goods2&lt;/button&gt; &lt;/div&gt; ); &#125;&#125; 兄弟组件之间的通信如果是兄弟组件之间的传递，则父组件作为中间层来实现数据的互通，通过使用父组件传递 123456789101112131415161718192021class Parent extends React.Component &#123; constructor(props) &#123; super(props) this.state = &#123;count: 0&#125; &#125; setCount = () =&gt; &#123; this.setState(&#123;count: this.state.count + 1&#125;) &#125; render() &#123; return ( &lt;div&gt; &lt;SiblingA count=&#123;this.state.count&#125; /&gt; &lt;SiblingB onClick=&#123;this.setCount&#125; /&gt; &lt;/div&gt; ); &#125;&#125; 父组件向后代组件传递父组件向后代组件传递数据是一件最普通的事情，就像全局数据一样 使用context提供了组件之间通讯的一种方式，可以共享数据，其他数据都能读取对应的数据 通过使用React.createContext创建一个context 1const PriceContext = React.createContext(&#x27;price&#x27;) context创建成功后，其下存在Provider组件用于创建数据源，Consumer组件用于接收数据，使用实例如下： Provider组件通过value属性用于给后代组件传递数据： 12&lt;PriceContext.Provider value=&#123;100&#125;&gt;&lt;/PriceContext.Provider&gt; 如果想要获取Provider传递的数据，可以通过Consumer组件或者或者使用contextType属性接收，对应分别如下： 1234567class MyClass extends React.Component &#123; static contextType = PriceContext; render() &#123; let price = this.context; /* 基于这个值进行渲染工作 */ &#125;&#125; Consumer组件： 123456&lt;PriceContext.Consumer&gt; &#123; /*这里是一个函数*/ &#125; &#123; price =&gt; &lt;div&gt;price：&#123;price&#125;&lt;/div&gt; &#125;&lt;/PriceContext.Consumer&gt; 非关系组件传递如果组件之间关系类型比较复杂的情况，建议将数据进行一个全局资源管理，从而实现通信，例如redux。 三、总结由于React是单向数据流，主要思想是组件不会改变接收的数据，只会监听数据的变化，当数据发生变化时它们会使用接收到的新值，而不是去修改已有的值。 因此，可以看到通信过程中，数据的存储位置都是存放在上级位置中。","categories":[{"name":"react","slug":"react","permalink":"http://example.com/categories/react/"}],"tags":[{"name":"react","slug":"react","permalink":"http://example.com/tags/react/"}]},{"title":"react中setState的机制","slug":"react中setState的机制","date":"2018-10-02T07:52:59.000Z","updated":"2022-06-02T08:17:20.305Z","comments":true,"path":"2018/10/02/react中setState的机制/","link":"","permalink":"http://example.com/2018/10/02/react%E4%B8%ADsetState%E7%9A%84%E6%9C%BA%E5%88%B6/","excerpt":"","text":"一、是什么一个组件的显示形态可以由数据状态和外部参数所决定，而数据状态就是state 当需要修改里面的值的状态需要通过调用setState来改变，从而达到更新组件内部数据的作用 如下例子： 1234567891011121314151617181920212223242526import React, &#123; Component &#125; from &#x27;react&#x27;export default class App extends Component &#123; constructor(props) &#123; super(props); this.state = &#123; message: &quot;Hello World&quot; &#125; &#125; render() &#123; return ( &lt;div&gt; &lt;h2&gt;&#123;this.state.message&#125;&lt;/h2&gt; &lt;button onClick=&#123;e =&gt; this.changeText()&#125;&gt;面试官系列&lt;/button&gt; &lt;/div&gt; ) &#125; changeText() &#123; this.setState(&#123; message: &quot;JS每日一题&quot; &#125;) &#125;&#125; 通过点击按钮触发onclick事件，执行this.setState方法更新state状态，然后重新执行render函数，从而导致页面的视图更新 如果直接修改state的状态，如下： 123changeText() &#123; this.state.message = &quot;你好啊,xxx&quot;;&#125; 我们会发现页面并不会有任何反应，但是state的状态是已经发生了改变 这是因为React并不像vue2中调用Object.defineProperty数据响应式或者Vue3调用Proxy监听数据的变化 必须通过setState方法来告知react组件state已经发生了改变 关于state方法的定义是从React.Component中继承，定义的源码如下： 12345678910Component.prototype.setState = function(partialState, callback) &#123; invariant( typeof partialState === &#x27;object&#x27; || typeof partialState === &#x27;function&#x27; || partialState == null, &#x27;setState(...): takes an object of state variables to update or a &#x27; + &#x27;function which returns an object of state variables.&#x27;, ); this.updater.enqueueSetState(this, partialState, callback, &#x27;setState&#x27;);&#125;; 从上面可以看到setState第一个参数可以是一个对象，或者是一个函数，而第二个参数是一个回调函数，用于可以实时的获取到更新之后的数据 二、更新类型在使用setState更新数据的时候，setState的更新类型分成： 异步更新 同步更新 异步更新先举出一个例子： 123456changeText() &#123; this.setState(&#123; message: &quot;你好啊&quot; &#125;) console.log(this.state.message); // Hello World&#125; 从上面可以看到，最终打印结果为Hello world，并不能在执行完setState之后立马拿到最新的state的结果 如果想要立刻获取更新后的值，在第二个参数的回调中更新后会执行 1234567changeText() &#123; this.setState(&#123; message: &quot;你好啊&quot; &#125;, () =&gt; &#123; console.log(this.state.message); // 你好啊 &#125;);&#125; 同步更新同样先给出一个在setTimeout中更新的例子： 12345678changeText() &#123; setTimeout(() =&gt; &#123; this.setState(&#123; message: &quot;你好啊 &#125;); console.log(this.state.message); // 你好啊 &#125;, 0);&#125; 上面的例子中，可以看到更新是同步 再来举一个原生DOM事件的例子： 123456789componentDidMount() &#123; const btnEl = document.getElementById(&quot;btn&quot;); btnEl.addEventListener(&#x27;click&#x27;, () =&gt; &#123; this.setState(&#123; message: &quot;你好啊,xxx&quot; &#125;); console.log(this.state.message); // 你好啊,xxx &#125;)&#125; 小结 在组件生命周期或React合成事件中，setState是异步 在setTimeout或者原生dom事件中，setState是同步 三、批量更新同样先给出一个例子： 12345678910111213141516handleClick = () =&gt; &#123; this.setState(&#123; count: this.state.count + 1, &#125;) console.log(this.state.count) // 1 this.setState(&#123; count: this.state.count + 1, &#125;) console.log(this.state.count) // 1 this.setState(&#123; count: this.state.count + 1, &#125;) console.log(this.state.count) // 1&#125; 点击按钮触发事件，打印的都是 1，页面显示 count 的值为 2 对同一个值进行多次 setState， setState 的批量更新策略会对其进行覆盖，取最后一次的执行结果 上述的例子，实际等价于如下： 123456Object.assign( previousState, &#123;index: state.count+ 1&#125;, &#123;index: state.count+ 1&#125;, ...) 由于后面的数据会覆盖前面的更改，所以最终只加了一次 如果是下一个state依赖前一个state的话，推荐给setState一个参数传入一个function，如下： 12345678onClick = () =&gt; &#123; this.setState((prevState, props) =&gt; &#123; return &#123;count: prevState.count + 1&#125;; &#125;); this.setState((prevState, props) =&gt; &#123; return &#123;count: prevState.count + 1&#125;; &#125;);&#125; 而在setTimeout或者原生dom事件中，由于是同步的操作，所以并不会进行覆盖现象","categories":[{"name":"react","slug":"react","permalink":"http://example.com/categories/react/"}],"tags":[{"name":"react","slug":"react","permalink":"http://example.com/tags/react/"}]},{"title":"react生命周期","slug":"react生命周期","date":"2018-10-02T02:52:59.000Z","updated":"2022-06-02T03:04:17.825Z","comments":true,"path":"2018/10/02/react生命周期/","link":"","permalink":"http://example.com/2018/10/02/react%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/","excerpt":"","text":"一、是什么生命周期（Life Cycle）的概念应用很广泛，特别是在经济、环境、技术、社会等诸多领域经常出现，其基本涵义可以通俗地理解为“从摇篮到坟墓”（Cradle-to-Grave）的整个过程 跟Vue一样，React整个组件生命周期包括从创建、初始化数据、编译模板、挂载Dom→渲染、更新→渲染、卸载等一系列过程 二、流程这里主要讲述react16.4之后的生命周期，可以分成三个阶段： 创建阶段 更新阶段 卸载阶段 创建阶段创建阶段主要分成了以下几个生命周期方法： constructor getDerivedStateFromProps render componentDidMount constructor实例过程中自动调用的方法，在方法内部通过super关键字获取来自父组件的props 在该方法中，通常的操作为初始化state状态或者在this上挂载方法 getDerivedStateFromProps该方法是新增的生命周期方法，是一个静态的方法，因此不能访问到组件的实例 执行时机：组件创建和更新阶段，不论是props变化还是state变化，也会调用 在每次render方法前调用，第一个参数为即将更新的props，第二个参数为上一个状态的state，可以比较props 和 state来加一些限制条件，防止无用的state更新 该方法需要返回一个新的对象作为新的state或者返回null表示state状态不需要更新 render类组件必须实现的方法，用于渲染DOM结构，可以访问组件state与prop属性 注意： 不要在 render 里面 setState, 否则会触发死循环导致内存崩溃 componentDidMount组件挂载到真实DOM节点后执行，其在render方法之后执行 此方法多用于执行一些数据获取，事件监听等操作 更新阶段该阶段的函数主要为如下方法： getDerivedStateFromProps shouldComponentUpdate render getSnapshotBeforeUpdate componentDidUpdate getDerivedStateFromProps该方法介绍同上 shouldComponentUpdate用于告知组件本身基于当前的props和state是否需要重新渲染组件，默认情况返回true 执行时机：到新的props或者state时都会调用，通过返回true或者false告知组件更新与否 一般情况，不建议在该周期方法中进行深层比较，会影响效率 同时也不能调用setState，否则会导致无限循环调用更新 render介绍如上 getSnapshotBeforeUpdate该周期函数在render后执行，执行之时DOM元素还没有被更新 该方法返回的一个Snapshot值，作为componentDidUpdate第三个参数传入 12345678getSnapshotBeforeUpdate(prevProps, prevState) &#123; console.log(&#x27;#enter getSnapshotBeforeUpdate&#x27;); return &#x27;foo&#x27;;&#125;componentDidUpdate(prevProps, prevState, snapshot) &#123; console.log(&#x27;#enter componentDidUpdate snapshot = &#x27;, snapshot);&#125; 此方法的目的在于获取组件更新前的一些信息，比如组件的滚动位置之类的，在组件更新后可以根据这些信息恢复一些UI视觉上的状态 componentDidUpdate执行时机：组件更新结束后触发 在该方法中，可以根据前后的props和state的变化做相应的操作，如获取数据，修改DOM样式等 卸载阶段componentWillUnmount此方法用于组件卸载前，清理一些注册是监听事件，或者取消订阅的网络请求等 一旦一个组件实例被卸载，其不会被再次挂载，而只可能是被重新创建 三、总结新版生命周期整体流程如下图所示： 旧的生命周期流程图如下： 通过两个图的对比，可以发现新版的生命周期减少了以下三种方法： componentWillMount componentWillReceiveProps componentWillUpdate 其实这三个方法仍然存在，只是在前者加上了UNSAFE_前缀，如UNSAFE_componentWillMount，并不像字面意思那样表示不安全，而是表示这些生命周期的代码可能在未来的 react版本可能废除 同时也新增了两个生命周期函数： getDerivedStateFromProps getSnapshotBeforeUpdate","categories":[{"name":"react","slug":"react","permalink":"http://example.com/categories/react/"}],"tags":[{"name":"react","slug":"react","permalink":"http://example.com/tags/react/"}]},{"title":"初识react","slug":"初识react","date":"2018-10-02T02:17:01.000Z","updated":"2022-06-02T02:52:21.818Z","comments":true,"path":"2018/10/02/初识react/","link":"","permalink":"http://example.com/2018/10/02/%E5%88%9D%E8%AF%86react/","excerpt":"","text":"一、是什么React，用于构建用户界面的 JavaScript 库，只提供了 UI 层面的解决方案 遵循组件设计模式、声明式编程范式和函数式编程概念，以使前端应用程序更高效 使用虚拟 DOM 来有效地操作 DOM，遵循从高阶组件到低阶组件的单向数据流 帮助我们将界面成了各个独立的小块，每一个块就是组件，这些组件之间可以组合、嵌套，构成整体页面 react 类组件使用一个名为 render() 的方法或者函数组件return，接收输入的数据并返回需要展示的内容 12345678910class HelloMessage extends React.Component &#123; render() &#123; return &lt;div&gt;Hello &#123;this.props.name&#125;&lt;/div&gt;; &#125;&#125;ReactDOM.render( &lt;HelloMessage name=&quot;Taylor&quot; /&gt;, document.getElementById(&quot;hello-example&quot;)); 上述这种类似 XML 形式就是 JSX，最终会被 babel 编译为合法的 JS 语句调用 被传入的数据可在组件中通过 this.props 在 render() 访问 二、特性React 特性有很多，如： JSX 语法 单向数据绑定 虚拟 DOM 声明式编程 Component 着重介绍下声明式编程及 Component 声明式编程声明式编程是一种编程范式，它关注的是你要做什么，而不是如何做 它表达逻辑而不显式地定义步骤。这意味着我们需要根据逻辑的计算来声明要显示的组件 如实现一个标记的地图： 通过命令式创建地图、创建标记、以及在地图上添加的标记的步骤如下： 1234567891011121314// 创建地图const map = new Map.map(document.getElementById(&quot;map&quot;), &#123; zoom: 4, center: &#123; lat, lng &#125;,&#125;);// 创建标记const marker = new Map.marker(&#123; position: &#123; lat, lng &#125;, title: &quot;Hello Marker&quot;,&#125;);// 地图上添加标记marker.setMap(map); 而用 React 实现上述功能则如下： 123&lt;Map zoom=&#123;4&#125; center=&#123;(lat, lng)&#125;&gt; &lt;Marker position=&#123;(lat, lng)&#125; title=&#123;&quot;Hello Marker&quot;&#125; /&gt;&lt;/Map&gt; 声明式编程方式使得 React 组件很容易使用，最终的代码简单易于维护 Component在 React 中，一切皆为组件。通常将应用程序的整个逻辑分解为小的单个部分。 我们将每个单独的部分称为组件 组件可以是一个函数或者是一个类，接受数据输入，处理它并返回在 UI 中呈现的 React 元素 函数式组件如下： 1234567const Header = () =&gt; &#123; return ( &lt;Jumbotron style=&#123;&#123; backgroundColor: &quot;orange&quot; &#125;&#125;&gt; &lt;h1&gt;TODO App&lt;/h1&gt; &lt;/Jumbotron&gt; );&#125;; 类组件（有状态组件）如下： 123456789101112131415class Dashboard extends React.Component &#123; constructor(props) &#123; super(props); this.state = &#123;&#125;; &#125; render() &#123; return ( &lt;div className=&quot;dashboard&quot;&gt; &lt;ToDoForm /&gt; &lt;ToDolist /&gt; &lt;/div&gt; ); &#125;&#125; 一个组件该有的特点如下： 可组合：每个组件易于和其它组件一起使用，或者嵌套在另一个组件内部 可重用：每个组件都是具有独立功能的，它可以被使用在多个 UI 场景 可维护：每个小的组件仅仅包含自身的逻辑，更容易被理解和维护 三、优势通过上面的初步了解，可以感受到 React 存在的优势： 高效灵活 声明式的设计，简单使用 组件式开发，提高代码复用率 单向响应的数据流会比双向绑定的更安全，速度更快","categories":[{"name":"react","slug":"react","permalink":"http://example.com/categories/react/"}],"tags":[{"name":"react","slug":"react","permalink":"http://example.com/tags/react/"}]},{"title":"ES6中Generator","slug":"ES6中Generator","date":"2018-07-25T01:36:14.000Z","updated":"2022-06-06T09:24:53.515Z","comments":true,"path":"2018/07/25/ES6中Generator/","link":"","permalink":"http://example.com/2018/07/25/ES6%E4%B8%ADGenerator/","excerpt":"","text":"一、介绍Generator 函数是 ES6 提供的一种异步编程解决方案，语法行为与传统函数完全不同 回顾下上文提到的解决异步的手段： 回调函数 promise 那么，上文我们提到promsie已经是一种比较流行的解决异步方案，那么为什么还出现Generator？甚至async/await呢？ 该问题我们留在后面再进行分析，下面先认识下Generator Generator函数执行 Generator 函数会返回一个遍历器对象，可以依次遍历 Generator 函数内部的每一个状态 形式上，Generator函数是一个普通函数，但是有两个特征： function关键字与函数名之间有一个星号 函数体内部使用yield表达式，定义不同的内部状态 12345function* helloWorldGenerator() &#123; yield &#x27;hello&#x27;; yield &#x27;world&#x27;; return &#x27;ending&#x27;;&#125; 二、使用Generator 函数会返回一个遍历器对象，即具有Symbol.iterator属性，并且返回给自己 12345678function* gen()&#123; // some code&#125;var g = gen();g[Symbol.iterator]() === g// true 通过yield关键字可以暂停generator函数返回的遍历器对象的状态 123456function* helloWorldGenerator() &#123; yield &#x27;hello&#x27;; yield &#x27;world&#x27;; return &#x27;ending&#x27;;&#125;var hw = helloWorldGenerator(); 上述存在三个状态：hello、world、return 通过next方法才会遍历到下一个内部状态，其运行逻辑如下： 遇到yield表达式，就暂停执行后面的操作，并将紧跟在yield后面的那个表达式的值，作为返回的对象的value属性值。 下一次调用next方法时，再继续往下执行，直到遇到下一个yield表达式 如果没有再遇到新的yield表达式，就一直运行到函数结束，直到return语句为止，并将return语句后面的表达式的值，作为返回的对象的value属性值。 如果该函数没有return语句，则返回的对象的value属性值为undefined 1234567891011hw.next()// &#123; value: &#x27;hello&#x27;, done: false &#125;hw.next()// &#123; value: &#x27;world&#x27;, done: false &#125;hw.next()// &#123; value: &#x27;ending&#x27;, done: true &#125;hw.next()// &#123; value: undefined, done: true &#125; done用来判断是否存在下个状态，value对应状态值 1yield`表达式本身没有返回值，或者说总是返回`undefined 通过调用next方法可以带一个参数，该参数就会被当作上一个yield表达式的返回值 123456789101112131415function* foo(x) &#123; var y = 2 * (yield (x + 1)); var z = yield (y / 3); return (x + y + z);&#125;var a = foo(5);a.next() // Object&#123;value:6, done:false&#125;a.next() // Object&#123;value:NaN, done:false&#125;a.next() // Object&#123;value:NaN, done:true&#125;var b = foo(5);b.next() // &#123; value:6, done:false &#125;b.next(12) // &#123; value:8, done:false &#125;b.next(13) // &#123; value:42, done:true &#125; 正因为Generator函数返回Iterator对象，因此我们还可以通过for...of进行遍历 12345678910111213function* foo() &#123; yield 1; yield 2; yield 3; yield 4; yield 5; return 6;&#125;for (let v of foo()) &#123; console.log(v);&#125;// 1 2 3 4 5 原生对象没有遍历接口，通过Generator函数为它加上这个接口，就能使用for...of进行遍历了 123456789101112131415function* objectEntries(obj) &#123; let propKeys = Reflect.ownKeys(obj); for (let propKey of propKeys) &#123; yield [propKey, obj[propKey]]; &#125;&#125;let jane = &#123; first: &#x27;Jane&#x27;, last: &#x27;Doe&#x27; &#125;;for (let [key, value] of objectEntries(jane)) &#123; console.log(`$&#123;key&#125;: $&#123;value&#125;`);&#125;// first: Jane// last: Doe 三、异步解决方案回顾之前展开异步解决的方案： 回调函数 Promise 对象 generator 函数 async&#x2F;await 这里通过文件读取案例，将几种解决异步的方案进行一个比较： 回调函数所谓回调函数，就是把任务的第二段单独写在一个函数里面，等到重新执行这个任务的时候，再调用这个函数 12345678fs.readFile(&#x27;/etc/fstab&#x27;, function (err, data) &#123; if (err) throw err; console.log(data); fs.readFile(&#x27;/etc/shells&#x27;, function (err, data) &#123; if (err) throw err; console.log(data); &#125;);&#125;); readFile函数的第三个参数，就是回调函数，等到操作系统返回了/etc/passwd这个文件以后，回调函数才会执行 PromisePromise就是为了解决回调地狱而产生的，将回调函数的嵌套，改成链式调用 123456789101112131415161718const fs = require(&#x27;fs&#x27;);const readFile = function (fileName) &#123; return new Promise(function (resolve, reject) &#123; fs.readFile(fileName, function(error, data) &#123; if (error) return reject(error); resolve(data); &#125;); &#125;);&#125;;readFile(&#x27;/etc/fstab&#x27;).then(data =&gt;&#123; console.log(data) return readFile(&#x27;/etc/shells&#x27;)&#125;).then(data =&gt; &#123; console.log(data)&#125;) 这种链式操作形式，使异步任务的两段执行更清楚了，但是也存在了很明显的问题，代码变得冗杂了，语义化并不强 generatoryield表达式可以暂停函数执行，next方法用于恢复函数执行，这使得Generator函数非常适合将异步任务同步化 123456const gen = function* () &#123; const f1 = yield readFile(&#x27;/etc/fstab&#x27;); const f2 = yield readFile(&#x27;/etc/shells&#x27;); console.log(f1.toString()); console.log(f2.toString());&#125;; async&#x2F;await将上面Generator函数改成async/await形式，更为简洁，语义化更强了，async 是 Generator 的语法糖 123456const asyncReadFile = async function () &#123; const f1 = await readFile(&#x27;/etc/fstab&#x27;); const f2 = await readFile(&#x27;/etc/shells&#x27;); console.log(f1.toString()); console.log(f2.toString());&#125;; 区别通过上述代码进行分析，将promise、Generator、async/await进行比较： promise和async/await是专门用于处理异步操作的 Generator并不是为异步而设计出来的，它还有其他功能（对象迭代、控制输出、部署Interator接口…） promise编写代码相比Generator、async更为复杂化，且可读性也稍差 Generator、async需要与promise对象搭配处理异步情况 async实质是Generator的语法糖，相当于会自动执行Generator函数 async使用上更为简洁，将异步代码以同步的形式进行编写，是处理异步编程的最终方案 四、使用场景Generator是异步解决的一种方案，最大特点则是将异步操作同步化表达出来 1234567891011function* loadUI() &#123; showLoadingScreen(); yield loadUIDataAsynchronously(); hideLoadingScreen();&#125;var loader = loadUI();// 加载UIloader.next()// 卸载UIloader.next() 包括redux-saga中间件也充分利用了Generator特性 123456789101112131415161718192021import &#123; call, put, takeEvery, takeLatest &#125; from &#x27;redux-saga/effects&#x27;import Api from &#x27;...&#x27;function* fetchUser(action) &#123; try &#123; const user = yield call(Api.fetchUser, action.payload.userId); yield put(&#123;type: &quot;USER_FETCH_SUCCEEDED&quot;, user: user&#125;); &#125; catch (e) &#123; yield put(&#123;type: &quot;USER_FETCH_FAILED&quot;, message: e.message&#125;); &#125;&#125;function* mySaga() &#123; yield takeEvery(&quot;USER_FETCH_REQUESTED&quot;, fetchUser);&#125;function* mySaga() &#123; yield takeLatest(&quot;USER_FETCH_REQUESTED&quot;, fetchUser);&#125;export default mySaga; 还能利用Generator函数，在对象上实现Iterator接口 12345678910111213141516function* iterEntries(obj) &#123; let keys = Object.keys(obj); for (let i=0; i &lt; keys.length; i++) &#123; let key = keys[i]; yield [key, obj[key]]; &#125;&#125;let myObj = &#123; foo: 3, bar: 7 &#125;;for (let [key, value] of iterEntries(myObj)) &#123; console.log(key, value);&#125;// foo 3// bar 7","categories":[{"name":"ES6","slug":"ES6","permalink":"http://example.com/categories/ES6/"}],"tags":[{"name":"ES6","slug":"ES6","permalink":"http://example.com/tags/ES6/"}]},{"title":"ES6中Promise","slug":"ES6中Promise","date":"2018-07-24T07:36:14.000Z","updated":"2022-06-06T09:12:52.613Z","comments":true,"path":"2018/07/24/ES6中Promise/","link":"","permalink":"http://example.com/2018/07/24/ES6%E4%B8%ADPromise/","excerpt":"","text":"一、介绍Promise，译为承诺，是异步编程的一种解决方案，比传统的解决方案（回调函数）更加合理和更加强大 在以往我们如果处理多层异步操作，我们往往会像下面那样编写我们的代码 1234567doSomething(function(result) &#123; doSomethingElse(result, function(newResult) &#123; doThirdThing(newResult, function(finalResult) &#123; console.log(&#x27;得到最终结果: &#x27; + finalResult); &#125;, failureCallback); &#125;, failureCallback);&#125;, failureCallback); 阅读上面代码，是不是很难受，上述形成了经典的回调地狱 现在通过Promise的改写上面的代码 12345678910doSomething().then(function(result) &#123; return doSomethingElse(result);&#125;).then(function(newResult) &#123; return doThirdThing(newResult);&#125;).then(function(finalResult) &#123; console.log(&#x27;得到最终结果: &#x27; + finalResult);&#125;).catch(failureCallback); 瞬间感受到promise解决异步操作的优点： 链式操作减低了编码难度 代码可读性明显增强 下面我们正式来认识promise： 状态promise对象仅有三种状态 pending（进行中） fulfilled（已成功） rejected（已失败） 特点 对象的状态不受外界影响，只有异步操作的结果，可以决定当前是哪一种状态 一旦状态改变（从pending变为fulfilled和从pending变为rejected），就不会再变，任何时候都可以得到这个结果 流程认真阅读下图，我们能够轻松了解promise整个流程 二、用法Promise对象是一个构造函数，用来生成Promise实例 1const promise = new Promise(function(resolve, reject) &#123;&#125;); 1Promise`构造函数接受一个函数作为参数，该函数的两个参数分别是`resolve`和`reject resolve函数的作用是，将Promise对象的状态从“未完成”变为“成功” reject函数的作用是，将Promise对象的状态从“未完成”变为“失败” 实例方法Promise构建出来的实例存在以下方法： then() catch() finally() then()then是实例状态发生改变时的回调函数，第一个参数是resolved状态的回调函数，第二个参数是rejected状态的回调函数 then方法返回的是一个新的Promise实例，也就是promise能链式书写的原因 12345getJSON(&quot;/posts.json&quot;).then(function(json) &#123; return json.post;&#125;).then(function(post) &#123; // ...&#125;); catchcatch()方法是.then(null, rejection)或.then(undefined, rejection)的别名，用于指定发生错误时的回调函数 123456getJSON(&#x27;/posts.json&#x27;).then(function(posts) &#123; // ...&#125;).catch(function(error) &#123; // 处理 getJSON 和 前一个回调函数运行时发生的错误 console.log(&#x27;发生错误！&#x27;, error);&#125;); Promise对象的错误具有“冒泡”性质，会一直向后传递，直到被捕获为止 1234567getJSON(&#x27;/post/1.json&#x27;).then(function(post) &#123; return getJSON(post.commentURL);&#125;).then(function(comments) &#123; // some code&#125;).catch(function(error) &#123; // 处理前面三个Promise产生的错误&#125;); 一般来说，使用catch方法代替then()第二个参数 Promise对象抛出的错误不会传递到外层代码，即不会有任何反应 123456const someAsyncThing = function() &#123; return new Promise(function(resolve, reject) &#123; // 下面一行会报错，因为x没有声明 resolve(x + 2); &#125;);&#125;; 浏览器运行到这一行，会打印出错误提示ReferenceError: x is not defined，但是不会退出进程 catch()方法之中，还能再抛出错误，通过后面catch方法捕获到 finally()finally()方法用于指定不管 Promise 对象最后状态如何，都会执行的操作 1234promise.then(result =&gt; &#123;···&#125;).catch(error =&gt; &#123;···&#125;).finally(() =&gt; &#123;···&#125;); 构造函数方法Promise构造函数存在以下方法： all() race() allSettled() resolve() reject() try() all()Promise.all()方法用于将多个 Promise实例，包装成一个新的 Promise实例 1const p = Promise.all([p1, p2, p3]); 接受一个数组（迭代对象）作为参数，数组成员都应为Promise实例 实例p的状态由p1、p2、p3决定，分为两种： 只有p1、p2、p3的状态都变成fulfilled，p的状态才会变成fulfilled，此时p1、p2、p3的返回值组成一个数组，传递给p的回调函数 只要p1、p2、p3之中有一个被rejected，p的状态就变成rejected，此时第一个被reject的实例的返回值，会传递给p的回调函数 注意，如果作为参数的 Promise 实例，自己定义了catch方法，那么它一旦被rejected，并不会触发Promise.all()的catch方法 12345678910111213141516const p1 = new Promise((resolve, reject) =&gt; &#123; resolve(&#x27;hello&#x27;);&#125;).then(result =&gt; result).catch(e =&gt; e);const p2 = new Promise((resolve, reject) =&gt; &#123; throw new Error(&#x27;报错了&#x27;);&#125;).then(result =&gt; result).catch(e =&gt; e);Promise.all([p1, p2]).then(result =&gt; console.log(result)).catch(e =&gt; console.log(e));// [&quot;hello&quot;, Error: 报错了] 如果p2没有自己的catch方法，就会调用Promise.all()的catch方法 1234567891011121314const p1 = new Promise((resolve, reject) =&gt; &#123; resolve(&#x27;hello&#x27;);&#125;).then(result =&gt; result);const p2 = new Promise((resolve, reject) =&gt; &#123; throw new Error(&#x27;报错了&#x27;);&#125;).then(result =&gt; result);Promise.all([p1, p2]).then(result =&gt; console.log(result)).catch(e =&gt; console.log(e));// Error: 报错了 race()Promise.race()方法同样是将多个 Promise 实例，包装成一个新的 Promise 实例 1const p = Promise.race([p1, p2, p3]); 只要p1、p2、p3之中有一个实例率先改变状态，p的状态就跟着改变 率先改变的 Promise 实例的返回值则传递给p的回调函数 12345678910const p = Promise.race([ fetch(&#x27;/resource-that-may-take-a-while&#x27;), new Promise(function (resolve, reject) &#123; setTimeout(() =&gt; reject(new Error(&#x27;request timeout&#x27;)), 5000) &#125;)]);p.then(console.log).catch(console.error); allSettled()Promise.allSettled()方法接受一组 Promise 实例作为参数，包装成一个新的 Promise 实例 只有等到所有这些参数实例都返回结果，不管是fulfilled还是rejected，包装实例才会结束 12345678const promises = [ fetch(&#x27;/api-1&#x27;), fetch(&#x27;/api-2&#x27;), fetch(&#x27;/api-3&#x27;),];await Promise.allSettled(promises);removeLoadingIndicator(); resolve()将现有对象转为 Promise对象 123Promise.resolve(&#x27;foo&#x27;)// 等价于new Promise(resolve =&gt; resolve(&#x27;foo&#x27;)) 参数可以分成四种情况，分别如下： 参数是一个 Promise 实例，promise.resolve将不做任何修改、原封不动地返回这个实例 参数是一个thenable对象，promise.resolve会将这个对象转为 Promise对象，然后就立即执行thenable对象的then()方法 参数不是具有then()方法的对象，或根本就不是对象，Promise.resolve()会返回一个新的 Promise 对象，状态为resolved 没有参数时，直接返回一个resolved状态的 Promise 对象 reject()123456789Promise.reject(reason)`方法也会返回一个新的 Promise 实例，该实例的状态为`rejectedconst p = Promise.reject(&#x27;出错了&#x27;);// 等同于const p = new Promise((resolve, reject) =&gt; reject(&#x27;出错了&#x27;))p.then(null, function (s) &#123; console.log(s)&#125;);// 出错了 Promise.reject()方法的参数，会原封不动地变成后续方法的参数 12345Promise.reject(&#x27;出错了&#x27;).catch(e =&gt; &#123; console.log(e === &#x27;出错了&#x27;)&#125;)// true 三、使用场景将图片的加载写成一个Promise，一旦加载完成，Promise的状态就发生变化 12345678const preloadImage = function (path) &#123; return new Promise(function (resolve, reject) &#123; const image = new Image(); image.onload = resolve; image.onerror = reject; image.src = path; &#125;);&#125;; 通过链式操作，将多个渲染数据分别给个then，让其各司其职。或当下个异步请求依赖上个请求结果的时候，我们也能够通过链式操作友好解决问题 123456789101112131415161718// 各司其职getInfo().then(res=&gt;&#123; let &#123; bannerList &#125; = res //渲染轮播图 console.log(bannerList) return res&#125;).then(res=&gt;&#123; let &#123; storeList &#125; = res //渲染店铺列表 console.log(storeList) return res&#125;).then(res=&gt;&#123; let &#123; categoryList &#125; = res console.log(categoryList) //渲染分类列表 return res&#125;) 通过all()实现多个请求合并在一起，汇总所有请求结果，只需设置一个loading即可 123456789101112function initLoad()&#123; // loading.show() //加载loading Promise.all([getBannerList(),getStoreList(),getCategoryList()]).then(res=&gt;&#123; console.log(res) loading.hide() //关闭loading &#125;).catch(err=&gt;&#123; console.log(err) loading.hide()//关闭loading &#125;)&#125;//数据初始化 initLoad() 通过race可以设置图片请求超时 12345678910111213141516171819202122232425262728293031//请求某个图片资源function requestImg()&#123; var p = new Promise(function(resolve, reject)&#123; var img = new Image(); img.onload = function()&#123; resolve(img); &#125; //img.src = &quot;https://b-gold-cdn.xitu.io/v3/static/img/logo.a7995ad.svg&quot;; 正确的 img.src = &quot;https://b-gold-cdn.xitu.io/v3/static/img/logo.a7995ad.svg1&quot;; &#125;); return p;&#125;//延时函数，用于给请求计时function timeout()&#123; var p = new Promise(function(resolve, reject)&#123; setTimeout(function()&#123; reject(&#x27;图片请求超时&#x27;); &#125;, 5000); &#125;); return p;&#125;Promise.race([requestImg(), timeout()]).then(function(results)&#123; console.log(results);&#125;).catch(function(reason)&#123; console.log(reason);&#125;);","categories":[{"name":"ES6","slug":"ES6","permalink":"http://example.com/categories/ES6/"}],"tags":[{"name":"ES6","slug":"ES6","permalink":"http://example.com/tags/ES6/"}]},{"title":"ES6新增功能","slug":"ES6新增功能","date":"2018-07-24T01:36:14.000Z","updated":"2022-05-31T03:02:03.136Z","comments":true,"path":"2018/07/24/ES6新增功能/","link":"","permalink":"http://example.com/2018/07/24/ES6%E6%96%B0%E5%A2%9E%E5%8A%9F%E8%83%BD/","excerpt":"","text":"数组新增 一、扩展运算符的应用ES6通过扩展元素符...，好比 rest 参数的逆运算，将一个数组转为用逗号分隔的参数序列 12345678console.log(...[1, 2, 3])// 1 2 3console.log(1, ...[2, 3, 4], 5)// 1 2 3 4 5[...document.querySelectorAll(&#x27;div&#x27;)]// [&lt;div&gt;, &lt;div&gt;, &lt;div&gt;] 主要用于函数调用的时候，将一个数组变为参数序列 12345678910function push(array, ...items) &#123; array.push(...items);&#125;function add(x, y) &#123; return x + y;&#125;const numbers = [4, 38];add(...numbers) // 42 可以将某些数据结构转为数组 1[...document.querySelectorAll(&#x27;div&#x27;)] 能够更简单实现数组复制 123const a1 = [1, 2];const [...a2] = a1;// [1,2] 数组的合并也更为简洁了 12345const arr1 = [&#x27;a&#x27;, &#x27;b&#x27;];const arr2 = [&#x27;c&#x27;];const arr3 = [&#x27;d&#x27;, &#x27;e&#x27;];[...arr1, ...arr2, ...arr3]// [ &#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;, &#x27;e&#x27; ] 注意：通过扩展运算符实现的是浅拷贝，修改了引用指向的值，会同步反映到新数组 下面看个例子就清楚多了 12345const arr1 = [&#x27;a&#x27;, &#x27;b&#x27;,[1,2]];const arr2 = [&#x27;c&#x27;];const arr3 = [...arr1,...arr2]arr[1][0] = 9999 // 修改arr1里面数组成员值console.log(arr[3]) // 影响到arr3,[&#x27;a&#x27;,&#x27;b&#x27;,[9999,2],&#x27;c&#x27;] 扩展运算符可以与解构赋值结合起来，用于生成数组 1234567891011const [first, ...rest] = [1, 2, 3, 4, 5];first // 1rest // [2, 3, 4, 5]const [first, ...rest] = [];first // undefinedrest // []const [first, ...rest] = [&quot;foo&quot;];first // &quot;foo&quot;rest // [] 如果将扩展运算符用于数组赋值，只能放在参数的最后一位，否则会报错 12345const [...butLast, last] = [1, 2, 3, 4, 5];// 报错const [first, ...middle, last] = [1, 2, 3, 4, 5];// 报错 可以将字符串转为真正的数组 12[...&#x27;hello&#x27;]// [ &quot;h&quot;, &quot;e&quot;, &quot;l&quot;, &quot;l&quot;, &quot;o&quot; ] 定义了遍历器（Iterator）接口的对象，都可以用扩展运算符转为真正的数组 12345678910let nodeList = document.querySelectorAll(&#x27;div&#x27;);let array = [...nodeList];let map = new Map([ [1, &#x27;one&#x27;], [2, &#x27;two&#x27;], [3, &#x27;three&#x27;],]);let arr = [...map.keys()]; // [1, 2, 3] 如果对没有 Iterator 接口的对象，使用扩展运算符，将会报错 12const obj = &#123;a: 1, b: 2&#125;;let arr = [...obj]; // TypeError: Cannot spread non-iterable object 二、构造函数新增的方法关于构造函数，数组新增的方法有如下： Array.from() Array.of() Array.from()将两类对象转为真正的数组：类似数组的对象和可遍历（iterable）的对象（包括 ES6 新增的数据结构 Set 和 Map） 1234567let arrayLike = &#123; &#x27;0&#x27;: &#x27;a&#x27;, &#x27;1&#x27;: &#x27;b&#x27;, &#x27;2&#x27;: &#x27;c&#x27;, length: 3&#125;;let arr2 = Array.from(arrayLike); // [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;] 还可以接受第二个参数，用来对每个元素进行处理，将处理后的值放入返回的数组 12Array.from([1, 2, 3], (x) =&gt; x * x)// [1, 4, 9] Array.of()用于将一组值，转换为数组 1Array.of(3, 11, 8) // [3,11,8] 没有参数的时候，返回一个空数组 当参数只有一个的时候，实际上是指定数组的长度 参数个数不少于 2 个时，Array()才会返回由参数组成的新数组 123Array() // []Array(3) // [, , ,]Array(3, 11, 8) // [3, 11, 8] 三、实例对象新增的方法关于数组实例对象新增的方法有如下： copyWithin() find()、findIndex() fill() entries()，keys()，values() includes() flat()，flatMap() copyWithin()将指定位置的成员复制到其他位置（会覆盖原有成员），然后返回当前数组 参数如下： target（必需）：从该位置开始替换数据。如果为负值，表示倒数。 start（可选）：从该位置开始读取数据，默认为 0。如果为负值，表示从末尾开始计算。 end（可选）：到该位置前停止读取数据，默认等于数组长度。如果为负值，表示从末尾开始计算。 12[1, 2, 3, 4, 5].copyWithin(0, 3) // 将从 3 号位直到数组结束的成员（4 和 5），复制到从 0 号位开始的位置，结果覆盖了原来的 1 和 2// [4, 5, 3, 4, 5] find()、findIndex()find()用于找出第一个符合条件的数组成员 参数是一个回调函数，接受三个参数依次为当前的值、当前的位置和原数组 123[1, 5, 10, 15].find(function(value, index, arr) &#123; return value &gt; 9;&#125;) // 10 1234findIndex`返回第一个符合条件的数组成员的位置，如果所有成员都不符合条件，则返回`-1[1, 5, 10, 15].findIndex(function(value, index, arr) &#123; return value &gt; 9;&#125;) // 2 这两个方法都可以接受第二个参数，用来绑定回调函数的this对象。 12345function f(v)&#123; return v &gt; this.age;&#125;let person = &#123;name: &#x27;John&#x27;, age: 20&#125;;[10, 12, 26, 15].find(f, person); // 26 fill()使用给定值，填充一个数组 12345[&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;].fill(7)// [7, 7, 7]new Array(3).fill(7)// [7, 7, 7] 还可以接受第二个和第三个参数，用于指定填充的起始位置和结束位置 12[&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;].fill(7, 1, 2)// [&#x27;a&#x27;, 7, &#x27;c&#x27;] 注意，如果填充的类型为对象，则是浅拷贝 entries()，keys()，values()keys()是对键名的遍历、values()是对键值的遍历，entries()是对键值对的遍历 12345678910111213141516or (let index of [&#x27;a&#x27;, &#x27;b&#x27;].keys()) &#123; console.log(index);&#125;// 0// 1for (let elem of [&#x27;a&#x27;, &#x27;b&#x27;].values()) &#123; console.log(elem);&#125;// &#x27;a&#x27;// &#x27;b&#x27;for (let [index, elem] of [&#x27;a&#x27;, &#x27;b&#x27;].entries()) &#123; console.log(index, elem);&#125;// 0 &quot;a&quot; includes()用于判断数组是否包含给定的值 123[1, 2, 3].includes(2) // true[1, 2, 3].includes(4) // false[1, 2, NaN].includes(NaN) // true 方法的第二个参数表示搜索的起始位置，默认为0 参数为负数则表示倒数的位置 12[1, 2, 3].includes(3, 3); // false[1, 2, 3].includes(3, -1); // true flat()，flatMap()将数组扁平化处理，返回一个新数组，对原数据没有影响 12[1, 2, [3, 4]].flat()// [1, 2, 3, 4] flat()默认只会“拉平”一层，如果想要“拉平”多层的嵌套数组，可以将flat()方法的参数写成一个整数，表示想要拉平的层数，默认为1 12345[1, 2, [3, [4, 5]]].flat()// [1, 2, 3, [4, 5]][1, 2, [3, [4, 5]]].flat(2)// [1, 2, 3, 4, 5] flatMap()方法对原数组的每个成员执行一个函数相当于执行Array.prototype.map()，然后对返回值组成的数组执行flat()方法。该方法返回一个新数组，不改变原数组 123// 相当于 [[2, 4], [3, 6], [4, 8]].flat()[2, 3, 4].flatMap((x) =&gt; [x, x * 2])// [2, 4, 3, 6, 4, 8] 1flatMap()方法还可以有第二个参数，用来绑定遍历函数里面的this 四、数组的空位数组的空位指，数组的某一个位置没有任何值 ES6 则是明确将空位转为undefined，包括Array.from、扩展运算符、copyWithin()、fill()、entries()、keys()、values()、find()和findIndex() 建议大家在日常书写中，避免出现空位 五、排序稳定性将sort()默认设置为稳定的排序算法 1234567891011121314const arr = [ &#x27;peach&#x27;, &#x27;straw&#x27;, &#x27;apple&#x27;, &#x27;spork&#x27;];const stableSorting = (s1, s2) =&gt; &#123; if (s1[0] &lt; s2[0]) return -1; return 1;&#125;;arr.sort(stableSorting)// [&quot;apple&quot;, &quot;peach&quot;, &quot;straw&quot;, &quot;spork&quot;] 排序结果中，straw在spork的前面，跟原始顺序一致 对象新增 一、属性的简写ES6中，当对象键名与对应值名相等的时候，可以进行简写 1234const baz = &#123;foo:foo&#125;// 等同于const baz = &#123;foo&#125; 方法也能够进行简写 12345678910111213const o = &#123; method() &#123; return &quot;Hello!&quot;; &#125;&#125;;// 等同于const o = &#123; method: function() &#123; return &quot;Hello!&quot;; &#125;&#125; 在函数内作为返回值，也会变得方便很多 12345678function getPoint() &#123; const x = 1; const y = 10; return &#123;x, y&#125;;&#125;getPoint()// &#123;x:1, y:10&#125; 注意：简写的对象方法不能用作构造函数，否则会报错 1234567const obj = &#123; f() &#123; this.foo = &#x27;bar&#x27;; &#125;&#125;;new obj.f() // 报错 二、属性名表达式ES6 允许字面量定义对象时，将表达式放在括号内 12345678910let lastWord = &#x27;last word&#x27;;const a = &#123; &#x27;first word&#x27;: &#x27;hello&#x27;, [lastWord]: &#x27;world&#x27;&#125;;a[&#x27;first word&#x27;] // &quot;hello&quot;a[lastWord] // &quot;world&quot;a[&#x27;last word&#x27;] // &quot;world&quot; 表达式还可以用于定义方法名 1234567let obj = &#123; [&#x27;h&#x27; + &#x27;ello&#x27;]() &#123; return &#x27;hi&#x27;; &#125;&#125;;obj.hello() // hi 注意，属性名表达式与简洁表示法，不能同时使用，会报错 12345678// 报错const foo = &#x27;bar&#x27;;const bar = &#x27;abc&#x27;;const baz = &#123; [foo] &#125;;// 正确const foo = &#x27;bar&#x27;;const baz = &#123; [foo]: &#x27;abc&#x27;&#125;; 注意，属性名表达式如果是一个对象，默认情况下会自动将对象转为字符串[object Object] 123456789const keyA = &#123;a: 1&#125;;const keyB = &#123;b: 2&#125;;const myObject = &#123; [keyA]: &#x27;valueA&#x27;, [keyB]: &#x27;valueB&#x27;&#125;;myObject // Object &#123;[object Object]: &quot;valueB&quot;&#125; 三、super关键字this关键字总是指向函数所在的当前对象，ES6 又新增了另一个类似的关键字super，指向当前对象的原型对象 12345678910111213const proto = &#123; foo: &#x27;hello&#x27;&#125;;const obj = &#123; foo: &#x27;world&#x27;, find() &#123; return super.foo; &#125;&#125;;Object.setPrototypeOf(obj, proto); // 为obj设置原型对象obj.find() // &quot;hello&quot; 四、扩展运算符的应用在解构赋值中，未被读取的可遍历的属性，分配到指定的对象上面 1234let &#123; x, y, ...z &#125; = &#123; x: 1, y: 2, a: 3, b: 4 &#125;;x // 1y // 2z // &#123; a: 3, b: 4 &#125; 注意：解构赋值必须是最后一个参数，否则会报错 解构赋值是浅拷贝 1234let obj = &#123; a: &#123; b: 1 &#125; &#125;;let &#123; ...x &#125; = obj;obj.a.b = 2; // 修改obj里面a属性中键值x.a.b // 2，影响到了结构出来x的值 对象的扩展运算符等同于使用Object.assign()方法 五、属性的遍历ES6 一共有 5 种方法可以遍历对象的属性。 for…in：循环遍历对象自身的和继承的可枚举属性（不含 Symbol 属性） Object.keys(obj)：返回一个数组，包括对象自身的（不含继承的）所有可枚举属性（不含 Symbol 属性）的键名 Object.getOwnPropertyNames(obj)：回一个数组，包含对象自身的所有属性（不含 Symbol 属性，但是包括不可枚举属性）的键名 Object.getOwnPropertySymbols(obj)：返回一个数组，包含对象自身的所有 Symbol 属性的键名 Reflect.ownKeys(obj)：返回一个数组，包含对象自身的（不含继承的）所有键名，不管键名是 Symbol 或字符串，也不管是否可枚举 上述遍历，都遵守同样的属性遍历的次序规则： 首先遍历所有数值键，按照数值升序排列 其次遍历所有字符串键，按照加入时间升序排列 最后遍历所有 Symbol 键，按照加入时间升序排 12Reflect.ownKeys(&#123; [Symbol()]:0, b:0, 10:0, 2:0, a:0 &#125;)// [&#x27;2&#x27;, &#x27;10&#x27;, &#x27;b&#x27;, &#x27;a&#x27;, Symbol()] 六、对象新增的方法关于对象新增的方法，分别有以下： Object.is() Object.assign() Object.getOwnPropertyDescriptors() Object.setPrototypeOf()，Object.getPrototypeOf() Object.keys()，Object.values()，Object.entries() Object.fromEntries() Object.is()严格判断两个值是否相等，与严格比较运算符（&#x3D;&#x3D;&#x3D;）的行为基本一致，不同之处只有两个：一是+0不等于-0，二是NaN等于自身 12345+0 === -0 //trueNaN === NaN // falseObject.is(+0, -0) // falseObject.is(NaN, NaN) // true Object.assign()1Object.assign()`方法用于对象的合并，将源对象`source`的所有可枚举属性，复制到目标对象`target Object.assign()方法的第一个参数是目标对象，后面的参数都是源对象 1234567const target = &#123; a: 1, b: 1 &#125;;const source1 = &#123; b: 2, c: 2 &#125;;const source2 = &#123; c: 3 &#125;;Object.assign(target, source1, source2);target // &#123;a:1, b:2, c:3&#125; 注意：Object.assign()方法是浅拷贝，遇到同名属性会进行替换 Object.getOwnPropertyDescriptors()返回指定对象所有自身属性（非继承属性）的描述对象 12345678910111213141516const obj = &#123; foo: 123, get bar() &#123; return &#x27;abc&#x27; &#125;&#125;;Object.getOwnPropertyDescriptors(obj)// &#123; foo:// &#123; value: 123,// writable: true,// enumerable: true,// configurable: true &#125;,// bar:// &#123; get: [Function: get bar],// set: undefined,// enumerable: true,// configurable: true &#125; &#125; Object.setPrototypeOf()Object.setPrototypeOf方法用来设置一个对象的原型对象 1234Object.setPrototypeOf(object, prototype)// 用法const o = Object.setPrototypeOf(&#123;&#125;, null); Object.getPrototypeOf()用于读取一个对象的原型对象 1Object.getPrototypeOf(obj); Object.keys()返回自身的（不含继承的）所有可遍历（enumerable）属性的键名的数组 123var obj = &#123; foo: &#x27;bar&#x27;, baz: 42 &#125;;Object.keys(obj)// [&quot;foo&quot;, &quot;baz&quot;] Object.values()返回自身的（不含继承的）所有可遍历（enumerable）属性的键对应值的数组 123const obj = &#123; foo: &#x27;bar&#x27;, baz: 42 &#125;;Object.values(obj)// [&quot;bar&quot;, 42] Object.entries()返回一个对象自身的（不含继承的）所有可遍历（enumerable）属性的键值对的数组 123const obj = &#123; foo: &#x27;bar&#x27;, baz: 42 &#125;;Object.entries(obj)// [ [&quot;foo&quot;, &quot;bar&quot;], [&quot;baz&quot;, 42] ] Object.fromEntries()用于将一个键值对数组转为对象 12345Object.fromEntries([ [&#x27;foo&#x27;, &#x27;bar&#x27;], [&#x27;baz&#x27;, 42]])// &#123; foo: &quot;bar&quot;, baz: 42 &#125; 函数新增 一、参数ES6允许为函数的参数设置默认值 1234567function log(x, y = &#x27;World&#x27;) &#123; console.log(x, y);&#125;console.log(&#x27;Hello&#x27;) // Hello Worldconsole.log(&#x27;Hello&#x27;, &#x27;China&#x27;) // Hello Chinaconsole.log(&#x27;Hello&#x27;, &#x27;&#x27;) // Hello 函数的形参是默认声明的，不能使用let或const再次声明 1234function foo(x = 5) &#123; let x = 1; // error const x = 2; // error&#125; 参数默认值可以与解构赋值的默认值结合起来使用 12345678function foo(&#123;x, y = 5&#125;) &#123; console.log(x, y);&#125;foo(&#123;&#125;) // undefined 5foo(&#123;x: 1&#125;) // 1 5foo(&#123;x: 1, y: 2&#125;) // 1 2foo() // TypeError: Cannot read property &#x27;x&#x27; of undefined 上面的foo函数，当参数为对象的时候才能进行解构，如果没有提供参数的时候，变量x和y就不会生成，从而报错，这里设置默认值避免 12345function foo(&#123;x, y = 5&#125; = &#123;&#125;) &#123; console.log(x, y);&#125;foo() // undefined 5 参数默认值应该是函数的尾参数，如果不是非尾部的参数设置默认值，实际上这个参数是没发省略的 12345678function f(x = 1, y) &#123; return [x, y];&#125;f() // [1, undefined]f(2) // [2, undefined]f(, 1) // 报错f(undefined, 1) // [1, 1] 二、属性函数的length属性length将返回没有指定默认值的参数个数 123(function (a) &#123;&#125;).length // 1(function (a = 5) &#123;&#125;).length // 0(function (a, b, c = 5) &#123;&#125;).length // 2 rest 参数也不会计入length属性 1(function(...args) &#123;&#125;).length // 0 如果设置了默认值的参数不是尾参数，那么length属性也不再计入后面的参数了 12(function (a = 0, b, c) &#123;&#125;).length // 0(function (a, b = 1, c) &#123;&#125;).length // 1 name属性返回该函数的函数名 1234567var f = function () &#123;&#125;;// ES5f.name // &quot;&quot;// ES6f.name // &quot;f&quot; 如果将一个具名函数赋值给一个变量，则 name属性都返回这个具名函数原本的名字 12const bar = function baz() &#123;&#125;;bar.name // &quot;baz&quot; 12Function`构造函数返回的函数实例，`name`属性的值为`anonymous(new Function).name // &quot;anonymous&quot; bind返回的函数，name属性值会加上bound前缀 1234function foo() &#123;&#125;;foo.bind(&#123;&#125;).name // &quot;bound foo&quot;(function()&#123;&#125;).bind(&#123;&#125;).name // &quot;bound &quot; 三、作用域一旦设置了参数的默认值，函数进行声明初始化时，参数会形成一个单独的作用域 等到初始化结束，这个作用域就会消失。这种语法行为，在不设置参数默认值时，是不会出现的 下面例子中，y=x会形成一个单独作用域，x没有被定义，所以指向全局变量x 123456789let x = 1;function f(y = x) &#123; // 等同于 let y = x let x = 2; console.log(y);&#125;f() // 1 四、严格模式只要函数参数使用了默认值、解构赋值、或者扩展运算符，那么函数内部就不能显式设定为严格模式，否则会报错 12345678910111213141516171819202122232425// 报错function doSomething(a, b = a) &#123; &#x27;use strict&#x27;; // code&#125;// 报错const doSomething = function (&#123;a, b&#125;) &#123; &#x27;use strict&#x27;; // code&#125;;// 报错const doSomething = (...a) =&gt; &#123; &#x27;use strict&#x27;; // code&#125;;const obj = &#123; // 报错 doSomething(&#123;a, b&#125;) &#123; &#x27;use strict&#x27;; // code &#125;&#125;; 五、箭头函数使用“箭头”（=&gt;）定义函数 123456var f = v =&gt; v;// 等同于var f = function (v) &#123; return v;&#125;; 如果箭头函数不需要参数或需要多个参数，就使用一个圆括号代表参数部分 123456789var f = () =&gt; 5;// 等同于var f = function () &#123; return 5 &#125;;var sum = (num1, num2) =&gt; num1 + num2;// 等同于var sum = function(num1, num2) &#123; return num1 + num2;&#125;; 如果箭头函数的代码块部分多于一条语句，就要使用大括号将它们括起来，并且使用return语句返回 1var sum = (num1, num2) =&gt; &#123; return num1 + num2; &#125; 如果返回对象，需要加括号将对象包裹 1let getTempItem = id =&gt; (&#123; id: id, name: &quot;Temp&quot; &#125;); 注意点： 函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象 不可以当作构造函数，也就是说，不可以使用new命令，否则会抛出一个错误 不可以使用arguments对象，该对象在函数体内不存在。如果要用，可以用 rest 参数代替 不可以使用yield命令，因此箭头函数不能用作 Generator 函数","categories":[{"name":"ES6","slug":"ES6","permalink":"http://example.com/categories/ES6/"}],"tags":[{"name":"ES6","slug":"ES6","permalink":"http://example.com/tags/ES6/"}]},{"title":"虚拟dom和真实dom的区别","slug":"虚拟dom和真实dom的区别","date":"2018-06-02T03:03:57.000Z","updated":"2022-06-02T03:09:22.505Z","comments":true,"path":"2018/06/02/虚拟dom和真实dom的区别/","link":"","permalink":"http://example.com/2018/06/02/%E8%99%9A%E6%8B%9Fdom%E5%92%8C%E7%9C%9F%E5%AE%9Edom%E7%9A%84%E5%8C%BA%E5%88%AB/","excerpt":"","text":"一、是什么Real DOM，真实 DOM，意思为文档对象模型，是一个结构化文本的抽象，在页面渲染出的每一个结点都是一个真实 DOM 结构，如下： Virtual Dom，本质上是以 JavaScript 对象形式存在的对 DOM 的描述 创建虚拟 DOM 目的就是为了更好将虚拟的节点渲染到页面视图中，虚拟 DOM 对象的节点与真实 DOM 的属性一一照应 在 React 中，JSX 是其一大特性，可以让你在 JS 中通过使用 XML 的方式去直接声明界面的 DOM 结构 123456// 创建 h1 标签，右边千万不能加引号const vDom = &lt;h1&gt;Hello World&lt;/h1&gt;; // 找到 &lt;div id=&quot;root&quot;&gt;&lt;/div&gt; 节点const root = document.getElementById(&quot;root&quot;); // 把创建的 h1 标签渲染到 root 节点上ReactDOM.render(vDom, root); 上述中，ReactDOM.render() 用于将你创建好的虚拟 DOM 节点插入到某个真实节点上，并渲染到页面上 JSX 实际是一种语法糖，在使用过程中会被 babel 进行编译转化成 JS 代码，上述 VDOM 转化为如下： 12345const vDom = React.createElement( &#x27;h1&#x27;， &#123; className: &#x27;hClass&#x27;, id: &#x27;hId&#x27; &#125;, &#x27;hello world&#x27;) 可以看到，JSX 就是为了简化直接调用 React.createElement() 方法： 第一个参数是标签名，例如 h1、span、table… 第二个参数是个对象，里面存着标签的一些属性，例如 id、class 等 第三个参数是节点中的文本 通过 console.log(VDOM)，则能够得到虚拟 VDOM 消息 所以可以得到，JSX 通过 babel 的方式转化成 React.createElement 执行，返回值是一个对象，也就是虚拟 DOM 二、区别两者的区别如下： 虚拟 DOM 不会进行排版与重绘操作，而真实 DOM 会频繁重排与重绘 虚拟 DOM 的总损耗是“虚拟 DOM 增删改+真实 DOM 差异增删改+排版与重绘”，真实 DOM 的总损耗是“真实 DOM 完全增删改+排版与重绘” 传统的原生 api 或 jQuery 去操作 DOM 时，浏览器会从构建 DOM 树开始从头到尾执行一遍流程 当你在一次操作时，需要更新 10 个 DOM 节点，浏览器没这么智能，收到第一个更新 DOM 请求后，并不知道后续还有 9 次更新操作，因此会马上执行流程，最终执行 10 次流程 而通过 VNode，同样更新 10 个 DOM 节点，虚拟 DOM 不会立即操作 DOM，而是将这 10 次更新的 diff 内容保存到本地的一个 js 对象中，最终将这个 js 对象一次性 attach 到 DOM 树上，避免大量的无谓计算 三、优缺点真实 DOM 的优势： 易用 缺点： 效率低，解析速度慢，内存占用量过高 性能差：频繁操作真实 DOM，易于导致重绘与回流 使用虚拟 DOM 的优势如下： 简单方便：如果使用手动操作真实 DOM 来完成页面，繁琐又容易出错，在大规模应用下维护起来也很困难 性能方面：使用 Virtual DOM，能够有效避免真实 DOM 数频繁更新，减少多次引起重绘与回流，提高性能 跨平台：React 借助虚拟 DOM，带来了跨平台的能力，一套代码多端运行 缺点： 在一些性能要求极高的应用中虚拟 DOM 无法进行针对性的极致优化 首次渲染大量 DOM 时，由于多了一层虚拟 DOM 的计算，速度比正常稍慢","categories":[{"name":"react","slug":"react","permalink":"http://example.com/categories/react/"}],"tags":[{"name":"react","slug":"react","permalink":"http://example.com/tags/react/"}]},{"title":"vue为何使用虚拟dom","slug":"vue为何使用虚拟dom","date":"2018-05-03T02:21:06.000Z","updated":"2022-06-02T03:38:26.271Z","comments":true,"path":"2018/05/03/vue为何使用虚拟dom/","link":"","permalink":"http://example.com/2018/05/03/vue%E4%B8%BA%E4%BD%95%E4%BD%BF%E7%94%A8%E8%99%9A%E6%8B%9Fdom/","excerpt":"","text":"为何使用虚拟dom 手动操作 DOM 比较麻烦，还需要考虑浏览器兼容性问题，虽然有 jQuery 等库简化 DOM 操作，但是随着项目的复杂 DOM 操作复杂提升 为了简化 DOM 的复杂操作于是出现了各种 MVVM 框架，MVVM 框架解决了视图和状态的同步问题 为了简化视图的操作我们可以使用模板引擎，但是模板引擎没有解决跟踪状态变化的问题，于是Virtual DOM 出现了 Virtual DOM 的好处是当状态改变时不需要立即更新 DOM，只需要创建一个虚拟树来描述DOM，Virtual DOM 内部将弄清楚如何有效(diff)的更新 DOM 虚拟 DOM 可以维护程序的状态，跟踪上一次的状态 通过比较前后两次状态的差异更新真实 DOM 虚拟dom的作用 维护视图和状态的关系 复杂视图情况下提升渲染性能 除了渲染 DOM 以外，还可以实现 SSR(Nuxt.js/Next.js)、原生应用(Weex/React Native)、小程序(mpvue/uni-app)等 虚拟dom的必要性 创建真实DOM的代价高：真实的 DOM 节点 node 实现的属性很多，而 vnode 仅仅实现一些必要的属性，相比起来，创建一个 vnode 的成本比较低。 触发多次浏览器重绘及回流：使用 vnode ，相当于加了一个缓冲，让一次数据变动所带来的所有 node 变化，先在 vnode 中进行修改，然后 diff 之后对所有产生差异的节点集中一次对 DOM tree 进行修改，以减少浏览器的重绘及回流。 vue为何采用虚拟dom 引入 Virtual DOM 在性能方面的考量仅仅是一方面。 性能受场景的影响是非常大的，不同的场景可能造成不同实现方案之间成倍的性能差距，所以依赖细粒度绑定及 Virtual DOM 哪个的性能更好还真不是一个容易下定论的问题。 Vue 之所以引入了 Virtual DOM，更重要的原因是为了解耦 HTML依赖，这带来两个非常重要的好处是： 不再依赖 HTML 解析器进行模版解析，可以进行更多的 AOT 工作提高运行时效率：通过模版 AOT 编译，Vue 的运行时体积可以进一步压缩，运行时效率可以进一步提升； 可以渲染到 DOM 以外的平台，实现 SSR、同构渲染这些高级特性，Weex等框架应用的就是这一特性。 综上，Virtual DOM 在性能上的收益并不是最主要的，更重要的是它使得 Vue 具备了现代框架应有的高级特性。","categories":[{"name":"vue","slug":"vue","permalink":"http://example.com/categories/vue/"}],"tags":[{"name":"vue","slug":"vue","permalink":"http://example.com/tags/vue/"}]},{"title":"单页应用（SPA）","slug":"单页应用（SPA）","date":"2018-04-29T14:41:23.000Z","updated":"2022-05-30T02:12:03.205Z","comments":true,"path":"2018/04/29/单页应用（SPA）/","link":"","permalink":"http://example.com/2018/04/29/%E5%8D%95%E9%A1%B5%E5%BA%94%E7%94%A8%EF%BC%88SPA%EF%BC%89/","excerpt":"","text":"一、什么是SPASPA（single-page application），翻译过来就是单页应用SPA是一种网络应用程序或网站的模型，它通过动态重写当前页面来与用户交互，这种方法避免了页面之间切换打断用户体验在单页应用中，所有必要的代码（HTML、JavaScript和CSS）都通过单个页面的加载而检索，或者根据需要（通常是为响应用户操作）动态装载适当的资源并添加到页面页面在任何时间点都不会重新加载，也不会将控制转移到其他页面举个例子来讲就是一个杯子，早上装的牛奶，中午装的是开水，晚上装的是茶，我们发现，变的始终是杯子里的内容，而杯子始终是那个杯子结构如下图 我们熟知的JS框架如react,vue,angular,ember都属于SPA 二、SPA和MPA的区别上面大家已经对单页面有所了解了，下面来讲讲多页应用MPA（MultiPage-page application），翻译过来就是多页应用在MPA中，每个页面都是一个主页面，都是独立的当我们在访问另一个页面的时候，都需要重新加载html、css、js文件，公共文件则根据需求按需加载如下图 单页应用与多页应用的区别 单页面应用（SPA） 多页面应用（MPA） 组成 一个主页面和多个页面片段 多个主页面 刷新方式 局部刷新 整页刷新 url模式 哈希模式 历史模式 SEO搜索引擎优化 难实现，可使用SSR方式改善 容易实现 数据传递 容易 通过url、cookie、localStorage等传递 页面切换 速度快，用户体验良好 切换加载资源，速度慢，用户体验差 维护成本 相对容易 相对复杂 单页应用优缺点优点： 具有桌面应用的即时性、网站的可移植性和可访问性 用户体验好、快，内容的改变不需要重新加载整个页面 良好的前后端分离，分工更明确 缺点： 不利于搜索引擎的抓取 首次渲染速度相对较慢","categories":[{"name":"vue","slug":"vue","permalink":"http://example.com/categories/vue/"}],"tags":[{"name":"vue","slug":"vue","permalink":"http://example.com/tags/vue/"}]},{"title":"vuex","slug":"vuex","date":"2018-04-20T02:21:06.000Z","updated":"2022-06-02T03:53:59.174Z","comments":true,"path":"2018/04/20/vuex/","link":"","permalink":"http://example.com/2018/04/20/vuex/","excerpt":"","text":"Vuex 集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以可预测的方式发生变化 核心概念 state: Vuex 使用单一状态树,即每个应用将仅仅包含一个store 实例，但单一状态树和模块化并不冲突。存放的数据状态，不可以直接修改里面的数据。 mutations: mutations定义的方法动态修改Vuex 的 store 中的状态或数据。 actions: actions可以理解为通过将mutations里面处里数据的方法变成可异步的处理数据的方法，简单的说就是异步操作数据。view 层通过 store.dispath 来分发 action。 getters: 类似vue的计算属性，主要用来过滤一些数据。 modules: 项目特别复杂的时候，可以让每一个模块拥有自己的state、mutation、action、getters，使得结构非常清晰，方便管理。 状态 - state state保存应用状态 1export default new Vuex.Store(&#123; state: &#123; counter:0 &#125;,&#125;) 状态变更 - mutations 1mutations用于修改状态，store.js 12345678export default new Vuex.Store(&#123; mutations: &#123; add(state) &#123; state.counter++ &#125; &#125; &#125;) 派生状态 - getters 从state派生出新状态，类似计算属性 1234567export default new Vuex.Store(&#123; getters: &#123; doubleCounter(state) &#123; // 计算剩余数量 return state.counter * 2; &#125; &#125; &#125;) 动作 - actions 加业务逻辑，类似于controller 123456789export default new Vuex.Store(&#123; actions: &#123; add(&#123; commit &#125;) &#123; setTimeout(() = &gt;&#123;&#125; &#125; &#125;) 测试代码: 123&lt;p @click=&quot;$store.commit(&#x27;add&#x27;)&quot;&gt;counter: &#123;&#123;$store.state.counter&#125;&#125;&lt;/p&gt;&lt;p @click=&quot;$store.dispatch(&#x27;add&#x27;)&quot;&gt;async counter: &#123;&#123;$store.state.counter&#125;&#125;&lt;/p&gt;&lt;p&gt;double:&#123;&#123;$store.getters.doubleCounter&#125;&#125;&lt;/p&gt; vuex原理解析 实现一个插件:声明Store类，挂载$store &#96;&#96;&#96;Store 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283 具体实现: - 创建响应式的`state`，保存`mutations`、`actions`和`getters` - 实现`commit`根据用户传入`type`执行对应`mutation` - 实现`dispatch`根据用户传入`type`执行对应`action`，同时传递上下文 - 实现`getters`，按照`getters`定义对`state`做派生```js// 目标1：实现Store类，管理state（响应式的），commit方法和dispatch方法// 目标2：封装一个插件，使用更容易使用let Vue;class Store &#123; constructor(options) &#123; // 定义响应式的state // this.$store.state.xx // 借鸡生蛋 this._vm = new Vue(&#123; data: &#123; $$state: options.state &#125; &#125;) this._mutations = options.mutations this._actions = options.actions // 绑定this指向 this.commit = this.commit.bind(this) this.dispatch = this.dispatch.bind(this) &#125; // 只读 get state() &#123; return this._vm._data.$$state &#125; set state(val) &#123; console.error(&#x27;不能直接赋值呀，请换别的方式！！天王盖地虎！！&#x27;); &#125; // 实现commit方法，可以修改state commit(type, payload) &#123; // 拿出mutations中的处理函数执行它 const entry = this._mutations[type] if (!entry) &#123; console.error(&#x27;未知mutaion类型&#x27;); return &#125; entry(this.state, payload) &#125; dispatch(type, payload) &#123; const entry = this._actions[type] if (!entry) &#123; console.error(&#x27;未知action类型&#x27;); return &#125; // 上下文可以传递当前store实例进去即可 entry(this, payload) &#125;&#125;function install(_Vue)&#123; Vue = _Vue // 混入store实例 Vue.mixin(&#123; beforeCreate() &#123; if (this.$options.store) &#123; Vue.prototype.$store = this.$options.store &#125; &#125; &#125;)&#125;// &#123; Store, install &#125;相当于Vuex// 它必须实现install方法export default &#123; Store, install &#125;","categories":[{"name":"vue","slug":"vue","permalink":"http://example.com/categories/vue/"}],"tags":[{"name":"vue","slug":"vue","permalink":"http://example.com/tags/vue/"}]},{"title":"v-if和v-for不要一起使用","slug":"v-if和v-for不要一起使用","date":"2018-04-03T03:33:04.000Z","updated":"2022-05-30T02:55:01.251Z","comments":true,"path":"2018/04/03/v-if和v-for不要一起使用/","link":"","permalink":"http://example.com/2018/04/03/v-if%E5%92%8Cv-for%E4%B8%8D%E8%A6%81%E4%B8%80%E8%B5%B7%E4%BD%BF%E7%94%A8/","excerpt":"","text":"一、作用v-if 指令用于条件性地渲染一块内容。这块内容只会在指令的表达式返回 true值的时候被渲染 v-for 指令基于一个数组来渲染一个列表。v-for 指令需要使用 item in items 形式的特殊语法，其中 items 是源数据数组或者对象，而 item 则是被迭代的数组元素的别名 在 v-for 的时候，建议设置key值，并且保证每个key值是独一无二的，这便于diff算法进行优化 两者在用法上 12345&lt;Modal v-if=&quot;isShow&quot; /&gt;&lt;li v-for=&quot;item in items&quot; :key=&quot;item.id&quot;&gt; &#123;&#123; item.label &#125;&#125;&lt;/li&gt; 二、优先级v-if与v-for都是vue模板系统中的指令 在vue模板编译的时候，会将指令系统转化成可执行的render函数 编写一个p标签，同时使用v-if与 v-for 12345&lt;div id=&quot;app&quot;&gt; &lt;p v-if=&quot;isShow&quot; v-for=&quot;item in items&quot;&gt; &#123;&#123; item.title &#125;&#125; &lt;/p&gt;&lt;/div&gt; 创建vue实例，存放isShow与items数据 123456789101112131415const app = new Vue(&#123; el: &quot;#app&quot;, data() &#123; return &#123; items: [ &#123; title: &quot;foo&quot; &#125;, &#123; title: &quot;baz&quot; &#125;] &#125; &#125;, computed: &#123; isShow() &#123; return this.items &amp;&amp; this.items.length &gt; 0 &#125; &#125;&#125;) 模板指令的代码都会生成在render函数中，通过app.$options.render就能得到渲染函数 123456ƒ anonymous() &#123; with (this) &#123; return _c(&#x27;div&#x27;, &#123; attrs: &#123; &quot;id&quot;: &quot;app&quot; &#125; &#125;, _l((items), function (item) &#123; return (isShow) ? _c(&#x27;p&#x27;, [_v(&quot;\\n&quot; + _s(item.title) + &quot;\\n&quot;)]) : _e() &#125;), 0) &#125;&#125; _l是vue的列表渲染函数，函数内部都会进行一次if判断 初步得到结论：v-for优先级是比v-if高 再将v-for与v-if置于不同标签 12345&lt;div id=&quot;app&quot;&gt; &lt;template v-if=&quot;isShow&quot;&gt; &lt;p v-for=&quot;item in items&quot;&gt;&#123;&#123;item.title&#125;&#125;&lt;/p&gt; &lt;/template&gt;&lt;/div&gt; 再输出下render函数 123456ƒ anonymous() &#123; with(this)&#123;return _c(&#x27;div&#x27;,&#123;attrs:&#123;&quot;id&quot;:&quot;app&quot;&#125;&#125;, [(isShow)?[_v(&quot;\\n&quot;), _l((items),function(item)&#123;return _c(&#x27;p&#x27;,[_v(_s(item.title))])&#125;)]:_e()],2)&#125;&#125; 这时候我们可以看到，v-for与v-if作用在不同标签时候，是先进行判断，再进行列表的渲染 我们再在查看下vue源码 源码位置：\\vue-dev\\src\\compiler\\codegen\\index.js 1234567891011121314151617181920export function genElement (el: ASTElement, state: CodegenState): string &#123; if (el.parent) &#123; el.pre = el.pre || el.parent.pre &#125; if (el.staticRoot &amp;&amp; !el.staticProcessed) &#123; return genStatic(el, state) &#125; else if (el.once &amp;&amp; !el.onceProcessed) &#123; return genOnce(el, state) &#125; else if (el.for &amp;&amp; !el.forProcessed) &#123; return genFor(el, state) &#125; else if (el.if &amp;&amp; !el.ifProcessed) &#123; return genIf(el, state) &#125; else if (el.tag === &#x27;template&#x27; &amp;&amp; !el.slotTarget &amp;&amp; !state.pre) &#123; return genChildren(el, state) || &#x27;void 0&#x27; &#125; else if (el.tag === &#x27;slot&#x27;) &#123; return genSlot(el, state) &#125; else &#123; // component or element ...&#125; 在进行if判断的时候，v-for是比v-if先进行判断 最终结论：v-for优先级比v-if高 三、注意事项 永远不要把 v-if 和 v-for 同时用在同一个元素上，带来性能方面的浪费（每次渲染都会先循环再进行条件判断） 如果避免出现这种情况，则在外层嵌套template（页面渲染不生成dom节点），在这一层进行v-if判断，然后在内部进行v-for循环 123&lt;template v-if=&quot;isShow&quot;&gt; &lt;p v-for=&quot;item in items&quot;&gt;&lt;/template&gt; 如果条件出现在循环内部，可通过计算属性computed提前过滤掉那些不需要显示的项 1234567computed: &#123; items: function() &#123; return this.list.filter(function (item) &#123; return item.isShow &#125;) &#125;&#125;","categories":[{"name":"vue","slug":"vue","permalink":"http://example.com/categories/vue/"}],"tags":[{"name":"vue","slug":"vue","permalink":"http://example.com/tags/vue/"}]},{"title":"v-show和v-if的区别","slug":"v-show和v-if的区别","date":"2018-04-03T02:21:06.000Z","updated":"2022-05-30T02:54:44.353Z","comments":true,"path":"2018/04/03/v-show和v-if的区别/","link":"","permalink":"http://example.com/2018/04/03/v-show%E5%92%8Cv-if%E7%9A%84%E5%8C%BA%E5%88%AB/","excerpt":"","text":"一、v-show与v-if的共同点在 vue 中 v-show 与 v-if 的作用效果是相同的(不含v-else)，都能控制元素在页面是否显示 在用法上也是相同的 12&lt;Model v-show=&quot;isShow&quot; /&gt;&lt;Model v-if=&quot;isShow&quot; /&gt; 当表达式为true的时候，都会占据页面的位置 当表达式都为false时，都不会占据页面位置 二、v-show与v-if的区别控制手段： v-show隐藏则是为该元素添加css--display:none，dom元素依旧还在。 v-if显示隐藏是将dom元素整个添加或删除 编译过程： v-if切换有一个局部编译&#x2F;卸载的过程，切换过程中合适地销毁和重建内部的事件监听和子组件； v-show只是简单的基于css切换 编译条件： v-if是真正的条件渲染，它会确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建。只有渲染条件为假时，并不做操作，直到为真才渲染。 v-show 由false变为true的时候不会触发组件的生命周期 v-if由false变为true的时候，触发组件的beforeCreate、create、beforeMount、mounted钩子，由true变为false的时候触发组件的beforeDestory、destoryed方法 性能消耗：v-if有更高的切换消耗；v-show有更高的初始渲染消耗； 三、v-show与v-if原理分析具体解析流程这里不展开讲，大致流程如下 将模板template转为ast结构的JS对象 用ast得到的JS对象拼装render和staticRenderFns函数 render和staticRenderFns函数被调用后生成虚拟VNODE节点，该节点包含创建DOM节点所需信息 vm.patch函数通过虚拟DOM算法利用VNODE节点创建真实DOM节点 v-show原理不管初始条件是什么，元素总是会被渲染 我们看一下在vue中是如何实现的 代码很好理解，有transition就执行transition，没有就直接设置display属性 12345678910111213141516171819202122// https://github.com/vuejs/vue-next/blob/3cd30c5245da0733f9eb6f29d220f39c46518162/packages/runtime-dom/src/directives/vShow.tsexport const vShow: ObjectDirective&lt;VShowElement&gt; = &#123; beforeMount(el, &#123; value &#125;, &#123; transition &#125;) &#123; el._vod = el.style.display === &#x27;none&#x27; ? &#x27;&#x27; : el.style.display if (transition &amp;&amp; value) &#123; transition.beforeEnter(el) &#125; else &#123; setDisplay(el, value) &#125; &#125;, mounted(el, &#123; value &#125;, &#123; transition &#125;) &#123; if (transition &amp;&amp; value) &#123; transition.enter(el) &#125; &#125;, updated(el, &#123; value, oldValue &#125;, &#123; transition &#125;) &#123; // ... &#125;, beforeUnmount(el, &#123; value &#125;) &#123; setDisplay(el, value) &#125;&#125; v-if原理v-if在实现上比v-show要复杂的多，因为还有else else-if 等条件需要处理，这里我们也只摘抄源码中处理 v-if 的一小部分 返回一个node节点，render函数通过表达式的值来决定是否生成DOM 1234567891011121314151617181920212223242526// https://github.com/vuejs/vue-next/blob/cdc9f336fd/packages/compiler-core/src/transforms/vIf.tsexport const transformIf = createStructuralDirectiveTransform( /^(if|else|else-if)$/, (node, dir, context) =&gt; &#123; return processIf(node, dir, context, (ifNode, branch, isRoot) =&gt; &#123; // ... return () =&gt; &#123; if (isRoot) &#123; ifNode.codegenNode = createCodegenNodeForBranch( branch, key, context ) as IfConditionalExpression &#125; else &#123; // attach this branch&#x27;s codegen node to the v-if root. const parentCondition = getParentCondition(ifNode.codegenNode!) parentCondition.alternate = createCodegenNodeForBranch( branch, key + ifNode.branches.length - 1, context ) &#125; &#125; &#125;) &#125;) 四、v-show与v-if的使用场景v-if 与 v-show 都能控制dom元素在页面的显示 v-if 相比 v-show 开销更大的（直接操作dom节点增加与删除） 如果需要非常频繁地切换，则使用 v-show 较好 如果在运行时条件很少改变，则使用 v-if 较好","categories":[{"name":"vue","slug":"vue","permalink":"http://example.com/categories/vue/"}],"tags":[{"name":"vue","slug":"vue","permalink":"http://example.com/tags/vue/"}]},{"title":"vue生命周期","slug":"vue生命周期","date":"2018-04-01T14:49:10.000Z","updated":"2022-05-30T02:11:10.048Z","comments":true,"path":"2018/04/01/vue生命周期/","link":"","permalink":"http://example.com/2018/04/01/vue%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/","excerpt":"","text":"一、生命周期是什么生命周期（Life Cycle）的概念应用很广泛，特别是在政治、经济、环境、技术、社会等诸多领域经常出现，其基本涵义可以通俗地理解为“从摇篮到坟墓”（Cradle-to-Grave）的整个过程在Vue中实例从创建到销毁的过程就是生命周期，即指从创建、初始化数据、编译模板、挂载Dom→渲染、更新→渲染、卸载等一系列过程我们可以把组件比喻成工厂里面的一条流水线，每个工人（生命周期）站在各自的岗位，当任务流转到工人身边的时候，工人就开始工作PS：在Vue生命周期钩子会自动绑定 this 上下文到实例中，因此你可以访问数据，对 property 和方法进行运算这意味着你不能使用箭头函数来定义一个生命周期方法 (例如 created: () =&gt; this.fetchTodos()) 二、生命周期有哪些Vue生命周期总共可以分为8个阶段：创建前后, 载入前后,更新前后,销毁前销毁后，以及一些特殊场景的生命周期 生命周期 描述 beforeCreate 组件实例被创建之初 created 组件实例已经完全创建 beforeMount 组件挂载之前 mounted 组件挂载到实例上去之后 beforeUpdate 组件数据发生变化，更新之前 updated 组件数据更新之后 beforeDestroy 组件实例销毁之前 destroyed 组件实例销毁之后 activated keep-alive 缓存的组件激活时 deactivated keep-alive 缓存的组件停用时调用 errorCaptured 捕获一个来自子孙组件的错误时被调用 三、生命周期整体流程Vue生命周期流程图 具体分析beforeCreate -&gt; created 初始化vue实例，进行数据观测 created 完成数据观测，属性与方法的运算，watch、event事件回调的配置 可调用methods中的方法，访问和修改data数据触发响应式渲染dom，可通过computed和watch完成数据计算 此时vm.$el 并没有被创建 created -&gt; beforeMount 判断是否存在el选项，若不存在则停止编译，直到调用vm.$mount(el)才会继续编译 优先级：render &gt; template &gt; outerHTML vm.el获取到的是挂载DOM的 beforeMount 在此阶段可获取到vm.el 此阶段vm.el虽已完成DOM初始化，但并未挂载在el选项上 beforeMount -&gt; mounted 此阶段vm.el完成挂载，vm.$el生成的DOM替换了el选项所对应的DOM mounted vm.el已完成DOM的挂载与渲染，此刻打印vm.$el，发现之前的挂载点及内容已被替换成新的DOM beforeUpdate 更新的数据必须是被渲染在模板上的（el、template、render之一） 此时view层还未更新 若在beforeUpdate中再次修改数据，不会再次触发更新方法 updated 完成view层的更新 若在updated中再次修改数据，会再次触发更新方法（beforeUpdate、updated） beforeDestroy 实例被销毁前调用，此时实例属性与方法仍可访问 destroyed 完全销毁一个实例。可清理它与其它实例的连接，解绑它的全部指令及事件监听器 并不能清除DOM，仅仅销毁实例 使用场景分析 生命周期 描述 beforeCreate 执行时组件实例还未创建，通常用于插件开发中执行一些初始化任务 created 组件初始化完毕，各种数据可以使用，常用于异步数据获取 beforeMount 未执行渲染、更新，dom未创建 mounted 初始化结束，dom已创建，可用于获取访问数据和dom元素 beforeUpdate 更新前，可用于获取更新前各种状态 updated 更新后，所有状态已是最新 beforeDestroy 销毁前，可用于一些定时器或订阅的取消 destroyed 组件已销毁，作用同上 四、数据请求在created和mouted的区别created是在组件实例一旦创建完成的时候立刻调用，这时候页面dom节点并未生成mounted是在页面dom节点渲染完毕之后就立刻执行的触发时机上created是比mounted要更早的两者相同点：都能拿到实例对象的属性和方法讨论这个问题本质就是触发的时机，放在mounted请求有可能导致页面闪动（页面dom结构已经生成），但如果在页面加载前完成则不会出现此情况建议：放在create生命周期当中","categories":[{"name":"vue","slug":"vue","permalink":"http://example.com/categories/vue/"}],"tags":[{"name":"vue","slug":"vue","permalink":"http://example.com/tags/vue/"}]},{"title":"什么是vue","slug":"什么是vue","date":"2018-03-29T14:25:14.000Z","updated":"2022-05-29T14:42:36.807Z","comments":true,"path":"2018/03/29/什么是vue/","link":"","permalink":"http://example.com/2018/03/29/%E4%BB%80%E4%B9%88%E6%98%AFvue/","excerpt":"","text":"一、Vue是什么Vue.js（&#x2F;vjuː&#x2F;，或简称为Vue）是一个用于创建用户界面的开源JavaScript框架，也是一个创建单页应用（SPA）的Web应用框架。2016年一项针对JavaScript的调查表明，Vue有着89%的开发者满意度。在GitHub上，该项目平均每天能收获95颗星，为Github有史以来星标数第3多的项目同时也是一款流行的JavaScript前端框架，旨在更好地组织与简化Web开发。Vue所关注的核心是MVC模式中的视图层，同时，它也能方便地获取数据更新，并通过组件内部特定的方法实现视图与模型的交互。 1、前端工程化前端工程化，是一种当下流行的软件开发观念。可能很多小伙伴在学习前端的时候，是先从Html、Css、JavaScript开始学起的，在学习和使用的过程中会发现，这样的进行开发需要重复写很多的代码，而且，代码的逻辑关联性较低，还会出现Css或者JavaScript配置文件冲突或者相互之间产生干扰的问题，会给开发以及debug带来很多的问题，可能找半天都没有找到是什么地方错了，总之，比较凌乱。 而前端工程化是为了解决上诉的这些问题，针对具体的生产开发环境而提出的方案。前端工程化包含了：工程化的目的是为了，提高开发效率、保证开发质量。 1）规范化，也就是制定或者约定一个开发规则、开发标准，比如，类的命名规范、制定编码模板代码，等等，提倡约定大于配置（vue、springboot等等当中就有约定大于配置的规范）。 2）可定量的过程化方法，简单来说就是制定衡量整个开发流程和进度的方法。 3）版本控制，来管理代码的更新。 4）开发使用的技术、方法。 2、前后端分离前端：负责View（视图层）和Controller（业务模块流程控制层）。 后端：负责Model层、业务、数据处理等。 这样子的好处，前端UI的设计可以根据业务需求进行修改，而不会干扰，后端的开发，后端可以专注于后端的事情，前端也不用关心后端开发的问题，只需要留有前后端对接的接口就可以了。 3、组件化开发组件化开发，让前端重复的使用的代码可以单独拎出来成为一个组件来供整个项目各个页面的使用，Css、JavaScript的脚本的内容可以限定作用的域，从而大幅度减少了开发的冲突问题。 二、Vue核心特性数据驱动（MVVM)1MVVM表示的是 Model-View-ViewModel Model：模型层，负责处理业务逻辑以及和服务器端进行交互 View：视图层：负责将数据模型转化为UI展示出来，可以简单的理解为HTML页面 ViewModel：视图模型层，用来连接Model和View，是Model和View之间的通信桥梁 组件化1.什么是组件化一句话来说就是把图形、非图形的各种逻辑均抽象为一个统一的概念（组件）来实现开发的模式，在Vue中每一个.vue文件都可以视为一个组件2.组件化的优势 降低整个系统的耦合度，在保持接口不变的情况下，我们可以替换不同的组件快速完成需求，例如输入框，可以替换为日历、时间、范围等组件作具体的实现 调试方便，由于整个系统是通过组件组合起来的，在出现问题的时候，可以用排除法直接移除组件，或者根据报错的组件快速定位问题，之所以能够快速定位，是因为每个组件之间低耦合，职责单一，所以逻辑会比分析整个系统要简单 提高可维护性，由于每个组件的职责单一，并且组件在系统中是被复用的，所以对代码进行优化可获得系统的整体升级 指令系统解释：指令 (Directives) 是带有 v- 前缀的特殊属性作用：当表达式的值改变时，将其产生的连带影响，响应式地作用于 DOM 常用的指令 条件渲染指令 v-if 列表渲染指令v-for 属性绑定指令v-bind 事件绑定指令v-on 双向数据绑定指令v-model","categories":[{"name":"vue","slug":"vue","permalink":"http://example.com/categories/vue/"}],"tags":[{"name":"vue","slug":"vue","permalink":"http://example.com/tags/vue/"}]},{"title":"防抖与节流","slug":"防抖与节流","date":"2018-02-27T07:58:47.000Z","updated":"2022-05-27T08:24:19.863Z","comments":true,"path":"2018/02/27/防抖与节流/","link":"","permalink":"http://example.com/2018/02/27/%E9%98%B2%E6%8A%96%E4%B8%8E%E8%8A%82%E6%B5%81/","excerpt":"","text":"一、是什么本质上是优化高频率执行代码的一种手段 如：浏览器的 resize、scroll、keypress、mousemove 等事件在触发时，会不断地调用绑定在事件上的回调函数，极大地浪费资源，降低前端性能 为了优化体验，需要对这类事件进行调用次数的限制，对此我们就可以采用 防抖（debounce） 和 节流（throttle） 的方式来减少调用频率 定义 节流: n 秒内只运行一次，若在 n 秒内重复触发，只有一次生效 防抖: n 秒后在执行该事件，若在 n 秒内被重复触发，则重新计时 一个经典的比喻: 想象每天上班大厦底下的电梯。把电梯完成一次运送，类比为一次函数的执行和响应 假设电梯有两种运行策略 debounce 和 throttle，超时设定为15秒，不考虑容量限制 电梯第一个人进来后，15秒后准时运送一次，这是节流 电梯第一个人进来后，等待15秒。如果过程中又有人进来，15秒等待重新计时，直到15秒后开始运送，这是防抖 代码实现节流1234567891011121314151617181920212223242526272829&lt;div id=&quot;div1&quot; draggable=&quot;true&quot;&gt;可拖拽&lt;div&gt;&lt;style&gt;#div1 &#123; border: 1px solid #ccc; width: 200px; height: 100px;&#125;&lt;/style&gt; &lt;script&gt; // 节流 const div1 = document.getElementById(&#x27;div1&#x27;) function throttle(fn, delay = 500) &#123; let timer = null return function () &#123; if (timer) &#123; return &#125; timer = setTimeout(() =&gt; &#123; fn.apply(this, arguments) timer = null &#125;, delay) &#125; &#125; div1.addEventListener(&#x27;drag&#x27;, throttle(function (e) &#123; console.log(e.offsetX, e.offsetY) &#125;)) &lt;/script&gt; 防抖123456789101112131415161718192021222324&lt;input type=&quot;text&quot; id=&quot;input1&quot;&gt; &lt;script&gt; // 防抖 const input1 = document.getElementById(&#x27;input1&#x27;) function debounce(fn, delay = 500) &#123; let timer = null return function () &#123; if (timer) &#123; clearTimeout(timer) &#125; timer = setTimeout(() =&gt; &#123; fn.apply(this, arguments) timer = null &#125;, delay) &#125; &#125; input1.addEventListener(&#x27;keyup&#x27;, debounce(function () &#123; console.log(input1.value) &#125;, 600)) &lt;/script&gt; 二、区别相同点： 都可以通过使用 setTimeout 实现 目的都是，降低回调执行频率，节省计算资源 不同点： 函数防抖，在一段连续操作结束后，处理回调，利用clearTimeout和 setTimeout实现。函数节流，在一段连续操作中，每一段时间只执行一次，频率较高的事件中使用来提高性能 函数防抖关注一定时间连续触发的事件，只在最后执行一次，而函数节流一段时间内只执行一次 三、应用场景防抖在连续的事件，只需触发一次回调的场景有： 搜索框搜索输入。只需用户最后一次输入完，再发送请求 手机号、邮箱验证输入检测 窗口大小resize。只需窗口调整完成后，计算窗口大小。防止重复渲染。 登录时防止用户多次点击登录，造成重复发送请求 节流在间隔一段时间执行一次回调的场景有： 滚动加载，加载更多或滚到底部监听 搜索框，搜索联想功能","categories":[{"name":"javascript","slug":"javascript","permalink":"http://example.com/categories/javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://example.com/tags/javascript/"}]},{"title":"AJAX","slug":"AJAX","date":"2017-11-04T02:35:00.000Z","updated":"2022-05-28T03:10:26.718Z","comments":true,"path":"2017/11/04/AJAX/","link":"","permalink":"http://example.com/2017/11/04/AJAX/","excerpt":"","text":"AJAX定义ajax全称“Asynchronous Javascript And XML”，是由javascript、xml、XMLHttpRequest组合在一起、能实现异步提交的功能，是一种创建交互式网页应用的网页开发技术。 前后台分离的项目架构 ajax包含哪些技术AJAX:(Asynchronous JavaScript and XML)并不是一项新技术,其实是多种技术的综合，包括Javascript、XHTML和CSS、DOM、XML和XMLHttpRequest。 服务器端语言：服务器需要具备向浏览器发送特定信息的能力。Ajax与服务器端语言无关。 XML (eXtensible Markup Language，可扩展标记语言) 是一种描述数据的格式。AJAX程序需要某种格式化的格式来在服务器和客户端之间传递信息，XML 是其中的一种选择。 XHTMLXHTML（eXtended Hypertext Markup Language,使用扩展超媒体标记语言）和 CSS（Cascading Style Sheet,级联样式单）标准化呈现； DOM（Document Object Model,文档对象模型）实现动态显示和交互； 使用XMLHTTP组件XMLHttpRequest对象进行异步数据读取 使用JavaScript绑定和处理所有数据。 同步和异步同步处理：我们通过实践触发ajax，请求服务器，在这个期间等待服务器处理请求，在这个期间客户端不能做任何处理。当 ajax 执行完毕才会继续执行其他代码。 异步处理：就是我们通过事件触发到ajax，请求服务器，在这个期间无论服务器有没有响应，客户端的其他代码一样可以运行。 同步机制流程图 Ajax异步交互原理AJAX采用异步交互过程。AJAX在用户与服务器之间引入一个中间媒介，从而消除了网络交互过程中的处理—等待—处理—等待缺点。 用户的浏览器在执行任务时即装载了AJAX引擎。AJAX引擎用JavaScript语言编写，通常藏在一个隐藏的框架中。它负责编译用户界面及与服务器之间的交互。 AJAX引擎允许用户与应用软件之间的交互过程异步进行，独立于用户与网络服务器间的交流。现在，可以用Javascript调用AJAX引擎来代替产生一个HTTP的用户动作，内存中的数据编辑、页面导航、数据校验这些不需要重新载入整个页面的需求可以交给AJAX来执行。 使用AJAX，可以为开发人员、终端用户带来可见的便捷： XMLHttpRequst对象XMLHttpRequest是XMLHTTP组件的对象，通过这个对象，AJAX可以像桌面应用程序一样只同服务器进行数据层面的交换，而不用每次都刷新界面，也不用每次将数据处理的工作都交给服务器来做；这样既减轻了服务器负担又加快了响应速度、缩短了用户等待的时间。 XMLHttpRequest最早是在IE5中以ActiveX组件的形式实现的。非W3C标准。 创建XMLHttpRequest对象（由于非标准所以实现方法不统一） Internet Explorer把XMLHttpRequest实现为一个ActiveX对象 其他浏览器（Firefox、Safari、Opera…）把它实现为一个本地的JavaScript对象。 XMLHttpRequest在不同浏览器上的实现是兼容的，所以可以用同样的方式访问XMLHttpRequest实例的属性和方法，而不论这个实例创建的方法是什么。 12345678910111213141516//兼容性写法function createXmlHttpRequest()&#123; var xmlHttp; try&#123; //Firefox, Opera 8.0+, Safari xmlHttp=new XMLHttpRequest(); &#125;catch (e)&#123; try&#123; //Internet Explorer xmlHttp=new ActiveXObject(&quot;Msxml2.XMLHTTP&quot;); &#125;catch (e)&#123; try&#123; xmlHttp=new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;); &#125;catch (e)&#123;&#125; &#125; &#125; return xmlHttp; &#125; XMLHttpRequest方法 XMLHttpRequst对象属性 发送请求利用XMLHttpRequest 实例与服务器进行异步通信包含以下3个关键部分： onreadystatechange 事件处理函数 open 方法 send 方法 open(method, url, asynch) XMLHttpRequest 对象的 open 方法允许程序员用一个Ajax调用向服务器发送请求。 method：请求类型，类似 “GET”或”POST”的字符串。若只想从服务器检索一个文件，而不需要发送任何数据，使用GET(可以在GET请求里通过附加在URL上的查询字符串来发送数据，不过数据大小限制为2000个字符)。若需要向服务器发送数据，用POST。 在某些情况下，有些浏览器会把多个XMLHttpRequest请求的结果缓存在同一个URL。如果对每个请求的响应不同，这就会来不好的结果。把当前时间戳追加到URL的最后，就能确保URL的惟一性，从而避免浏览器缓存结果。 onreadystatechange: 该事件处理函数由服务器触发，而不是用户 在 Ajax 执行过程中，服务器会通知客户端当前的通信状态。这依靠更新 XMLHttpRequest 对象的 readyState 来实现。改变 readyState 属性是服务器对客户端连接操作的一种方式。 每次 readyState 属性的改变都会触发 readystatechange事件 参数设置 url：路径字符串，指向你所请求的服务器上的那个文件。可以是绝对路径或相对路径。 async：表示请求是否要异步传输，默认值为true(异步)。指定true，在读取后面的脚本之前，不需要等待服务器的相应。指定false，当脚本处理过程经过这点时，会停下来，一直等到Ajax请求执行完毕再继续执行。 send方法send(data)： open 方法定义了 Ajax 请求的一些细节。send 方法可为已经待命的请求发送指令 data：将要传递给服务器的字符串。 若选用的是 GET 请求，则不会发送任何数据， 给 send 方法传递 null 即可：request.send(null); 当向send()方法提供参数时，要确保open()中指定的方法是POST，如果没有数据作为请求体的一部分发送，则使用null. 完整的 Ajax 的 GET 请求示例： 123456789101112131415const xhr = new XMLHttpRequest()xhr.open(&#x27;GET&#x27;, &#x27;/data/test.json&#x27;, true)xhr.onreadystatechange = function () &#123; if (xhr.readyState === 4) &#123; if (xhr.status === 200) &#123; // console.log( // JSON.parse(xhr.responseText) // ) alert(xhr.responseText) &#125; else if (xhr.status === 404) &#123; console.log(&#x27;404 not found&#x27;) &#125; &#125;&#125;xhr.send(null) 注意：使用get请求时send方法参数时null,如果传值的话，服务器也接收不到 发送Post请求setRequestHeader(header,value)当浏览器向服务器请求页面时，它会伴随这个请求发送一组首部信息。这些首部信息是一系列描述请求的元数据(metadata)。 首部信息用来声明一个请求是 GET 还是 POST。 Ajax 请求中，发送首部信息的工作可以由 setRequestHeader完成参数header： 首部的名字; 参数value：首部的值。 如果用 POST 请求向服务器发送数据，需要将 “Content-type” 的首部设置为 “application&#x2F;x-www-form-urlencoded”.它会告知服务器正在发送数据，并且数据已经符合URL编码了。 该方法必须在open()之后才能调用完整的 Ajax 的 POST 请求示例： 12345678910111213141516171819function ajax(url) &#123; const p = new Promise((resolve, reject) =&gt; &#123; const xhr = new XMLHttpRequest() xhr.open(&#x27;POST&#x27;, url, true) xhr.onreadystatechange = function () &#123; if (xhr.readyState === 4) &#123; if (xhr.status === 200) &#123; resolve( JSON.parse(xhr.responseText) ) &#125; else if (xhr.status === 404 || xhr.status === 500) &#123; reject(new Error(&#x27;404 not found&#x27;)) &#125; &#125; &#125; xhr.send(null) &#125;) return p&#125; 接收数据的方法和属性用XMLHttpRequest的方法可向服务器发送请求。在Ajax处理过程中，XMLHttpRequest的如下属性可被服务器更改： readyState status responseText responseXML readyState（请求状态）readyState 属性表示Ajax请求的当前状态。它的值用数字代表。 0 代表未初始化。 还没有调用 open 方法 1 代表正在加载。 open 方法已被调用，但 send 方法还没有被调用 2 代表已加载完毕。send 已被调用。请求已经开始 3 代表交互中。服务器正在发送响应 4 代表完成。响应发送完毕 每次 readyState 值的改变，都会触发 readystatechange 事件。如果把 onreadystatechange 事件处理函数赋给一个函数，那么每次 readyState 值的改变都会引发该函数的执行。 readyState 值的变化会因浏览器的不同而有所差异。但是，当请求结束的时候，每个浏览器都会把 readyState 的值统一设为 4。 status（服务器状态码）服务器发送的每一个响应也都带有首部信息。三位数的状态码是服务器发送的响应中最重要的首部信息，并且属于超文本传输协议中的一部分。 在 XMLHttpRequest 对象中，服务器发送的状态码都保存在 status 属性里。通过把这个值和 200 或 304 比较，可以确保服务器是否已发送了一个成功的响应。 常用状态码及其含义： 404 没找到页面(not found) 403 禁止访问(forbidden) 500 内部服务器出错(internal service error) 200 一切正常(ok) 304 没有被修改(not modified)(服务器返回304状态，表示源文件没有被修改 ) responseTextXMLHttpRequest 的 responseText 属性包含了从服务器发送的数据。它是一个HTML,XML或普通文本，这取决于服务器发送的内容。 当 readyState 属性值变成 4 时, responseText 属性才可用，表明 Ajax 请求已经结束。 1234567891011//指定响应处理函数XMLHttpReq.onreadystatechange=function()&#123; //判断对象状态 4代表完成 if(XMLHttpReq.readyState==4)&#123; //信息已经成功返回，开始处理信息 if(XMLHttpReq.status==200 || XMLHttpReq.status==304)&#123; // 开始处理信息 alert(XMLHttpReq.responseText); &#125; &#125;&#125; 两种数据格式XMLHttpRequest对成功返回的信息有两种处理方式： responseText：将传回的信息当字符串使用； responseXML：将传回的信息当XML文档使用，可以用DOM处理。 如果服务器返回的是 XML， 那么数据将储存在 responseXML 属性中只用服务器发送了带有正确首部信息的数据时， responseXML 属性才是可用的。 MIME 类型必须为 text&#x2F;xml 12345678//处理返回信息的函数function processResponse()&#123; if(XMLHttpReq.readyState==4)&#123; //判断对象状态 4代表完成 if(XMLHttpReq.status==200)&#123; //信息已经成功返回，开始处理信息 document.getElementById(&quot;chatArea&quot;).value=XMLHttpReq.responseText; &#125; &#125;&#125; get和post区别","categories":[{"name":"AJAX","slug":"AJAX","permalink":"http://example.com/categories/AJAX/"}],"tags":[{"name":"AJAX","slug":"AJAX","permalink":"http://example.com/tags/AJAX/"}]},{"title":"flex布局","slug":"flex布局","date":"2017-10-15T03:45:54.000Z","updated":"2022-05-30T06:04:13.274Z","comments":true,"path":"2017/10/15/flex布局/","link":"","permalink":"http://example.com/2017/10/15/flex%E5%B8%83%E5%B1%80/","excerpt":"","text":"一、是什么Flexible Box 简称 flex，意为”弹性布局”，可以简便、完整、响应式地实现各种页面布局 采用Flex布局的元素，称为flex容器container 它的所有子元素自动成为容器成员，称为flex项目item 容器中默认存在两条轴，主轴和交叉轴，呈90度关系。项目默认沿主轴排列，通过flex-direction来决定主轴的方向 每根轴都有起点和终点，这对于元素的对齐非常重要 二、属性关于flex常用的属性，我们可以划分为容器属性和容器成员属性 容器属性有： flex-direction flex-wrap flex-flow justify-content align-items align-content flex-direction决定主轴的方向(即项目的排列方向) 123.container &#123; flex-direction: row | row-reverse | column | column-reverse; &#125; 属性对应如下： row（默认值）：主轴为水平方向，起点在左端 row-reverse：主轴为水平方向，起点在右端 column：主轴为垂直方向，起点在上沿。 column-reverse：主轴为垂直方向，起点在下沿 如下图所示： flex-wrap弹性元素永远沿主轴排列，那么如果主轴排不下，通过flex-wrap决定容器内项目是否可换行 123.container &#123; flex-wrap: nowrap | wrap | wrap-reverse;&#125; 属性对应如下： nowrap（默认值）：不换行 wrap：换行，第一行在下方 wrap-reverse：换行，第一行在上方 默认情况是不换行，但这里也不会任由元素直接溢出容器，会涉及到元素的弹性伸缩 flex-flow是flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap 123.box &#123; flex-flow: &lt;flex-direction&gt; || &lt;flex-wrap&gt;;&#125; justify-content定义了项目在主轴上的对齐方式 123.box &#123; justify-content: flex-start | flex-end | center | space-between | space-around;&#125; 属性对应如下： flex-start（默认值）：左对齐 flex-end：右对齐 center：居中 space-between：两端对齐，项目之间的间隔都相等 space-around：两个项目两侧间隔相等 效果图如下： align-items定义项目在交叉轴上如何对齐 123.box &#123; align-items: flex-start | flex-end | center | baseline | stretch;&#125; 属性对应如下： flex-start：交叉轴的起点对齐 flex-end：交叉轴的终点对齐 center：交叉轴的中点对齐 baseline: 项目的第一行文字的基线对齐 stretch（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度 align-content定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用 123.box &#123; align-content: flex-start | flex-end | center | space-between | space-around | stretch;&#125; 属性对应如吓： flex-start：与交叉轴的起点对齐 flex-end：与交叉轴的终点对齐 center：与交叉轴的中点对齐 space-between：与交叉轴两端对齐，轴线之间的间隔平均分布 space-around：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍 stretch（默认值）：轴线占满整个交叉轴 效果图如下： 容器成员属性如下： order flex-grow flex-shrink flex-basis flex align-self order定义项目的排列顺序。数值越小，排列越靠前，默认为0 123.item &#123; order: &lt;integer&gt;;&#125; flex-grow上面讲到当容器设为flex-wrap: nowrap;不换行的时候，容器宽度有不够分的情况，弹性元素会根据flex-grow来决定 定义项目的放大比例（容器宽度&gt;元素总宽度时如何伸展） 默认为0，即如果存在剩余空间，也不放大 123.item &#123; flex-grow: &lt;number&gt;;&#125; 如果所有项目的flex-grow属性都为1，则它们将等分剩余空间（如果有的话） 如果一个项目的flex-grow属性为2，其他项目都为1，则前者占据的剩余空间将比其他项多一倍 弹性容器的宽度正好等于元素宽度总和，无多余宽度，此时无论flex-grow是什么值都不会生效 flex-shrink定义了项目的缩小比例（容器宽度&lt;元素总宽度时如何收缩），默认为1，即如果空间不足，该项目将缩小 123.item &#123; flex-shrink: &lt;number&gt;; /* default 1 */&#125; 如果所有项目的flex-shrink属性都为1，当空间不足时，都将等比例缩小 如果一个项目的flex-shrink属性为0，其他项目都为1，则空间不足时，前者不缩小 在容器宽度有剩余时，flex-shrink也是不会生效的 flex-basis设置的是元素在主轴上的初始尺寸，所谓的初始尺寸就是元素在flex-grow和flex-shrink生效前的尺寸 浏览器根据这个属性，计算主轴是否有多余空间，默认值为auto，即项目的本来大小，如设置了width则元素尺寸由width/height决定（主轴方向），没有设置则由内容决定 123.item &#123; flex-basis: &lt;length&gt; | auto; /* default auto */&#125; 当设置为0的是，会根据内容撑开 它可以设为跟width或height属性一样的值（比如350px），则项目将占据固定空间 flexflex属性是flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto，也是比较难懂的一个复合属性 123.item &#123; flex: none | [ &lt;&#x27;flex-grow&#x27;&gt; &lt;&#x27;flex-shrink&#x27;&gt;? || &lt;&#x27;flex-basis&#x27;&gt; ]&#125; 一些属性有： flex: 1 &#x3D; flex: 1 1 0% flex: 2 &#x3D; flex: 2 1 0% flex: auto &#x3D; flex: 1 1 auto flex: none &#x3D; flex: 0 0 auto，常用于固定尺寸不伸缩 flex:1 和 flex:auto 的区别，可以归结于flex-basis:0和flex-basis:auto的区别 当设置为0时（绝对弹性元素），此时相当于告诉flex-grow和flex-shrink在伸缩的时候不需要考虑我的尺寸 当设置为auto时（相对弹性元素），此时则需要在伸缩时将元素尺寸纳入考虑 注意：建议优先使用这个属性，而不是单独写三个分离的属性，因为浏览器会推算相关值 align-self允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性 默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch 123.item &#123; align-self: auto | flex-start | flex-end | center | baseline | stretch;&#125; 效果图如下： 三、应用场景在以前的文章中，我们能够通过flex简单粗暴的实现元素水平垂直方向的居中，以及在两栏三栏自适应布局中通过flex完成，这里就不再展开代码的演示 包括现在在移动端、小程序这边的开发，都建议使用flex进行布局","categories":[{"name":"css","slug":"css","permalink":"http://example.com/categories/css/"}],"tags":[{"name":"css","slug":"css","permalink":"http://example.com/tags/css/"}]},{"title":"BOM","slug":"BOM","date":"2017-08-02T00:06:25.000Z","updated":"2022-05-28T03:18:50.715Z","comments":true,"path":"2017/08/02/BOM/","link":"","permalink":"http://example.com/2017/08/02/BOM/","excerpt":"","text":"BOM定义BOM（Browser Object Model）即浏览器对象模型。 BOM提供了独立于内容而与浏览器窗口进行交互的对象； 由于BOM主要用于管理窗口与窗口之间的通讯，因此其核心对象是window； BOM由一系列相关的对象构成，并且每个对象都提供了很多方法与属性； BOM组成 window：代表整个浏览器窗口） Navigator：代表浏览器当前的信息； Location：代表浏览器当前的地址信息 History：代表浏览器的历史信息 Screen：代表用户的屏幕信息 Window对象BOM的核心是window对象,表示浏览器的实例。window对象在浏览器中有两重身份，一个是ECMAScript中的Global对象，另一个就是浏览器窗口的JavaScript接口。这意味着网页中定义的所有对象、变量和函数都以window作为其Global对象，都可以访问其上定义的parseInt()等全局方法。 Global作用域因为window对象被复用为ECMAScript的Global对象，所以通过var声明的所有全局变量和函数都会变成window对象的属性和方法。 12345var age = 29;var sayAge = () =&gt;alert(this.age);alert(window.age);sayAge();window.sayAge(); 这里，变量age和函数sayAge()被定义在全局作用域中，它们自动成为了window对象的成员。因此，变量age可以通过window.age来访问，而函数sayAge()也可以通过window.sayAge()来访问。因为sayAge()存在于全局作用域，this.age映射到window.age，所以就可以显示正确的结果了。 如果在这里使用let或const替代var，则不会把变量添加给全局对象: 12345let age = 29;const sayAge = () =&gt; alert(this.age);alert(window.age); // undefinedsayAge(); // undefinedwindow.sayAge(); // TypeError: window.sayAge is not a function 导航与打开新窗口window.open()方法可以用于导航到指定URL，也可以用于打开新浏览器窗口。这个方法接收4个参数：要加载的URL、目标窗口、特性字符串和表示新窗口在浏览器历史记录中是否替代当前加载页面的布尔值。通常，调用这个方法时只传前3个参数，最后一个参数只有在不打开新窗口时才会使用。 如果window.open()的第二个参数是一个已经存在的窗口或窗格（frame）的名字，则会在对应的窗口或窗格中打开URL。下面是一个例子： 1window.open(&quot;http://www.wrox.com/&quot;, &quot;topFrame&quot;); 执行这行代码的结果就如同用户点击了一个href属性为”http://www.wrox.com&quot;，target属性为&quot;topFrame&quot;的链接。如果有一个窗口名叫&quot;topFrame&quot;，则这个窗口就会打开这个URL；否则就会打开一个新窗口并将其命名为&quot;topFrame&quot;。第二个参数也可以是一个特殊的窗口名，比如_self、_parent、_top或_blank。 弹出窗口 如果window.open()的第二个参数不是已有窗口，则会打开一个新窗口或标签页。第三个参数，即特性字符串，用于指定新窗口的配置。如果没有传第三个参数，则新窗口（或标签页）会带有所有默认的浏览器特性（工具栏、地址栏、状态栏等都是默认配置）。如果打开的不是新窗口，则忽略第三个参数。 特性字符串是一个逗号分隔的设置字符串，用于指定新窗口包含的特性。下表列出了一些选项。 这些设置需要以逗号分隔的名值对形式出现，其中名值对以等号连接。 来看下面的例子： 1window.open(&quot;http://www.wrox.com/&quot;,&quot;wroxWindow&quot;,&quot;height=400,width=400,top=10,left=10,resizable=yes&quot;); 这行代码会打开一个可缩放的新窗口，大小为400像素×400像素，位于离屏幕左边及顶边各10像素的位置。 window.open()方法返回一个对新建窗口的引用。这个对象与普通window对象没有区别，只是为控制新窗口提供了方便。例如，某些浏览器默认不允许缩放或移动主窗口，但可能允许缩放或移动通过window.open()创建的窗口。跟使用任何window对象一样，可以使用这个对象操纵新打开的窗口。 123456let wroxWin = window.open(&quot;http://www.wrox.com/&quot;,&quot;wroxWindow&quot;,&quot;height=400,width=400,top=10,left=10,resizable=yes&quot;);// 缩放wroxWin.resizeTo(500, 500);// 移动wroxWin.moveTo(100, 100);wroxWin.close();//关闭新打开的窗口 定时器setTimeout()的参数 code&#x2F;function：必需。要调用一个代码串，也可以是一个函数，或者函数名。 milliseconds：可选。执行或调用 code&#x2F;function 需要等待的时间，以毫秒计。默认为 0。 param1, …：可选，多个。 传给执行函数的其他参数（IE9 及其更早版本不支持该参数）。 使用函数名称 12345678function myFunction() &#123; myVar = setTimeout(alertFunc, 3000);&#125; function alertFunc() &#123; alert(&quot;Hello!&quot;);&#125; 使用匿名函数 12345var myWindow = window.open(&quot;&quot;, &quot;&quot;, &quot;width=200, height=100&quot;);myWindow.document.write(&quot;&lt;p&gt;新窗口&#x27;&lt;/p&gt;&quot;);setTimeout(function()&#123; myWindow.close() &#125;, 3000); 给函数传参 12345678910function alertFunc(r, g)&#123; alert(r + g); &#125;function myStartFunction() &#123; myVar = setTimeout(alertFunc, 2000, &quot;Runoob&quot;, &quot;Google&quot;);&#125;//使用匿名函数function myStartFunction() &#123; myVar = setTimeout(function()&#123; alertFunc(&quot;Runoob&quot;, &quot;Google&quot;); &#125;, 2000);&#125; setTimeout的特点 setTimeout() 方法用于在指定的毫秒数后调用函数或计算表达式。 方法只会被调用一次1000的单位是毫秒，1000毫秒&#x3D;1秒 setInterval()的特点 setInterval() 方法可按照指定的周期来调用函数或计算表达式。 setInterval() 方法会不停地调用函数1000的单位是毫秒，1000毫秒&#x3D;1秒 12345678910111213141516var myVar;function myFunction() &#123; myVar = setTimeout(function()&#123; alert(&quot;Hello&quot;); &#125;, 3000);&#125;function myStopFunction() &#123; clearTimeout(myVar);&#125;var myVar;function myFunction() &#123; myVar = setInterval(function()&#123; alert(&quot;Hello&quot;); &#125;, 3000);&#125; function myStopFunction() &#123; clearInterval(myVar);&#125; clearTimeout():可取消由 setTimeout() 方法设置的定时操作 clearInterval():可取消由 setInterval() 函数设定的定时执行操作 看到了setTimeout函数。 它会在给定的毫秒数之后，调度另一个函数在稍后调用。 有时需要取消调度的函数。可以存储setTimeout的返回值，并将作为参数调用clearTimeout。 12345678let bombTimer = setTimeout(() =&gt; &#123; console.log(&quot;BOOM!&quot;);&#125;, 500);if (Math.random() &lt; 0.5) &#123; // 50% chance console.log(&quot;Defused.&quot;); clearTimeout(bombTimer);&#125; 函数cancelAnimationFrame作用与clearTimeout相同，使用requestAnimationFrame的返回值调用该函数，可以取消帧（假定函数还没有被调用）。 还有setInterval和clearInterval这种相似的函数，用于设置计时器，每隔一定毫秒数重复执行一次。 12345678let ticks = 0;let clock = setInterval(() =&gt; &#123; console.log(&quot;tick&quot;, ticks++); if (ticks == 10) &#123; clearInterval(clock); console.log(&quot;stop.&quot;); &#125;&#125;, 200); 降频某些类型的事件可能会连续、迅速触发多次（例如mousemove和scroll事件）。处理这类事件时，你必须小心谨慎，防止处理任务耗时过长，否则处理器会占据过多事件，导致用户与文档交互变得非常慢。 若你需要在这类处理器中编写一些重要任务，可以使用setTimeout来确保不会频繁进行这些任务。我们通常称之为“事件降频（Debounce）”。有许多方法可以完成该任务。 在第一个示例中，当用户输入某些字符时，我们想要有所反应，但我们不想在每个按键事件中立即处理该任务。当用户输入过快时，我们希望暂停一下然后进行处理。我们不是立即在事件处理器中执行动作，而是设置一个定时器。我们也会清除上一次的定时器（如果有），因此当两个事件触发间隔过短（比定时器延时短），就会取消上一次事件设置的定时器。 123456789&lt;textarea&gt;Type something here...&lt;/textarea&gt;&lt;script&gt; let textarea = document.querySelector(&quot;textarea&quot;); let timeout; textarea.addEventListener(&quot;input&quot;, () =&gt; &#123; clearTimeout(timeout); timeout = setTimeout(() =&gt; console.log(&quot;Typed!&quot;), 500); &#125;);&lt;/script&gt; 将undefined传递给clearTimeout或在一个已结束的定时器上调用clearTimeout是没有效果的。因此，我们不需要关心何时调用该方法，只需要每个事件中都这样做即可。 如果我们想要保证每次响应之间至少间隔一段时间，但不希望每次事件发生时都重置定时器，而是在一连串事件连续发生时能够定时触发响应，那么我们可以使用一个略有区别的方法来解决问题。例如，我们想要响应&quot;mousemove&quot;事件来显示当前鼠标坐标，但频率只有 250ms。 12345678910111213&lt;script&gt; let scheduled = null; window.addEventListener(&quot;mousemove&quot;, event =&gt; &#123; if (!scheduled) &#123; setTimeout(() =&gt; &#123; document.body.textContent = `Mouse at $&#123;scheduled.pageX&#125;, $&#123;scheduled.pageY&#125;`; scheduled = null; &#125;, 250); &#125; scheduled = event; &#125;);&lt;/script&gt; location对象location是最有用的BOM对象之一，提供了当前窗口中加载文档的信息，以及通常的导航功能。这个对象独特的地方在于，它既是window的属性，也是document的属性。也就是说，window.location和document.location指向同一个对象。location对象不仅保存着当前加载文档的信息，也保存着把URL解析为离散片段后能够通过属性访问的信息。 假设浏览器当前加载的URL是http://foouser:barpassword@www.wrox.com:80/WileyCDA/?q=javascript#contents，location对象的内容如下表所示。 查找字符串location的多数信息都可以通过上面的属性获取。但是URL中的查询字符串并不容易使用。虽然location.search返回了从问号开始直到URL末尾的所有内容，但没有办法逐个访问每个查询参数。下面的函数解析了查询字符串，并返回一个以每个查询参数为属性的对象： 123456789101112131415let getQueryStringArgs = function() &#123; // 取得没有开头问号的查询字符串 let qs = (location.search.length &gt; 0 ? location.search.substring(1) : &quot;&quot;), // 保存数据的对象 args = &#123;&#125;; // 把每个参数添加到 args 对象 for (let item of qs.split(&quot;&amp;&quot;).map(kv =&gt; kv.split(&quot;=&quot;))) &#123; let name = decodeURIComponent(item[0]), value = decodeURIComponent(item[1]); if (name.length) &#123; args[name] = value; &#125; &#125; return args;&#125; 这个函数首先删除了查询字符串开头的问号，当然前提是location.search必须有内容。解析后的参数将被保存到args对象，这个对象以字面量形式创建。接着，先把查询字符串按照&amp;分割成数组，每个元素的形式为name&#x3D;value。for循环迭代这个数组，将每一个元素按照&#x3D;分割成数组，这个数组第一项是参数名，第二项是参数值。参数名和参数值在使用decodeURIComponent()解码后（这是因为查询字符串通常是被编码后的格式）分别保存在name和value变量中。最后，name作为属性而value作为该属性的值被添加到args对象。这个函数可以像下面这样使用： 1234// 假设查询字符串为?q=javascript&amp;num=10let args = getQueryStringArgs();alert(args[&quot;q&quot;]); // &quot;javasalert(args[&quot;num&quot;]); // &quot;10&quot; 操作地址可以通过修改location对象修改浏览器的地址。首先，最常见的是使用assign()方法并传入一个URL，如下所示： 1location.assign(&quot;http://www.wrox.com&quot;) 这行代码会立即启动导航到新URL的操作，同时在浏览器历史记录中增加一条记录。如果给location.href或window.location设置一个URL，也会以同一个URL值调用assign()方法。比如，下面两行代码都会执行与显式调用assign()一样的操作： 12window.location=&quot;http://www.wrox.com&quot;;location.href=&quot;http://www.wrox.com&quot;; 在这3种修改浏览器地址的方法中，设置location.href是最常见的。 修改location对象的属性也会修改当前加载的页面。其中，hash、search、hostname、pathname和port属性被设置为新值之后都会修改当前URL，如下面的例子所示： 1234567891011//假设当前URL为http://www.wrox.com/WileyCDA///把URL修改为http://www.wrox.com/WileyCDA/#section1location.hash=&quot;#section1&quot;;//把URL修改为http://www.wrox.com/WileyCDA/?q=javascriptlocation.search=&quot;?q=javascript&quot;;//把URL修改为http://www.somewhere.com/WileyCDA/location.hostname=&quot;www.somewhere.com&quot;;//把URL修改为http://www.somewhere.com/mydir/location.pathname=&quot;mydir&quot;;//把URL修改为http://www.somewhere.com:8080/WileyCDA/location.port=8080; 除了hash之外，只要修改location的一个属性，就会导致页面重新加载新URL。 注意修改hash的值会在浏览器历史中增加一条新记录。在早期的IE中，点击“后退”和“前进”按钮不会更新hash属性，只有点击包含散列的URL才会更新hash的值。 在以前面提到的方式修改URL之后，浏览器历史记录中就会增加相应的记录。当用户单击“后退”按钮时，就会导航到前一个页面。如果不希望增加历史记录，可以使用replace()方法。这个方法接收一个URL参数，但重新加载后不会增加历史记录。调用replace()之后，用户不能回到前一页。比如下面的例子： 123456789101112&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;title&gt;You won&#x27;t be able to get back here&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;Enjoy this page for a second, because you won&#x27;t be coming back here.&lt;/p&gt;&lt;script&gt; setTimeout(() =&gt; location.replace(&quot;http://www.wrox.com/&quot;), 1000);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 浏览器加载这个页面1秒之后会重定向到www.wrox.com。此时，“后退”按钮是禁用状态，即不能返回这个示例页面，除非手动输入完整的URL。 最后一个修改地址的方法是reload()，它能重新加载当前显示的页面。调用reload()而不传参数，页面会以最有效的方式重新加载。也就是说，如果页面自上次请求以来没有修改过，浏览器可能会从缓存中加载页面。如果想强制从服务器重新加载，可以像下面这样给reload()传个true： location.reload();&#x2F;&#x2F;重新加载，可能是从缓存加载 location.reload(true);&#x2F;&#x2F;重新加载，从服务器加载 脚本中位于reload()调用之后的代码可能执行也可能不执行，这取决于网络延迟和系统资源等因素。为此，最好把reload()作为最后一行代码。 navigator对象navigator是由NetscapeNavigator2最早引入浏览器的，现在已经成为客户端标识浏览器的标准。只要浏览器启用JavaScript，navigator对象就一定存在。但是与其他BOM对象一样，每个浏览器都支持自己的属性。 navigator属性如下表： appCodeName ：返回浏览器的代码名。 appMinorVersion：返回浏览器的次级版本。 appName：返回浏览器的名称。 appVersion ：返回浏览器的平台和版本信息。 browserLanguage ：返回当前浏览器的语言。 cookieEnabled：返回指明浏览器中是否启用 cookie 的布尔值。 cpuClass ：返回浏览器系统的 CPU 等级。 onLine：返回指明系统是否处于脱机模式的布尔值。 platform：返回运行浏览器的操作系统平台。 systemLanguage：返回 OS 使用的默认语言。 userAgent ：返回由客户机发送服务器的 user-agent 头部的值。 userLanguage ：返回 OS 的自然语言设置。 我们使用的比较多的是他的userAgent，经常需要判断的情况有： （1）PC还是移动端 （2）安卓还是IOS （3）浏览器的类型 示例代码： 123456789101112131415161718var browser=&#123; versions:function()&#123; var u = navigator.userAgent, app = navigator.appVersion; return &#123; //移动终端浏览器版本信息 trident: u.indexOf(&#x27;Trident&#x27;) &gt; -1, //IE内核 presto: u.indexOf(&#x27;Presto&#x27;) &gt; -1, //opera内核 webKit: u.indexOf(&#x27;AppleWebKit&#x27;) &gt; -1, //苹果、谷歌内核 gecko: u.indexOf(&#x27;Gecko&#x27;) &gt; -1 &amp;&amp; u.indexOf(&#x27;KHTML&#x27;) == -1, //火狐内核 mobile: !!u.match(/AppleWebKit.*Mobile.*/), //是否为移动终端 ios: !!u.match(/\\(i[^;]+;( U;)? CPU.+Mac OS X/), //ios终端 android: u.indexOf(&#x27;Android&#x27;) &gt; -1 || u.indexOf(&#x27;Linux&#x27;) &gt; -1, //android终端或uc浏览器 iPhone: u.indexOf(&#x27;iPhone&#x27;) &gt; -1 , //是否为iPhone或者QQHD浏览器 iPad: u.indexOf(&#x27;iPad&#x27;) &gt; -1, //是否iPad webApp: u.indexOf(&#x27;Safari&#x27;) == -1 //是否web应该程序，没有头部与底部 &#125;; &#125;(), language:(navigator.browserLanguage || navigator.language).toLowerCase()&#125; screen对象window的另一个属性screen对象，是为数不多的几个在编程中很少用的JavaScript对象。这个对象中保存的纯粹是客户端能力信息，也就是浏览器窗口外面的客户端显示器的信息，比如像素宽度和像素高度。每个浏览器都会在screen对象上暴露不同的属性。 下表总结了这些属性: availHeight 屏幕像素高度减去系统组件高度（只读） availLeft 没有被系统组件占用的屏幕的最左侧像素（只读） availTop 没有被系统组件占用的屏幕的最顶端像素（只读） availWidth 屏幕像素宽度减去系统组件宽度（只读） colorDepth 表示屏幕颜色的位数；多数系统是 32（只读） height 屏幕像素高度 left 当前屏幕左边的像素距离 pixelDepth 屏幕的位深（只读） top 当前屏幕顶端的像素距离 width 屏幕像素宽度 orientation 返回 Screen Orientation API中屏幕的朝向 history对象history对象表示当前窗口首次使用以来用户的导航历史记录。因为history是window的属性，所以每个window都有自己的history对象。出于安全考虑，这个对象不会暴露用户访问过的 URL，但可以通过它在不知道实际URL的情况下前进和后退。 导航go()方法可以在用户历史记录中沿任何方向导航，可以前进也可以后退。这个方法只接收一个参数，这个参数可以是一个整数，表示前进或后退多少步。负值表示在历史记录中后退，而正值表示在历史记录中前进。 下面来看几个例子： 123456// 后退一页history.go(-1);// 前进一页history.go(1);// 前进两页history.go(2); go()有两个简写方法：back()和forward()。顾名思义，这两个方法模拟了浏览器的后退按钮和前进按钮： 1234//后退一页history.back();//前进一页history.forward(); history对象还有一个length属性，表示历史记录中有多个条目。这个属性反映了历史记录的数量，包括可以前进和后退的页面。对于窗口或标签页中加载的第一个页面，history.length等于1。 通过以下方法测试这个值，可以确定用户浏览器的起点是不是你的页面： 123if (history.length == 1)&#123;// 这是用户窗口中的第一个页面&#125; history对象通常被用于创建“后退”和“前进”按钮，以及确定页面是不是用户历史记录中的第一条记录。","categories":[{"name":"BOM","slug":"BOM","permalink":"http://example.com/categories/BOM/"}],"tags":[{"name":"BOM","slug":"BOM","permalink":"http://example.com/tags/BOM/"}]},{"title":"DOM事件","slug":"DOM事件","date":"2017-07-21T13:37:27.000Z","updated":"2022-05-28T02:30:02.728Z","comments":true,"path":"2017/07/21/DOM事件/","link":"","permalink":"http://example.com/2017/07/21/DOM%E4%BA%8B%E4%BB%B6/","excerpt":"","text":"事件DOM事件的定义定义:DOM事件是由DOM中的事件源触发，可以引发事件响应的操作。 DOM事件流事件发生时会在元素节点与根节点之间按照特定的顺序传播，路径经过的所有节点都会收到该事件，这个传播过程即DOM事件流。 DOM标准规定事件流包括三个阶段： 捕获阶段： 事件自上而下传播，从Document根节点到再到 处理阶段： 目标节点（）处理事件的阶段 冒泡阶段： 事件自下而上传播，依次传播回Document根节点。 案例—–DOM事件流 三个逐层嵌套的圆，最里层的圆被点击，事件逐层传播。 123456789101112131415161718192021&lt;div id=&quot;outer&quot;&gt; &lt;div id=&quot;middle&quot;&gt; &lt;div id=&quot;inner&quot;&gt; Click me! &lt;/div&gt; &lt;/div&gt;&lt;/div&gt;&lt;script&gt; var innerCircle = document.getElementById(&#x27;inner&#x27;); innerCircle.onclick = function()&#123; alert(&quot;最内层的圆&quot;); &#125; var middleCircle = document.getElementById(&#x27;middle&#x27;); middleCircle.onclick = function()&#123; alert(&quot;中间层的圆&quot;); &#125; var outerCircle = document.getElementById(&#x27;outer&#x27;); outerCircle.onclick = function()&#123; alert(&quot;最外层的圆&quot;); &#125;&lt;/script&gt; 备注：触发一个DOM事件，会产生一个事件对象；JavaScript通过事件对象获取事件的信息。 事件对象触发DOM事件时，在事件处理函数中产生一个对应的事件对象 事件对象是在触发DOM事件时，在事件处理函数中产生并代表该事件状态的对象。 事件对象包含所有与事件有关的信息，包括导致事件被触发的元素、事件的类型，以及与特定事件相关的其他信息。 事件对象通常用event表示，可以作为参数传递给事件处理函数。 1）标准属性：type ：返回当前 Event 对象表示的事件的名称； bubbles ：返回布尔值，指示事件是否是起泡事件类型； cancelable ：返回布尔值，指示事件是否可拥可取消的默认动作； currentTarget ：返回其事件监听器触发该事件的元素； eventPhase ：返回事件传播的当前阶段； target ：返回触发此事件的元素（事件的目标节点）； timeStamp ：返回事件生成的日期和时间； 2）鼠标&#x2F;键盘属性altKey ：返回当事件被触发时，”ALT” 是否被按下； button ：返回当事件被触发时，哪个鼠标按钮被点击； clientX ：返回当事件被触发时，鼠标指针的水平坐标； clientY ：返回当事件被触发时，鼠标指针的垂直坐标； ctrlKey ：返回当事件被触发时，”CTRL” 键是否被按下； metaKey ：返回当事件被触发时，”meta” 键是否被按下； relatedTarget ：返回与事件的目标节点相关的节点； screenX ：返回当某个事件被触发时，鼠标指针的水平坐标； screenY ：返回当某个事件被触发时，鼠标指针的垂直坐标； shiftKey ：返回当事件被触发时，”SHIFT” 键是否被按下； 内联模式事件绑定直接写在html上 这里button的click事件的绑定直接写在html中 脚本模型脚本模型是通过DOM选择器选中操作元素，单独封装事件操作在Js中，把事件操作与HTML代码分离的一种事件操作形式。 上一节讲了内联模式,内联模式的缺点：函数违反了标记&#x2F;行为展现&#x2F;Javascript分离的层次分离原则。 案例：灯泡点亮 创建html页面，页面内如图有一图片；编写JS代码，给图片增加鼠标移过事件，触发函数；编写JS函数，实现给页面元素属性赋值。 事件函数鼠标事件 鼠标点击 鼠标点击事件包括 4 个：click（单击）、dblclick（双击）、mousedown（按下）和 mouseup（松开）。其中 click 事件类型比较常用，而 mousedown 和 mouseup 事件类型多用在鼠标拖放、拉伸操作中。当这些事件处理函数的返回值为 false 时，会禁止绑定对象的默认行为。 示例 在下面示例中，当定义超链接指向自身时（多在设计过程中 href 属性值暂时使用 “#”或“?”表示），可以取消超链接被单击时的默认行为，即刷新页面。 123456789101112&lt;a name=&quot;tag&quot; id=&quot;tag&quot; href=&quot;#&quot;&gt;a&lt;/a&gt;&lt;script&gt;var a = document.getElementsByTagName(&quot;a&quot;); //获取页面中所有超链接元素for (var i = 0; i &lt; a.length; i ++) &#123; //遍历所有a元素 if ((new RegExp(window.location.href)).test(a[i].href)) &#123; //如果当前超链接href属性中包含本页面的URL信息 a[i].onclick = function () &#123; //则为超链接注册鼠标单击事件 return false; //将禁止超链接的默认行为 &#125; &#125;&#125;&lt;/script&gt; 鼠标移动 mousemove 事件类型是一个实时响应的事件，当鼠标指针的位置发生变化时（至少移动一个像素），就会触发 mousemove 事件。该事件响应的灵敏度主要参考鼠标指针移动速度的快慢以及浏览器跟踪更新的速度。 示例下面示例演示了如何综合应用各种鼠标事件实现页面元素拖放操作的设计过程。实现拖放操作设计需要解决以下几个问题。定义拖放元素为绝对定位以及设计事件的响应过程，这个比较容易实现。 清楚几个坐标概念：按下鼠标时的指针坐标，移动中当前鼠标指针坐标，松开鼠标时的指针坐标，拖放元素的原始坐标，拖动中的元素坐标。 算法设计：按下鼠标时，获取被拖放元素和鼠标指针的位置，在移动中实时计算鼠标偏移的距离，并利用该偏移距离加上被拖放元素的原坐标位置，获得拖放元素的实时坐标。 如下图所示，其中变量 ox 和 oy 分别记录按下鼠标时被拖放元素的纵横坐标值，它们可以通过事件对象的 offsetLeft 和 offsetTop 属性获取。变量 mx 和 my 分别表示按下鼠标时，鼠标指针的坐标位置。而 event.mx 和 event.my 是事件对象的自定义属性，用它们来存储当鼠标移动时鼠标指针的实时位置。 当获取了上面 3 对坐标值之后，就可以动态计算拖动中元素的实时坐标位置，即 x 轴值为 ox+event.mx-mx，y 轴为 oy+event.my-my。当释放鼠标按钮时，就可以释放事件类型，并记下松开鼠标指针时拖动元素的坐标值，以及鼠标指针的位置，留待下一次拖放操作时调用。 整个拖放操作的示例代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;div id=&quot;box&quot; &gt;&lt;/div&gt;&lt;script&gt; // 初始化拖放对象 var box = document.getElementById(&quot;box&quot;); // 获取页面中被拖放元素的引用指针 box.style.position = &quot;absolute&quot;; // 绝对定位 box.style.width = &quot;160px&quot;; // 定义宽度 box.style.height = &quot;120px&quot;; // 定义高度 box.style.backgroundColor = &quot;red&quot;; // 定义背景色 // 初始化变量，标准化事件对象 var mx, my, ox, oy; // 定义备用变量 function e(event)&#123; // 定义事件对象标准化函数 if( ! event)&#123; // 兼容IE浏览器 event = window.event; event.target = event.srcElement; event.layerX = event.offsetX; event.layerY = event.offsetY; &#125; event.mx = event.pageX || event.clientX + document.body.scrollLeft; // 计算鼠标指针的x轴距离 event.my = event.pageY || event.clientY + document.body.scrollTop; // 计算鼠标指针的y轴距离 return event; // 返回标准化的事件对象 &#125; // 定义鼠标事件处理函数 document.onmousedown = function(event)&#123; // 按下鼠标时，初始化处理 event = e(event); // 获取标准事件对象 o = event.target; // 获取当前拖放的元素 ox = parseInt(o.offsetLeft); // 拖放元素的x轴坐标 oy = parseInt(o.offsetTop); // 拖放元素的y轴坐标 mx = event.mx; // 按下鼠标指针的x轴坐标 my = event.my; // 按下鼠标指针的y轴坐标 document.onmousemove = move; // 注册鼠标移动事件处理函数 document.onmouseup = stop; // 注册松开鼠标事件处理函数 &#125; function move(event)&#123; // 鼠标移动处理函数 event = e(event); o.style.left = ox + event.mx - mx + &quot;px&quot;; // 定义拖动元素的x轴距离 o.style.top = oy + event.my - my + &quot;px&quot;; // 定义拖动元素的y轴距离 &#125; function stop(event)&#123; // 松开鼠标处理函数 event = e(event); ox = parseInt(o.offsetLeft); // 记录拖放元素的x轴坐标 oy = parseInt(o.offsetTop); // 记录拖放元素的y轴坐标 mx = event.mx ; // 记录鼠标指针的x轴坐标 my = event.my ; // 记录鼠标指针的y轴坐标 o = document.onmousemove = document.onmouseup = null; // 释放所有操作对象 &#125;&lt;/script&gt; 鼠标经过 鼠标经过包括移过和移出两种事件类型。当移动鼠标指针到某个元素上时，将触发 mouseover 事件；而当把鼠标指针移出某个元素时，将触发 mouseout 事件。如果从父元素中移到子元素中时，也会触发父元素的 mouseover 事件类型。 示例 在下面示例中，分别为3个嵌套的div元素定义了mouseover和mouseout事件处理函数，这样当从外层的父元素中移动到内部的子元素中时，将会触发父元素的 mouseover 事件类型，但是不会触发 mouseout 事件类型。 1234567891011121314151617&lt;div&gt; &lt;div&gt; &lt;div&gt;盒子&lt;/div&gt; &lt;/div&gt;&lt;/div&gt;&lt;script&gt; var div = document.getElementsByTagName(&quot;div&quot;); // 获取3个嵌套的div元素 for(var i=0;i&lt;div.length;i++)&#123; // 遍历嵌套的div元素 div[i].onmouseover = function(e)&#123; // 注册移过事件处理函数 this.style.border = &quot;solid blue&quot;; &#125; div[i].onmouseout = function()&#123; // 注册移出事件处理函数 this.style.border = &quot;solid red&quot;; &#125; &#125;&lt;/script&gt; 鼠标来源 当一个事件发生后，可以使用事件对象的 target 属性获取发生事件的节点元素。如果在 IE 事件模型中实现相同的目标，可以使用 srcElement 属性。 示例： 在下面示例中，当鼠标移过页面中的 div 元素时，会弹出提示对话框，提示当前元素的节名称。 123456789&lt;div&gt;div元素&lt;/div&gt;&lt;script&gt; var div = document.getElementsByTagName(&quot;div&quot;)[0]; div.onmouseover = function(e)&#123; // 注册mouseover事件处理函数 var e = e || window.event; // 标准化事件对象，兼容DOM和IE事件模型 var o = e.target || e.srcElement; // 标准化事件属性，获取当前事件的节点 alert(o.tagName); // 返回字符串“DIV” &#125;&lt;/script&gt; 在 DOM 事件模型中还定义了 currentTarget 属性，当事件在传播过程中（如捕获和冒泡阶段）时，该属性值与 target 属性值不同。因此，一般在事件处理函数中，有你哥哥使用该属性而不是 this 关键词获取当前对象。 除了使用上面提到的通用事件属性外，如果想获取鼠标指针来移动某个元素，在 DOM 事件模型中可以使用 relatedTarget 属性获取当前事件对象的相关节点元素；而在 IE 事件模型中，可以使用 fromElement 获取 mouseover 事件中鼠标移到过的元素，使用 toElement 属性获取在 mouseout 事件中鼠标移到的文档元素。 示例2： 在下面示例中，当鼠标移到 div 元素上时，会弹出“BODY”字符提示信息，说明鼠标指针是从 body 元素过来的；而移开鼠标指针时，又弹出“BODY”字符提示信息，说明离开 div 元素将要移到的元素。 1234567891011121314&lt;div&gt;div元素&lt;/div&gt;&lt;script&gt; var div = document.getElementsByTagName(&quot;div&quot;)[0]; div.onmouseover = function(e)&#123; var e = e || window.event; var o = e.relatedTarget || e.fromElement; //标准化事件属性，获取与当前事件相关的节点 alert(o.tagName); &#125; div.onmouseout = function(e)&#123; var e = e || window.event; var o = e.relatedTarget || e.toElement; // 标准化事件属性，获取与当前事件相关的节点 alert(o.tagName); &#125;&lt;/script&gt; 键盘事件在JavaScript中，当用户操作键盘时，会触发键盘事件，键盘事件主要包括下面3种类型： keydown：在键盘上按下某个键时触发。如果按住某个键，会不断触发该事件，但是Opera浏览器不支持这种连续操作。该事件处理函数返回false时，会取消默认的动作（如输入的键盘字符，在IE和Safari浏览器下还会禁止keypress事件响应）。 keypress：按下某个键盘键并释放时触发。如果按住某个键，会不断触发该事件。该事件处理函数返回false时，会取消默认的动作（如输入的键盘字符）。 keyup：释放某个键盘键时触发。该事件仅在松开键盘时触发一次，不是一个持续的响应状态。 当获取用户正按下键码时，可以使用keydown、keypress和keyup事件获取这些信息。其中keydown和keypress事件基本上是同义事件，它们的表现也完全一致，不过一些浏览器不允许使用keypress事件获取按键信息。所有元素都支持键盘事件，但键盘事件多被应用在表单输入中。 示例 下面示例实时捕获键盘操作的各种细节，即键盘响应事件类型及对应的键值。 123456789101112&lt;textarea id=&quot;key&quot;&gt;&lt;/textarea&gt;&lt;script&gt; var key = document.getElementById(&quot;key&quot;); key.onkeydown =f; //注册keydown事件处理函数 key.onkeyup = f; //注册keyup事件处理函数 key.onkeypress = f; //注册keypress事件处理函数 function f (e) &#123; var e = e || window.event; //标准化事件处理 var s = e.type + &quot; &quot; + e.keyCode; //获取键盘事件类型和按下的值 key.value = s; &#125;&lt;/script&gt; 键盘事件属性 键盘定义了很多属性，如下表所示。利用这些属性可以精确控制键盘操作。键盘事件属性一般只在键盘相关事件发生时才会存在于事件对象中，但是 ctrlKey 和 shiftKey 属性除外，因为它们可以在水保事件中存在。例如，当按下 Ctrl 或Shift 键时单击鼠标操作。 keyCode ：该属性包含键盘中对应键位的键值 charCode ：该属性包含键盘中对应键位的 Unicode 编码，仅 DOM 支持 target：发生事件的节点（包含元素），仅 DOM 支持 srcElement ：发生事件的元素，仅 IE 支持 shiftKey：是否按下 Shift 键，如果按下返回 true，否则为false ctrlKey：是否按下 Ctrl 键，如果按下返回 true，否则为false altKey：是否按下 Alt 键，如果按下返回 true，否则为false metaKey：是否按下 Mtea 键，如果按下返回 true，否则为false，仅 DOM 支持 示例： ctrlKey和shiftKey属性可存在于键盘和鼠标事件中，表示键盘上的Ctrl和Shift键是否被按住。下面示例能够监测Ctrl 和Shift键是否被同时按下。如果同时按下，且鼠标单击某个页面元素，则会把该元素从页面中删除。 1234567document.onclick = function (e) &#123; var e = e || window.event; //标准化事件对象 var t = e.target || e.srcElement; //获取发生事件的元素，兼容IE和DOM if (e.ctrlKey &amp;&amp; e.shiftKey) &#123; //如果同时按下Ctrl和Shift键 t.parentNode.removeChild(t); //移出当前元素 &#125;&#125; 09（数字键）：4857 AZ（字母键）：6590 Backspace（退格键）：8 Tab（制表键）：9 Enter（回车键）：13 Space（空格键）：32 Left arrow（左箭头键）：37 Top arrow（上箭头键）：38 Right arrow（右箭头键）：39 Down arrow（下箭头键）：40 示例2： 下面示例演示了如何使用方向键控制页面元素的移动效果。 12345678910111213141516171819202122232425262728&lt;div id=&quot;box&quot;&gt;&lt;/div&gt;&lt;script&gt; var box = document.getElementById(&quot;box&quot;); // 获取页面元素的引用指针 box.style.position = &quot;absolute&quot;; // 色块绝对定位 box.style.width = &quot;20px&quot;; // 色块宽度 box.style.height = &quot;20px&quot;; // 色块高度 box.style.backgroundColor = &quot;red&quot;; // 色块背景 document.onkeydown = keyDown; //在Document对象中注册keyDown事件处理函数 function keyDown(event)&#123; // 方向键控制元素移动函数 var event = event || window.event; // 标准化事件对象 switch(event.keyCode)&#123; // 获取当前按下键盘键的编码 case 37 : // 按下左箭头键，向左移动5个像素 box.style.left = box.offsetLeft - 5 + &quot;px&quot;; break; case 39 : // 按下右箭头键，向右移动5个像素 box.style.left = box.offsetLeft + 5 + &quot;px&quot;; break; case 38 : // 按下上箭头键，向上移动5个像素 box.style.top = box.offsetTop - 5 + &quot;px&quot;; break; case 40 : // 按下下箭头键，向下移动5个像素 box.style.top = box.offsetTop + 5 + &quot;px&quot;; break; &#125; return false &#125;&lt;/script&gt; 在上面示例中，首先获取页面元素，通过 CSS 脚本控制元素绝对定位、大小和背景色。然后在 document 对象上注册鼠标按下事件类型处理函数，在事件回调函数 keyDown() 中侦测当前按下的方向键，并决定定位元素在窗口中的位置。其中元素的 offsetLeft 和 offsetTop 属性可以存取它在页面中的位置。 键盘响应顺序 当按下键盘时，会连续触发多个事件，它们将按如下顺序发生。 对于字符键来说，键盘事件的响应顺序：keydown → keypress → keyup。 对于非字符键（如功能键或特殊键）来说，键盘事件的相应顺序：keydown → keyup。 如果按下字符键不放，则 keydown 和 keypress 事件将逐个持续发生，直至松开按键。 如果按下非字符键不放，则只有 keydown 事件持续发生，直至松开按键。 示例 下面设计一个简单示例，以获取键盘事件相应顺序。 12345678910111213&lt;textarea id=&quot;text&quot; cols=&quot;26&quot; rows=&quot;16&quot;&gt;&lt;/textarea&gt;&lt;script&gt; var n = 1; // 定义编号变量 var text = document.getElementById(&quot;text&quot;); // 获取文本区域的引用指针 text.onkeydown = f; // 注册keydown事件处理函数 text.onkeyup = f; // 注册keyup事件处理函数 text.onkeypress = f; // 注册keypress事件处理函数 function f(e)&#123; // 事件调用函数 var e = e || window.event; // 标准化事件对象 text.value += (n++) + &quot;=&quot; + e.type +&quot; (keyCode=&quot; + e.keyCode + &quot;)\\n&quot;; //捕获事件响应信息 &#125;&lt;/script&gt; 表单事件onblur:元素失去焦点时触发 123456789101112&lt;script type=&quot;text/javascript&quot;&gt;function upperCase()&#123; var x=document.getElementById(&quot;fname&quot;).value document.getElementById(&quot;fname&quot;).value=x.toUpperCase()&#125;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;输入您的姓名：&lt;input type=&quot;text&quot; id=&quot;fname&quot; onblur=&quot;upperCase()&quot; /&gt;&lt;/body&gt; onfocus:元素获取焦点时触发 123456789101112131415&lt;html&gt;&lt;head&gt;&lt;script type=&quot;text/javascript&quot;&gt;function setStyle(x)&#123; document.getElementById(x).style.background=&quot;yellow&quot;&#125;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;First name: &lt;input type=&quot;text&quot; onfocus=&quot;setStyle(this.id)&quot; id=&quot;fname&quot; /&gt;&lt;br /&gt;Last name: &lt;input type=&quot;text&quot; onfocus=&quot;setStyle(this.id)&quot; id=&quot;lname&quot; /&gt;&lt;/body&gt;&lt;/html&gt; onsubmit:表单提交时触发 12345678910111213141516171819202122232425262728&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;onsubmit用户提交,submit属性,事件&lt;/title&gt;&lt;/head&gt;&lt;script type=&quot;text/javascript&quot;&gt; function test()&#123; var s1 =document.mianform.user.value; var s2 = document.mianform.pwd.value ; if(s1 == &quot;&quot;||s2 ==&quot;&quot;)&#123; alert(&#x27;请将内容填写完整&#x27;); return false ;//false不提交 &#125; return true ; // true提交 &#125;&lt;/script&gt;&lt;body&gt; &lt;form name=&quot;mianform&quot; onsubmit=&quot;return test()&quot;&gt; &lt;label&gt;姓名:&lt;/label&gt; &lt;input type=&quot;text&quot; name=&quot;user&quot; onfocus=&quot;console.log(&#x27;点击这里输入用户名&#x27;);&quot; onblur=&quot;console.log(&#x27;文本失去焦点&#x27;);&quot;&gt; &lt;br&gt; &lt;label&gt;密码:&lt;/label&gt; &lt;input type=&quot;password&quot; name=&quot;pwd&quot; &gt; &lt;br&gt; &lt;input type=&quot;submit&quot; value=&quot;提交&quot; &gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; onreset:表单重置时触发 onchange:表单域里的内容改变时触发 onselect:用户选取表单域里的文本时触发 12345678910111213141516&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot;&gt;&lt;title&gt; 内容选中事件 &lt;/title&gt;&lt;script type=&quot;text/javascript&quot;&gt; function message()&#123; alert(&quot;您触发了选中事件！&quot;); &#125;&lt;/script&gt; &lt;/head&gt;&lt;body&gt; &lt;form&gt; 个人简介：&lt;br&gt; &lt;textarea name=&quot;summary&quot; cols=&quot;60&quot; rows=&quot;5&quot; onselect=&quot;message()&quot;&gt;请写入个人简介，不少于200字！&lt;/textarea&gt; &lt;/form&gt;&lt;/body&gt; 绑定和删除事件addEventListener()方法用于向指定元素添加事件句柄 removeEventListener()方法用于移除由addEventLister()方法添加的事件句柄 其他事件1）页面事件 onload 页面载入完毕时触发 onunload 用户退出页面时触发 2）窗口事件 onresize 窗口被调整大小时触发 onscroll 元素滚动条在滚动时触发","categories":[{"name":"DOM","slug":"DOM","permalink":"http://example.com/categories/DOM/"}],"tags":[{"name":"DOM","slug":"DOM","permalink":"http://example.com/tags/DOM/"}]},{"title":"DOM","slug":"DOM","date":"2017-07-15T13:19:55.000Z","updated":"2022-05-28T02:29:45.829Z","comments":true,"path":"2017/07/15/DOM/","link":"","permalink":"http://example.com/2017/07/15/DOM/","excerpt":"","text":"DOM简介Document Object Model 文档对象模型 DOM包含了所有HTML元素的属性和方法，以及访问操作他们的方式； 认识dom树和dom节点什么是Dom操作？ DOM是一个使程序和脚本有能力动态地访问和更新文档的内容、结构以及样式的平台和语言中立的接口 在HTML和JavaScript的学习中，DOM操作可谓时重中之重 Dom树 DOM节点的分类：DOM节点分为三大类：元素（标签）节点、属性节点、文本节点； 节点之间的关系：由DOM树我们可以看到，文本节点、属性节点属于元素节点的子节点 在操作元素节点和文本节点前，一定要先获取到元素节点。 访问节点通过ID名查找dom元素语法：document.getElementById(“id名”) 功能：找页面中对应id名的元素； 返回值：dom元素 返回值类型：object; 说明：getELementById()前面必须的document对象（即文档对象）如果页面中没有这个id元素，返回null; 通过标签名找元素语法1：document.getElementsByTagName(“标签名”) 功能：获取页面中所有指定标签； 返回值：返回一个类数组（即一个集合）；换句话说，就是将页面中所有的指定标签放在一个方括号的集合里面。 获取具体的某个元素； 通过name属性找元素document.getElementByName: 方法可返回带有指定名称的对象的集合 通过指定的类名获取元素语法：document.getElementsByClassName() 功能：返回文档中所有指定类名的元素集合，作为 NodeList 对象。 HTML 5 为 document 对象和 HTML 元素新增了 getElementsByClassName() 方法，使用该方法可以选择指定类名的元素。 getElementsByClassName() 方法可以接收一个字符串参数，包含一个或多个类名，类名通过空格分隔，不分先后顺序，方法返回带有指定类的所有元素 NodeList。 浏览器支持状态：IE 9+、Firefox 3.0+、Safari 3+、Chrome 和 Opera 9.5+。 如果不考虑兼容早期 IE 浏览器或者怪异模式，用户可以放心使用。 示例1 下面示例使用 getElementsByClassName(“red”) 方法选择文档中所有包含 red 类的元素。 123456789&lt;div class=&quot;red&quot;&gt;红盒子&lt;/div&gt;&lt;div class=&quot;blue red&quot;&gt;蓝盒子&lt;/div&gt;&lt;div class=&quot;green red&quot;&gt;绿盒子&lt;/div&gt;&lt;script&gt; var divs = document.getElementsByClassName(&quot;red&quot;); for (var i = 0; i &lt; divs.length; i ++) &#123; console.log(divs[i].innerHTML); &#125;&lt;/script&gt; 示例2 下面示例使用 document.getElementById(“box”) 方法先获取 ，然后在它下面使用 getElementsByClassName(“blue red”) 选择同时包含 red 和 blue 类的元素。 12345678910&lt;div id=&quot;box&quot;&gt; &lt;div class=&quot;blue red green&quot;&gt;blue red green&lt;/div&gt;&lt;/div&gt;&lt;div class=&quot;blue red black&quot;&gt;blue red black&lt;/div&gt;&lt;script&gt; var divs = document.getElementById(&quot;box&quot;).getElementsByClassName(&quot;blue red&quot;); for (var i = 0; i &lt; divs.length; i ++) &#123; console.log(divs[i].innerHTML); &#125;&lt;/script&gt; 在 document 对象上调用 getElementsByClassName() 会返回与类名匹配的所有元素，在元素上调用该方法就只会返回后代元素中匹配的元素。 通过样式查找单个元素语法：元素.querySelector(“css选择器”); 功能：返回文档中匹配指定 CSS 选择器的一个元素 返回值：DOM对象 传递一个标签选择器 传递一个类选择器 传递一个交集选择器 获取文档中有 “target” 属性的第一个 元素 并集选择器 通过样式获取所有元素语法：元素.querySelectorAll(“css选择器”);语法：元素.querySelectorAll(“css选择器”); 功能：该方法和document.querySelector()用法类似，不同的是它会将符合条件的元素封装到一个数组中返回。即使符合条件的元素只有一个，它也会返回数组. 返回值：类数组 Document类型JavaScript 通过 Document 类型表示文档。在浏览器中，document 对象是 HTMLDocument（继承自 Document 类型）的一个实例，表示整个 HTML 页面。而且，document 对象是 window 对象的一个属性，因此可以将其作为全局对象来访问。Document 节点具有下列特征： nodeType 的值为9； nodeName 的值为 &quot;#document&quot;； nodeValue 的值为 null； parentNode 的值为 null； ownerDocument 的值为 null； 其子节点可能是一个 DocumentType（最多一个）、Element（最多一个）、ProcessingInstruction 或 Comment。 Document 类型可以表示 HTML 页面或者其他基于 XML 的文档。不过，最常见的应用还是作为 HTMLDocument 实例的 document 对象。通过这个文档对象，不仅可以取得与页面有关的信息，而且还能操作页面的外观及其底层结构。 文档的子节点虽然 DOM 标准规定 Document 节点的子节点可以是DocumentType、Element、ProcessingInstruction 或 Comment，但还有两个内置的访问其子节点的快捷方式。第一个就是documentElement 属性，该属性始终指向 HTML 页面中的 html 元素。另一个就是通过 childNodes 列表访问文档元素，但通过 documentElement 属性则能更快捷、更直接地访问该元素。以下面这个简单的页面为例。 1234&lt;html&gt; &lt;body&gt; &lt;/body&gt;&lt;/html&gt; 这个页面在经过浏览器解析后，其文档中只包含一个子节点，即 html 元素。可以通过 documentElement 或 childNodes 列表来访问这个元素，如下所示。 123var html = document.documentElement; // 取得对&lt;html&gt;的引用console.log(html === document.childNodes[0]); // trueconsole.log(html === document.firstChild); // true 这个例子说明，documentElement、firstChild 和 childNodes[0] 的值相同，都指向 &lt;html&gt; 元素。 作为 HTMLDocument 的实例，document 对象还有一个 body 属性，直接指向 &lt;body&gt; 元素。因为开发人员经常要使用这个元素，所以 document.body 在 JavaScript 代码中出现的频率非常高，其用法如下。 1var body = document.body; // 取得对&lt;body&gt;的引用 所有浏览器都支持 document.documentElement 和 document.body 属性。 Document 另一个可能的子节点是 DocumentType。通常将 &lt;!DOCTYPE&gt; 标签看成一个与文档其他部分不同的实体，可以通过 doctype 属性（在浏览器中是 document.doctype ）来访问它的信息。 1var doctype = document.doctype; // 取得对&lt;!DOCTYPE&gt;的引用 浏览器对 document.doctype 的支持差别很大，可以给出如下总结。 IE8 及之前版本：如果存在文档类型声明，会将其错误地解释为一个注释并把它当作 Comment 节点；而 document.doctype 的值始终为 null。 IE9+ 及 Firefox：如果存在文档类型声明，则将其作为文档的第一个子节点；document.doctype 是一个 DocumentType 节点，也可以通过 document.firstChild 或 document.childNodes[0] 访问同一个节点。 Safari、Chrome 和 Opera：如果存在文档类型声明，则将其解析，但不作为文档的子节点。document.doctype 是一个 DocumentType 节点，但该节点不会出现在 document.childNodes 中。 由于浏览器对 document.doctype 的支持不一致，因此这个属性的用处很有限。 文档信息作为 HTMLDocument 的一个实例，document 对象还有一些标准的 Document 对象所没有的属性。这些属性提供了 document 对象所表现的网页的一些信息。其中第一个属性就是 title，包含着 &lt;title&gt; 元素中的文本——显示在浏览器窗口的标题栏或标签页上。通过这个属性可以取得当前页面的标题，也可以修改当前页面的标题并反映在浏览器的标题栏中。 12345// 取得文档标题var originalTitle = document.title;// 设置文档标题document.title = &quot;New page title&quot;; 接下来要介绍的3个属性都与对网页的请求有关，它们是 URL、domain 和 referrer。URL 属性中包含页面完整的 URL（即地址栏中显示的URL），domain 属性中只包含页面的域名，而 referrer 属性中则保存着链接到当前页面的那个页面的 URL。在没有来源页面的情况下，referrer 属性中可能会包含空字符串。所有这些信息都存在于请求的 HTTP 头部，只不过是通过这些属性让我们能够在 JavaScrip 中访问它们而已，如下面的例子所示。 12345678// 取得完整的URLvar url = document.URL;// 取得域名var domain = document.domain;// 取得来源页面的URLvar referrer = document.referrer; 更改节点内容 获取元素的内容 语法：元素.innerHTML; 说明：获取到的内容都是string 类型； 修改设置元素的内容 语法：元素.innerHTML &#x3D; ‘内容’ 元素的行内样式获取元素的行内样式 style 语法：元素.style.css属性； 注意：复合属性需要转驼峰； 设置元素的行内样式语法：元素.style.css属性 &#x3D; 属性值； 获取元素的html属性语法：元素.html属性 Eg: 元素.id 元素.src 元素.alt 元素.value 等； 设置修改元素的html属性语法：元素.属性 &#x3D; 属性值； 初始 修改后 Node 属性概述Node 常用属性主要有以下10个，接下来我们会着重讲解部分属性。 nodeType：显示节点的类型 nodeName：显示节点的名称 nodeValue：显示节点的值 attributes：获取一个属性节点 firstChild：表示某一节点的第一个节点 lastChild：表示某一节点的最后一个子节点 childNodes：表示所在节点的所有子节点 parentNode：表示所在节点的父节点 nextSibling：紧挨着当前节点的下一个节点 previousSibling：紧挨着当前节点的上一个节点 nodeName 和 nodeValue 属性要了解节点的具体信息，可以使用 nodeName 和 nodeValue 这两个属性。这两个属性的值完全取决于节点的类型。在使用这两个值以前，最好是像下面这样先检测一下节点的类型。 123if (someNode.nodeType == 1)&#123; value = someNode.nodeName; // nodeName的值是元素的标签名&#125; 在这个例子中，首先检查节点类型，看它是不是一个元素。如果是，则取得并保存 nodeName 的值。对于元素节点，nodeName 中保存的始终都是元素的标签名，而 nodeValue 的值则始终为 null。 属性节点的主要特征值：nodeType 等于 2、nodeName 等于属性的名称、nodeValue 等于属性的值、parentNode 等于 null，在 HTML 中不包含子节点。属性节点继承于 Node 类型，包含以下 3 个专用属性。 name：表示属性名称，等效于 nodeName。 value：表示属性值，可读可写，等效于 nodeValue。 specified：如果属性值是在代码中设置的，则返回 true；如果为默认值，则返回 false。 创建属性节点使用 document 对象的 createAttribute() 方法可以创建属性节点，具体用法如下： 1document.createAttribute(name) 参数 name 表示新创建的属性的名称。 示例1 下面示例创建一个属性节点，名称为 align，值为 center，然后为标签 设置属性 align，最后分别使用 3 种方法读取属性 align 的值。 12345678910&lt;div id=&quot;box&quot;&gt;document.createAttribute(name)&lt;/div&gt;&lt;script&gt; var element = document.getElementById(&quot;box&quot;); var attr = document.createAttribute(&quot;align&quot;); attr.value = &quot;center&quot;; element.setAttributeNode(attr); console.log(element.attributes[&quot;align&quot;].value); //&quot;center&quot; console.log(element.getAttributeNode(&quot;align&quot;).value); //&quot;center&quot; console.log(element.getAttribute(&quot;align&quot;)); //&quot;center&quot;&lt;/script&gt; 属性节点一般位于元素的头部标签中。元素的属性列表会随着元素信息预先加载，并被存储在关联数组中。例如，针对下面 HTML 结构。 1&lt;div id=&quot;div1&quot; class=&quot;style1&quot; lang=&quot;en&quot; title=&quot;div&quot;&gt;&lt;/div&gt; 当 DOM 加载后，表示 HTML div 元素的变量 divElement 就会自动生成一个关联集合，它以名值对形式检索这些属性。 123456divElement.attributes = &#123; id : &quot;div1&quot;, class : &quot;style1&quot;, lang : &quot;en&quot;, title : &quot;div&quot;&#125; 在传统 DOM 中，常用点语法通过元素直接访问 HTML 属性，如 img.src、a.href 等，这种方式虽然不标准，但是获得了所有浏览器的支持。 示例2 img 元素拥有 src 属性，所有图像对象都拥有一个 src 脚本属性，它与 HTML 的 src 特性关联在一起。下面两种用法都可以很好地工作在不同浏览器中。 123456&lt;img id=&quot;img1&quot; src=&quot;&quot; /&gt;&lt;script&gt; var img = document.getElementById(&quot;img1&quot;); img.setAttribute(&quot;src&quot;, &quot;http://www.w3.org&quot;); //HTML 属性 img.src = &quot;http://www.w3.org&quot;; //JavaScript 属性&lt;/script&gt; 类似的还有 onclick、style 和 href 等。为了保证 JavaScript 脚本在不同浏览器中都能很好地工作，建议采用标准用法，而且很多 HTML 属性并没有被 JavaScript 映射，所以也就无法直接通过脚本属性进行读写。 读取属性值使用元素的 getAttribute() 方法可以读取指定属性的值。用法如下： 1getAttribute(name) 参数 name 表示属性名称。 使用元素的 attributes 属性、getAttributeNode() 方法可以返回对应属性节点。 示例1 下面示例访问红色盒子和蓝色盒子，然后读取这些元素所包含的 id 属性值。 12345678&lt;div id=&quot;red&quot;&gt;红盒子&lt;/div&gt;&lt;div id=&quot;blue&quot;&gt;蓝盒子&lt;/div&gt;&lt;script&gt; var red = document.getElementById(&quot;red&quot;); //获取红色盒子 console.log(red.getAttribute(&quot;id&quot;)); //显示红色盒子的id属性值 var blue = document.getElementById(&quot;blue&quot;); //获取蓝色盒子 console.log(blue.getAttribute(&quot;id&quot;)); //显示蓝色盒子的id属性值&lt;/script&gt; 示例2 HTML DOM 也支持使用点语法读取属性值，使用比较简便，也获得了所有浏览器的支持。 1234var red = document.getElementById(&quot;red&quot;);console.log(red.id);var blue = document.getElementById(&quot;blue&quot;);console.log(blue.id); 对于 class 属性，则必须使用 className 属性名，因为 class 是 JavaScript 的保留字；对于 for 属性，则必须使用 htmlFor 属性名，这与 CSS 脚本中 float 和 text 属性被改名为 cssFloat 和 cssText 是一个道理。 示例3 使用 className 读写样式类。 12345678&lt;label id=&quot;label1&quot; class=&quot;class1&quot; for=&quot;textfield&quot;&gt;文本框： &lt;input type=&quot;text&quot; name=&quot;textfield&quot; id=&quot;textfield&quot; /&gt;&lt;/label&gt;&lt;script&gt; var label = document.getElementById(&quot;label1&quot;); console.log(label.className); console.log(label.htmlFor);&lt;/script&gt; 示例4 对于复合类样式，需要使用 split() 方法劈开返回的字符串，然后遍历读取类样式。 12345678&lt;div id=&quot;red&quot; class=&quot;red blue&quot;&gt;红盒子&lt;/div&gt;&lt;script&gt; //所有类名生成的数组 var classNameArray = document.getElementById(&quot;red&quot;).className.split(&quot; &quot;); for (var i in classNameArray) &#123; //遍历数组 console.log(classNameArray[i]); //当前class名 &#125;&lt;/script&gt; 设置属性值使用元素的 setAttribute() 方法可以设置元素的属性值。用法如下： 1setAttribute(name) 参数 name 和 value 分别表示属性名称和属性值。属性名和属性值必须以字符串的形式进行传递。如果元素中存在指定的属性，它的值将被刷新；如果不存在，则 setAttribute() 方法将为元素创建该属性并赋值。 示例1 下面示例分别为页面中 div 元素设置 title 属性。 12345678&lt;div id=&quot;red&quot;&gt;红盒子&lt;/div&gt;&lt;div id=&quot;blue&quot;&gt;蓝盒子&lt;/div&gt;&lt;script&gt; var red = document.getElementById(&quot;red&quot;); //获取红盒子的引用 var blue= document.getElementById(&quot;blue&quot;); //获取蓝盒子的引用 red.setAttribute(&quot;title&quot;, &quot;这是红盒子&quot;); //为红盒子对象设置title属性和值 blue.setAttribute(&quot;title&quot;, &quot;这是蓝盒子&quot;); //为蓝盒子对象设置title属性和值&lt;/script&gt; 示例2 下面示例定义了一个文本节点和元素节点，并为一级标题元素设置 title 属性，最后把它们添加到文档结构中。 12345var hello = document.createTextNode(&quot;Hello World!&quot;); //创建一个文本节点var h1 = document.createElement(&quot;h1&quot;); //创建一个一级标题h1.setAttribute(&quot;title&quot;, &quot;你好，欢迎光临！&quot;); //为以及标题定义title 属性h1.appendChild(hello); //把文本节点增加到一级标题中document.body.appendChild(h1); //把一级标题增加到文档 示例3 也可以使用快捷方法设置 HTML DOM 文档中元素的属性值。 12345678&lt;label id=&quot;label1&quot;&gt;文本框： &lt;input type=&quot;text&quot; name=&quot;textfield&quot; id=&quot;textfield&quot; /&gt;&lt;/label&gt;&lt;script&gt; var label1 = document.getElementById(&quot;label1&quot;); label.className = &quot;class1&quot;; label.htmlFor = &quot;textfield&quot;;&lt;/script&gt; DOM 支持使用 getAttribute() 和 setAttribute() 方法读写自定义属性，不过 IE 6.0 及其以下版本浏览器对其的支持不是很完善。 示例4 直接使用 className 添加类样式，会覆盖掉元素原来的类样式。这时可以采用叠加的方式添加类。 123456&lt;div id=&quot;red&quot;&gt;红盒子&lt;/div&gt;&lt;script&gt; var red = document.getElementById(&quot;red&quot;); red.className = &quot;red&quot;; red.className += &quot;blue&quot;;&lt;/script&gt; 示例5 使用叠加的方式添加类也存在问题，这样容易添加大量重复的类。为此，定义一个检测函数，判断元素是否包含指定的类，然后再决定是否添加类。 12345678910111213141516&lt;script&gt; function hasClass (element, className) &#123; //检测类名函数 var reg = new RegExp(&#x27;(\\\\s|^)&#x27; + className + &#x27;(\\\\s|$)&#x27;); return reg.test(element.className); //使用正则检测是否有相同的样式 &#125; function addClass (element, className) &#123; //添加类名函数 if (! hasClass (element, className)) element.className += &#x27; &#x27; + className; &#125;&lt;/script&gt;&lt;div id=&quot;red&quot;&gt;红盒子&lt;/div&gt;&lt;script&gt; var red = document.getElementById(&quot;red&quot;); addClass(red, &#x27;red&#x27;); addClass(red, &#x27;blue&#x27;);&lt;/script&gt; 删除属性使用元素的 removeAttribute() 方法可以删除指定的属性。用法如下： 1removeAttribute(name) 参数 name 表示元素的属性名。 示例1 下面示例演示了如何动态设置表格的边框 123456789101112131415161718&lt;script&gt; window.onload = function () &#123; //绑定页面加载完毕时的事件处理函数 var table = document.getElementByTagName(&quot;table&quot;)[0]; //获取表格外框的引用 var del = document.getElementById(&quot;del&quot;); var reset = document.getElementById(&quot;reset&quot;); del.onclick = function () &#123; table.removeAttribute(&quot;border&quot;); &#125; reset.onclick = function () &#123; table.setAttribute(&quot;border&quot;, &quot;2&quot;); &#125;&lt;/script&gt;&lt;table width=&quot;100%&quot; border=&quot;2&quot;&gt; &lt;tr&gt; &lt;td&gt;数据表格&lt;/td&gt; &lt;tr&gt;&lt;/table&gt;&lt;button id=&quot;del&quot;&gt;删除&lt;/button&gt;&lt;button id=&quot;reset&quot;&gt;恢复&lt;/button&gt; 在上面示例中设计了两个按钮，并分别绑定了不同的事件处理函数。单击“删除”按钮即可调用表格的 removeAttribute() 方法清除表格边框，单击“恢复”按钮即可调用表格的 setAttribute() 方法重新设置表哥便可的粗细。 示例2 下面示例演示了如何自定义删除类函数，并调用该函数删除指定类名。 12345678910111213141516&lt;script&gt; function hasClass (element, className) &#123; //类名检测函数 var reg = new RegExp (&#x27;(\\\\s|^)&#x27; + className + &#x27;(\\\\s|$)&#x27;); return reg.test (element, className); //使用正则检测是否有相同的样式 &#125; function deleteClass (element, className) &#123; if (hasClass (element, className)) &#123; element.className.replace (reg, &#x27; &#x27;); //捕获要删除样式，然后替换为空白字符串 &#125; &#125;&lt;/script&gt;&lt;div id=&quot;red&quot; class=&quot;red blue bold&quot;&gt;盒子&lt;/div&gt;&lt;script&gt; var red = document.getElementById (&quot;red&quot;); deleteClass (red, &#x27;blue&#x27;);&lt;/script&gt; 上面代码使用正则表达式检测 className 属性值字符串中是否包含指定的类名，如果存在，则使用空字符串替换掉匹配到的子字符串，从而实现删除类名的目的。 创建节点createElement() 方法创建新的元素节点。 document.createElement()是在对象中创建一个对象，要与appendChild()或insertBefore()方法联合使用。其中，appendChild()方法在节点的子节点列表末添加新的子节点。insertBefore()方法在节点的子节点列表任意位置插入新的节点。 添加节点appendChild() 方法向已存在的节点添加子节点。 示例： 12345678&lt;div id=&quot;board&quot;&gt;&lt;/div&gt;&lt;script&gt;var board = document.getElementById(&quot;board&quot;);var e = document.createElement(&quot;input&quot;);e.type = &quot;button&quot;;e.value = &quot;这是测试加载的小例子&quot;;var object = board.appendChild(e);&lt;/script&gt; 示例2： 12345678&lt;script type=&quot;text/javascript&quot;&gt; var board = document.getElementById(&quot;board&quot;); var e2 = document.createElement(&quot;select&quot;); e2.options[0] = new Option(&quot;加载项1&quot;, &quot;&quot;); e2.options[1] = new Option(&quot;加载项2&quot;, &quot;&quot;); e2.size = &quot;2&quot;; var object = board.appendChild(e2);&lt;/script&gt; 示例3： 123456789&lt;script type=&quot;text/javascript&quot;&gt; var board = document.getElementById(&quot;board&quot;); var e3 = document.createElement(&quot;input&quot;); e4.setAttribute(&quot;type&quot;, &quot;text&quot;); e4.setAttribute(&quot;name&quot;, &quot;q&quot;); e4.setAttribute(&quot;value&quot;, &quot;使用setAttribute&quot;); e4.setAttribute(&quot;onclick&quot;, &quot;javascript:alert(&#x27;This is a test!&#x27;);&quot;); var object = board.appendChild(e3);&lt;/script&gt; 替换节点replaceChild() 方法可以将某个子节点替换为另一个。 语法： 1nodeObject.replaceChild(new_node, old_node) 其中参数 new_node 为指定新的节点，old_node 为被替换的节点。如果替换成功，则返回被替换的节点；如果替换失败，则返回 null。 示例1： 以上示例为基础重写脚本，新建一个二级标题元素并替换掉红色盒子中的一级标题元素。 1234567var ok = document.getElementById(&quot;ok&quot;); //获取按钮元素的引用ok.onclick = function () &#123; //为按钮注册一个鼠标单击事件处理函数 var red = document.getElementById(&quot;red&quot;); //获取红色盒子的引用 var h1 = document.getElementsByTagName(&quot;h1&quot;)[0]; //获取一级标题的引用 var h2 = documeng.createElement(&quot;h2&quot;); //创建二级标题元素并引用 red.replaceChild(h2, h1); //把一级标题替换为二级标题&#125; 示例2： 在下面示例中使用蓝盒子替换掉红盒子中包含的一级标题元素。此时可以看到，蓝盒子原来显示的位置已经被删除显示，同时被替换元素 h1 也被删除。 1234567var ok = document.getElementById(&quot;ok&quot;); //获取按钮元素的引用ok.onclick = function () &#123; //为按钮注册一个鼠标单击事件处理函数 var red = document.getElementById(&quot;red&quot;); //获取红色盒子的引用 var blue= document.getElementById(&quot;blue&quot;); //获取蓝色盒子的引用 var h1 = document.getElementsByTagName(&quot;h1&quot;)[0]; //获取一级标题的引用 red.replaceChild(blue, h1); //把红盒子中包含的一级标题替换为蓝盒子&#125; 示例3： replaceChild() 方法能够返回被替换掉的节点引用，因此还可以把被替换掉的元素给找回来，并增加到文档中的指定节点中。 针对上面示例，使用一个变量 del_h1 存储被替换掉的一级标题，然后再把它插入到红色盒子前面。 12345678var ok = document.getElementById(&quot;ok&quot;); //获取按钮元素的引用ok.onclick = function () &#123; //为按钮注册一个鼠标单击事件处理函数 var red = document.getElementById(&quot;red&quot;); //获取红色盒子的引用 var blue= document.getElementById(&quot;blue&quot;); //获取蓝色盒子的引用 var h1 = document.getElementsByTagName(&quot;h1&quot;)[0]; //获取一级标题的引用 var del_h1 = red,replaceChild(blue, h1); //把红盒子中包含的一级标题替换为蓝盒子 red.parentNode.insertBefore(del_h1, red); //把替换掉的一级标题插入到红盒子前面&#125; 自定义属性HTML 5 允许用户为元素自定义属性，但要求添加 data- 前缀，目的是为元素提供与渲染无关的附加信息，或者提供语义信息。例如： 1&lt;div id=&quot;box&quot; data-myid=&quot;12345&quot; data-myname=&quot;zhangsan&quot; data-mypass=&quot;zhang123&quot;&gt;自定义数据属性&lt;/div&gt; 添加自定义属性之后，可以通过元素的 dataset 属性访问自定义属性。dataset 属性的值是一个 DOMStringMap 实例，也就是一个名值对的映射。在这个映射中，每个 data-name 形式的属性都会有一个对应的属性，只不过属性名没有 data- 前缀。 浏览器支持状态：Firefox 6+ 和 Chrome。 示例 下面代码演示了如何自定义属性，以及如何读取这些附加信息。 12345678910111213var div = document.getElementById(&quot;box&quot;);//访问自定义属性值var id = div.dataset.myid;var name = div.dataset.myname;var pass = div.dataset.mypass;//重置自定义属性值div.dataset.myid = &quot;66666&quot;;div.dataset.myname = &quot;zhangsan&quot;;div.dataset.mypass = &quot;zhangsan666&quot;;//检测自定义属性if (div.dataset.myname) &#123; console.log(div.dataset.myname);&#125; 虽然上述用法未获得所有浏览器支持，但是我们仍然可以使用这种方式为元素添加自定义属性，然后使用 getAttribute() 方法读取元素附加的信息。 节点关系识别空白文本元素.firstChild 第一个子节点 元素.lastChild 最后一个子节点 元素.childNodes 获取所有的子节点 元素.attributes 获取某个元素的所有属性节点 元素.nextSibling 获取下一个兄弟节点 元素.previousSibling 获取上一个兄弟节点 不识别空白文本元素.children 获取所有的元素子节点 元素.firstElementChild 获取第一个元素子节点 元素.lastElementChild 获取最后一个元素子节点 元素.nextElementSibling 获取下一个元素兄弟节点 元素.previousElementSibling 获取上一个元素兄弟节点 元素.parentNode 父节点","categories":[{"name":"DOM","slug":"DOM","permalink":"http://example.com/categories/DOM/"}],"tags":[{"name":"DOM","slug":"DOM","permalink":"http://example.com/tags/DOM/"}]},{"title":"面向对象编程","slug":"面向对象编程","date":"2017-06-20T03:48:17.000Z","updated":"2022-05-28T04:00:27.116Z","comments":true,"path":"2017/06/20/面向对象编程/","link":"","permalink":"http://example.com/2017/06/20/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/","excerpt":"","text":"一、面向对象与面向过程 面向过程：根据业务逻辑从上到下写代码。 面向对象：将变量与函数绑定到一起，分类进行封装，每个程序只要负责分配给自己的分类，这样能够更快速的开发程序，减少了重复代码。 面向过程编程最易被初学者接受，其往往用一长段代码来实现指定功能，开发过程的思路是将数据与函数按照执行的逻辑顺序组织在一起，数据与函数分开考虑，面向过程基本是由函数组成的。 面向过程编程面向过程编程的关注点在于怎么做 把完成某一个需求的 所有步骤 从头到尾 逐步实现 根据开发需求，将某些 功能独立 的代码 封装 成一个又一个 函数 最后完成的代码，就是顺序地调用 不同的函数 特点: 注重步骤与过程，不注重职责分工 如果需求复杂，代码会变得很复杂 开发复杂项目，没有固定的套路，开发难度很大！ 面向对象基本概念面向对象编程（Object Oriented Programming，OOP，面向对象程序设计）和面相过程编程，是两种不同的编程方式。 面向对象编程的关注点在于谁来做 相比较函数，面向对象是更大的封装，根据职责在 一个对象中封装多个方法 在完成某一个需求前，首先确定职责 —— 要做的事情（方法） 根据 职责 确定不同的 对象，在对象内部封装不同的方法（多个） 最后完成的代码，就是顺序地调用不同对象的相应方法。 特点: 注重 对象和职责，不同的对象承担不同的职责。 更加适合应对复杂的需求变化，是专门应对复杂项目开发，提供的固定套路。 需要在面向过程基础上，再学习一些面向对象的语法。 类和对象类和对象是面向对象编程的两个核心概念。 类类是对一群具有相同特征或者行为 的事物的一个统称，是抽象的，不能直接使用 特征其实就是一个变量，在类里我们称之为属性。 行为其实就是一个函数，在类里我们称之为方法。 类其实就是由 属性 和 方法 组成的一个抽象概念。 类就相当于制造飞机时的图纸，是一个模板。这个模板只规定了飞机的某些特征(例如大小，颜色，型号等等)和行为(例如起飞，降落，飞行等等)，它并不是一个具体的飞机，而是对飞机的一个抽象概念。它出现的目的，是为了让我们的创建飞机对象。 对象对象是由类创建出来的一个具体存在，可以直接使用。由哪一个类创建出来的 对象，就拥有在哪一个类中定义的属性和方法。 对象 就相当于用图纸制造的飞机。在开发中，应该先有类，在类里定义好属性和行为，再根据类来创建对象。 类和对象的关系 类是模板，对象是根据类这个模板创建出来的，应该先有类，再有对象。 使用同一个类，能够创建出很多对象。 类中定义了什么属性和方法，对象中就有什么属性和方法。 不同对象对应的属性值也会不同。 例如：定义了一个狗类，这个狗类有以下属性： 品种 颜色 性别 名字 现在根据这个类创建出了两条狗，这两条狗分别是 哈士奇、灰色、母、二哈 和 中华田园犬、黄色、公、旺财。我们发现，这两条狗都具有 品种、颜色、性别和名字这些属性，但是每条狗对应的属性值却不一样。 类的设计在程序开发中，要设计一个类，通常需要满足一下三个要素： 类名 这类事物的名字，安照大驼峰命名法(每个单词的首字母大写)起名。 属性 这类事物具有什么样的特征。 方法 这类事物具有什么样的行为。 定义类名名词提炼法:分析整个业务流程，出现的名词，通常就是找到的类。 属性和方法的确定 对对象的特征描述，可以定义成属性 对象具有的行为（动词）可以定义成方法 面向对象基本语法在Python中，对象几乎是无处不在的，我们可以使用dir内置函数来查看这个对象里的方法。 定义简单的类（只包含方法） 面向对象是更大的封装，在一个类中封装多个方法，这样通过这个类创建出来的对象，就可以直接调用这些方法了！ 定义类在Python中要定义一个只包含方法的类，语法格式如下： 12345class 类名: def 方法1(self,参数列表): pass def 方法2(self,参数列表): pass 方法的定义格式和函数一样。 方法里的第一个参数必须是self。. 类名要遵守大驼峰命名法。 创建实例对象当一个类定义完成之后，要使用这个类来创建对象，语法格式如下： 1对象变量名 = 类名() 案例需求 小猫 爱 吃 鱼，小猫 要 喝 水 分析 定义一个猫类 Cat 定义两个方法 eat 和 drink 按照需求 —— 不需要定义属性 12345678910111213141516class Cat: &quot;&quot;&quot;这是个猫类&quot;&quot;&quot; def eat(self): print(&quot;小猫在吃东西&quot;) def drink(self): print(&quot;小猫在喝水&quot;)tom = Cat() # 创建了一个Cat对象tom.eat()tom.drink()hello_kitty = Cat() # 又创建了一个新的Cat对象hello_kitty.eat()hello_kitty.drink( self的使用给对象添加属性python支持动态属性，当一个对象创建好了以后，直接使用 对象.属性名 = 属性值 就可以很方便的给对象添加一个属性。 12tom = Cat()tom.name = &#x27;Tom&#x27; # 可以直接给 tom 对象添加一个 name 属性 这种方法很方便，但是，不建议使用这种方式给对象添加属性。 self的概念哪个对象调用了方法，方法里的self指的就是谁。 通过 self.属性名 可以访问到这个对象的属性；通过 self.方法名() 可以调用这个对象的方法。 1234567891011class Cat: def eat(self): print(&quot;%s爱吃鱼&quot; %self.name)tom = Cat()tom.name = &#x27;Tom&#x27; # 给 tom 对象添加了一个name属性tom.eat() # Tom爱吃鱼lazy_cat = Cat()lazy_cat.name = &quot;大懒猫&quot;lazy_cat.eat() # 大懒猫爱吃鱼 直接给对象添加属性的缺点上述代码中，我们是先创建对象，然后再给对象添加 name 属性，但是这样做会有问题。 123tom = Cat()tom.eat()tom.name = &quot;Tom&quot; 程序运行时会报错： 12AttributeError: &#x27;Cat&#x27; object has no attribute &#x27;name&#x27;错误提示：&#x27;Cat&#x27;对象没有 &#x27;name&#x27; 属性 在日常开发中，不推荐在类的外部直接给对象添加属性这种方式。对象应该具有哪些属性，我们应该封装在类的内部。","categories":[{"name":"python","slug":"python","permalink":"http://example.com/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"http://example.com/tags/python/"}]},{"title":"css定位","slug":"css定位","date":"2017-06-01T03:42:18.000Z","updated":"2022-06-01T03:53:46.957Z","comments":true,"path":"2017/06/01/css定位/","link":"","permalink":"http://example.com/2017/06/01/css%E5%AE%9A%E4%BD%8D/","excerpt":"","text":"定位的作用 定位也是用来布局的，它有两部分组成：定位模式和边偏移。 边偏移 简单说，我们定位的盒子，是通过边偏移来移动位置的。在CSS中，通过top、bottom、left和right属性定义元素的边偏移 边偏移属性 示例 描述 top top: 80px 顶端偏移量，定义元素相对于其父元素上边线的距离。 bottom bottom: 80px 底部偏移量，定义元素相对于其父元素下边线的距离。 left left: 80px 左侧偏移量，定义元素相对于其父元素左边线的距离。 right right: 80px 右侧偏移量，定义元素相对于其父元素右边线的距离。 定位的盒子有了边偏移才有价值。一般情况下，凡是有定位地方必定有边偏移。 定位模式(position)在CSS中，通过position属性定义元素的定位模式，语法如下： 1选择器 &#123; position: 属性值; &#125; 定位模式是有不同分类的，在不同情况下，我们用到不同的定位模式。 值 语义 static 静态定位 relative 相对定位 absolute 绝对定位 fixed 固定定位 1.静态定位(static)-了解 静态定位是元素的默认定位方式，无定位的意思。它相当于border里面的none，不要定位的时候用。 静态定位 按照标准流特性摆放位置，它没有边偏移。 静态定位在布局时我们几乎不用的 2.相对定位(relative)-重要 相对定位是元素相对于它原来在标准流中的位置来说的。 效果图： 相对定位的特点： 相对于自己原来在标准流中位置来移动的 原来在标准流的区域继续占有，后面的盒子仍然以标准流的方式对待它。 3.绝对定位(absolute) - 重要 绝对定位是元素以带有定位的父级元素来移动位置 (拼爹型) 完全脱标——完全不占位置; 父元素没有定位，则以浏览器为准定位(Document 文档)。 父元素要有定位 将元素依据最近的已经定位(绝对、固定或相对定位)的父元素(祖先)进行定位。 绝对定位的特点：(务必记住) 绝对是以带有定位的父级元素来移动位置(拼爹型)如果父级都没有定位，则以浏览器文档为准移动位置 不保留原来的位置，完全是脱标的。 因为绝对定位的盒子是拼爹的，所以要和父级搭配一起来使用。 定位口诀——子绝父相 刚才咱们说过，绝对定位，要和带有定位的父级搭配使用，那么父级要用什么定位呢? 子绝父相——子级是绝对定位，父级要用相对定位。子绝父相是使用绝对定位的口诀，要牢牢记住! 观察下图，思考一下在布局时，左右两个方向的箭头图片以及父级盒子的定位方式。 分析： 1.方向箭头叠加在其他图片上方，应该使用绝对定位，因为绝对定位完全脱标，完全不占位置。 2.父级盒子应该使用相对定位，因为相对定位不脱标，后续盒子仍然以标准流的方式对待它。如果父级盒子也使用绝对定位，会完全脱标，那么下方的广告盒子会上移，这显然不是我们想要的。 结论：父级要占有位置，子级要任意摆放，这就是子绝父相的由来。 4. 固定定位(fixed)-重要 固定定位是绝对定位的一种特殊形式： 如果说绝对定位是一个矩形那么固定定位就类似于正方形 完全脱标——完全不占位置; 只认浏览器的可视窗口 —— 浏览器可视窗口 + 边偏移属性 来设置元素的位置; 跟父元素没有任何关系;单独使用的 不随滚动条滚动。","categories":[{"name":"css","slug":"css","permalink":"http://example.com/categories/css/"}],"tags":[{"name":"css","slug":"css","permalink":"http://example.com/tags/css/"}]},{"title":"javascript函数","slug":"javascript函数","date":"2017-05-26T03:24:17.000Z","updated":"2022-05-26T11:38:23.302Z","comments":true,"path":"2017/05/26/javascript函数/","link":"","permalink":"http://example.com/2017/05/26/javascript%E5%87%BD%E6%95%B0/","excerpt":"","text":"函数函数是一个代码块，定义之后，可以被执行或调用任意多次。Js函数是参数化的，即函数定义可以包含一组标识符，称为参数或形参。 定义函数在Js中定义函数最直观的方式就是使用function关键字，这个关键字可以用作声明或表达式。 命名函数的标识符 一对圆括号，中间包含逗号分隔的零或多个标识符。 一对花括号，其中包含零或多个Js语句。 123function 函数名(参数,参数2,......)&#123; 表达式&#125; 例如，这段代码定义了square，来引用一个函数，它产生给定数字的平方： 123456const square = function(x) &#123; return x * x;&#125;;console.log(square(12));// → 144 变量和作用域每个变量都有一个作用域，它是程序的一部分，其中变量是可见的。 对于在任何函数或块之外定义的变量，作用域是整个程序 - 您可以在任何地方引用这种变量。它们被称为全局的。 但是为函数参数创建的，或在函数内部声明的变量，只能在该函数中引用，所以它们被称为局部变量。 每次调用该函数时，都会创建这些变量的新实例。 这提供了函数之间的一些隔离 - 每个函数调用，都在它自己的小世界（它的局部环境）中运行，并且通常可以在不知道全局环境中发生的事情的情况下理解。 用let和const声明的变量，实际上是它们的声明所在的块的局部对象，所以如果你在循环中创建了一个，那么循环之前和之后的代码就不能“看见”它。JavaScript 2015 之前，只有函数创建新的作用域，因此，使用var关键字创建的旧式变量，在它们出现的整个函数中内都可见，或者如果它们不在函数中，在全局作用域可见。 12345678910let x = 10;if (true) &#123; let y = 20; var z = 30; console.log(x + y + z); // → 60&#125;// y is not visible hereconsole.log(x + z);// → 40 每个作用域都可以“向外查看”它周围的作用域，所以示例中的块内可以看到x。 当多个变量具有相同名称时例外 - 在这种情况下，代码只能看到最内层的那个。 例如，当halve函数中的代码引用n时，它看到它自己的n，而不是全局的n。 12345678const halve = function(n) &#123; return n / 2;&#125;let n = 10;console.log(halve(100));// → 50console.log(n);// → 10 嵌套作用域JavaScript 不仅区分全局和局部变量。 块和函数可以在其他块和函数内部创建，产生多层局部环境。 例如，这个函数的内部有另一个函数： 123456789101112131415const hummus = function(factor) &#123; const ingredient = function(amount, unit, name) &#123; let ingredientAmount = amount * factor; if (ingredientAmount &gt; 1) &#123; unit += &quot;s&quot;; &#125; console.log(`$&#123;ingredientAmount&#125; $&#123;unit&#125; $&#123;name&#125;`); &#125;; ingredient(1, &quot;can&quot;, &quot;chickpeas&quot;); ingredient(0.25, &quot;cup&quot;, &quot;tahini&quot;); ingredient(0.25, &quot;cup&quot;, &quot;lemon juice&quot;); ingredient(1, &quot;clove&quot;, &quot;garlic&quot;); ingredient(2, &quot;tablespoon&quot;, &quot;olive oil&quot;); ingredient(0.5, &quot;teaspoon&quot;, &quot;cumin&quot;);&#125;; ingredient函数中的代码，可以从外部函数中看到factor变量。 但是它的局部变量，比如unit或ingredientAmount，在外层函数中是不可见的。 简而言之，每个局部作用域也可以看到所有包含它的局部作用域。 块内可见的变量集，由这个块在程序文本中的位置决定。 每个局部作用域也可以看到包含它的所有局部作用域，并且所有作用域都可以看到全局作用域。 这种变量可见性方法称为词法作用域。 作为值的函数函数变量通常只充当程序特定部分的名称。 这样的变量被定义一次，永远不会改变。 这使得容易混淆函数和名称。 123456let launchMissiles = function(value) &#123; missileSystem.launch(&quot;now&quot;);&#125;;if (safeMode) &#123; launchMissiles = function() &#123;/* do nothing */&#125;;&#125; 箭头函数箭头函数的一般形式是圆括号中逗号分隔的参数列表，后跟箭头&#x3D;&gt;，再跟包含在花括号中的函数体： 1const sum = (x,y) =&gt;&#123;return x+y&#125; 调用函数语法： 123456function add(参数,参数2....)&#123;&#125;调用方法：add(参数,参数2....) 对象中方法调用 12345678let calculator = &#123; operand1 : 1, operand2 : 2, add()&#123; this.result = this.operand1 + this.operand2 &#125;&#125;calculator.add(); this关键字不具有变量那样的作用域机制，除了箭头函数，嵌套函数不会继承包含函数的this值。如果嵌套函数被当做方法来调用，那它的this值就是调用它的对象。 可选参数与默认值当调用函数时传入的实参少于声明的形参时，额外的形参会获得默认值，通常是undefined. 1234567891011121314//把对象o的可枚举属性名放到数组a中，返回a//如果不传a,则创建一个新数组function getPropertyNames(o,a)&#123; if(a === undefined)&#123; a = []; &#125; for(let property in o)&#123; a.push(property) &#125; return a;&#125;let o = &#123;x:1&#125;,p=&#123;y:2,z:3&#125;let a = getPropertyNames(o);getPropertyNames(p,a); 现在可以直接在函数形参列表中为每个参数定义默认值。语法是形参名后面加上等于号和默认值，这样在没有给该形参传值时就会使用这个默认值。 123456function getPropertyNames(o ,a = [])&#123; for(let property in o)&#123; a.push(property) &#125; return a;&#125; 闭包闭包（closure）就是能够读取其他函数内部变量的函数。 由于在Javascript语言中，只有函数内部的子函数才能读取局部变量，因此可以把闭包简单理解成”定义在一个函数内部的函数”。 所以，在本质上，闭包就是将函数内部和函数外部连接起来的一座桥梁。 变量作用域要理解闭包，首先必须理解Javascript特殊的变量作用域。 变量的作用域无非就是两种：全局变量和局部变量。 Javascript语言的特殊之处，就在于函数内部可以直接读取全局变量。 12345var n=999;function f1()&#123; alert(n);&#125;f1(); // 999 另一方面，在函数外部自然无法读取函数内的局部变量。 12345function f1()&#123; var n=999;&#125;alert(n); // error 这里有一个地方需要注意，函数内部声明变量的时候，一定要使用var命令。如果不用的话，你实际上声明了一个全局变量！ 1234567function f1()&#123; n=999;&#125;f1();alert(n); // 999 如何从外部获取内部变量出于种种原因，我们有时候需要得到函数内的局部变量。但是，前面已经说过了，正常情况下，这是办不到的，只有通过变通方法才能实现。 那就是在函数的内部，再定义一个函数。 1234567function f1()&#123; var n=999; function f2()&#123; alert(n); // 999 &#125;&#125; 在上面的代码中，函数f2就被包括在函数f1内部，这时f1内部的所有局部变量，对f2都是可见的。但是反过来就不行，f2内部的局部变量，对f1就是不可见的。这就是Javascript语言特有的”链式作用域”结构（chain scope），子对象会一级一级地向上寻找所有父对象的变量。所以，父对象的所有变量，对子对象都是可见的，反之则不成立。 既然f2可以读取f1中的局部变量，那么只要把f2作为返回值，我们不就可以在f1外部读取它的内部变量了吗！ 123456789101112131415function f1()&#123; var n=999; function f2()&#123; alert(n); &#125; return f2;&#125;var result=f1();result(); // 999 闭包的用途闭包可以用在许多地方。它的最大用处有两个，一个是前面提到的可以读取函数内部的变量，另一个就是让这些变量的值始终保持在内存中。 123456789101112131415161718192021function f1()&#123; var n=999; nAdd=function()&#123;n+=1&#125; function f2()&#123; alert(n); &#125; return f2;&#125;var result=f1();result(); // 999nAdd();result(); // 1000 在这段代码中，result实际上就是闭包f2函数。它一共运行了两次，第一次的值是999，第二次的值是1000。这证明了，函数f1中的局部变量n一直保存在内存中，并没有在f1调用后被自动清除。 为什么会这样呢？原因就在于f1是f2的父函数，而f2被赋给了一个全局变量，这导致f2始终在内存中，而f2的存在依赖于f1，因此f1也始终在内存中，不会在调用结束后，被垃圾回收机制（garbage collection）回收。 这段代码中另一个值得注意的地方，就是”nAdd&#x3D;function(){n+&#x3D;1}”这一行，首先在nAdd前面没有使用var关键字，因此nAdd是一个全局变量，而不是局部变量。其次，nAdd的值是一个匿名函数（anonymous function），而这个匿名函数本身也是一个闭包，所以nAdd相当于是一个setter，可以在函数外部对函数内部的局部变量进行操作。 立即执行函数立即执行函数通常有下面两种写法： 12345678//第一种写法(function()&#123; ...&#125;)();//第二种写法(function()&#123; ...&#125;()); 立即执行函数的作用 立即执行函数只有一个作用：创建一个独立的作用域。这个作用域里面的变量，外面访问不到（即避免了「变量污染」）。 123456var liList = ul.getElementsByTagName(&#x27;li&#x27;)for(var i=0; i&lt;6; i++)&#123; liList[i].onclick = function()&#123; alert(i) // 为什么 alert 出来的总是 6，而不是 0、1、2、3、4、5 &#125;&#125; 因为输出的 i 是全局作用域的，当循环结束后 i 的值是 6，所以输出的 i 就是6。 用立即执行函数可以解决这个问题。 12345678var liList = document.getElementsByTagName(&#x27;li&#x27;);for(var i=0; i&lt;6; i++)&#123; (function(j)&#123; liList[j].onclick = function()&#123; alert(j) // 0、1、2、3、4、5 &#125; &#125;)(i)&#125; 因为 JS 中调用函数传递参数都是值传递 ，所以当立即执行函数执行时，首先会把参数 i 的值复制一份，然后再创建函数作用域来执行函数，循环5次就会创建5个作用域，所以每个 li 元素访问的都是不同作用域的 i 的值 。","categories":[{"name":"javascript","slug":"javascript","permalink":"http://example.com/categories/javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://example.com/tags/javascript/"}]},{"title":"javascript对象","slug":"javascript对象","date":"2017-05-26T02:54:56.000Z","updated":"2022-05-26T11:38:46.781Z","comments":true,"path":"2017/05/26/javascript对象/","link":"","permalink":"http://example.com/2017/05/26/javascript%E5%AF%B9%E8%B1%A1/","excerpt":"","text":"对象对象是一种复合值，它汇聚多个值并允许它们按名字存储和获取这些值。对象是一个属性的无序集合，每个属性都有名字和值。 1）创建对象对象可以通过对象字面量、new关键字和object.create()函数来创建。 对象字面量创建对象最简单的方式是js代码中直接包含对象字面量。对象字面量的最简单形式是包含在一对花括号中的一组逗号分隔的“键:值”对。属性名是js标识符或字符串字面量。属性值是任何js的表达式，这个表达式的值会变成属性的值。 12let empty = &#123;&#125;let point = &#123;x:0,y:0&#125; 使用New创建对象new操作符用于创建和初始化一个新对象。new关键字后面必须跟一个函数调用。以这种方式使用的函数被称为构造函数，目的是初始化新创建的对象。 12let o = new Object(); //&#123;&#125;let a = new Array();//[] Object.create()ECMAScript 5 定义了一个名为 Object.create() 的方法，它创建一个新对象，其中第一个参数是这个对象的原型。Object.create() 提供第二个可选参数，用以对对象的属性进行进一步描述。Object.create() 是一个静态函数，而不是提供给某个对象调用的方法。使用它的方法很简单，只须传入所需的原型对象即可。例如： 123var person = Object.create(Object.prototype);person.name = &quot;stone&quot;;person.age = 28; 其中 var person = Object.create(Object.prototype); 也等价于 var person = &#123;&#125;; 。 2）原型所有通过对象字面量创建的对象都具有同一个原型对象，并可以通过 JavaScript 代码 Object.prototype 获得对原型对象的引用。通过关键字 new 和构造函数调用创建的对象的原型就是构造函数的 prototype 属性的值。因此，同使用 &#123;&#125; 创建对象一样，通过 new Object() 创建的对象也继承自 Object.prototype。同样，通过 new Array() 创建的对象的原型就是 Array.prototype，通过 new Date() 创建的对象的原型就是 Date.prototype。 没有原型的对象为数不多，Object.prototype 就是其中之一。它不继承任何属性。其他原型对象都是普通对象，普通对象都具有原型。所有的内置构造函数（以及大部分自定义的构造函数）都具有一个继承自 Object.prototype 的原型。例如，Date.prototype 的属性继承自 Object.prototype，因此由 new Date() 创建的 Date 对象的属性同时继承自 Date.prototype 和 Object.prototype。 3）查询或设置属性前面有提到过，可以通过点 . 或方括号 [] 运算符来获取属性的值。对于点 . 来说，左侧应当是一个对象，右侧必须是一个以属性名称命名的简单标识符。对于方括号来说 [] ，方括号内必须是一个计算结果为字符串的表达式，这个字符串就是属性的名称。例如： 1234567// 推荐写法console.log(person.name); // &quot;stone&quot;console.log(person.age); // &quot;28&quot;// 也可以写成console.log(person[&quot;name&quot;]); // stoneconsole.log(person[&quot;age&quot;]); // 28 和获取属性的值写法一样，通过点和方括号也可以创建属性或给属性赋值，但需要将它们放在赋值表达式的左侧。例如： 123456789// 推荐写法person.name = &quot;sophie&quot;; // 赋值person.age = 30; // 赋值person.weight = 38; // 创建// 也可以写成person[&quot;name&quot;] = &quot;sophie&quot;; // 赋值person[&quot;age&quot;] = 30; // 赋值person[&quot;weight&quot;] = 38; // 创建 当使用方括号时，方括号内的表达式必须返回字符串。更严格地讲，表达式必须返回字符串或返回一个可以转换为字符串的值。 查看一个对象本身的所有属性，可以使用Object.keys方法。 1234567var obj = &#123; key1: 1, key2: 2&#125;;Object.keys(obj);// [&#x27;key1&#x27;, &#x27;key2&#x27;] 4）属性的访问错误查询一个不存在的属性并不会报错，如果在对象 o 自身的属性或继承的属性中均未找到属性 x，属性访问表达式 o.x 返回 undefined。例如： 12var person = &#123;&#125;;person.wife; // undefined 但是，如果对象不存在，那么试图查询这个不存在的对象的属性就会报错。null 和 undefined 值都没有属性，因此查询这些值的属性会报错。例如： 12var person = &#123;&#125;;person.wife.name; // Uncaught TypeError: Cannot read property &#x27;name&#x27; of undefined. 除非确定 person 和 person.wife 都是对象，否则不能这样写表达式 person.wife.name，因为会报「未捕获的错误类型」，下面提供了两种避免出错的方法： 123456789// 冗余但易懂的写法var name;if (person) &#123; if (person.wife) name = person.wife.name;&#125;// 简练又常用的写法（推荐写法）var name = person &amp;&amp; person.wife &amp;&amp; person.wife.name; 5）删除属性delete操作符用于从对象中移除属性。它唯一的操作数应该是一个属性访问表达式。 123456var obj = &#123; p: 1 &#125;;Object.keys(obj) // [&quot;p&quot;]delete obj.p // trueobj.p // undefinedObject.keys(obj) // [] 上面代码中，delete命令删除对象obj的p属性。删除后，再读取p属性就会返回undefined，而且Object.keys方法的返回值也不再包括该属性。 注意，删除一个不存在的属性，delete不报错，而且返回true。 12var obj = &#123;&#125;;delete obj.p // true 上面代码中，对象obj并没有p属性，但是delete命令照样返回true。因此，不能根据delete命令的结果，认定某个属性是存在的。 另外，需要注意的是，delete命令只能删除对象本身的属性，无法删除继承的属性。 123var obj = &#123;&#125;;delete obj.toString // trueobj.toString // function toString() &#123; [native code] &#125; 上面代码中，toString是对象obj继承的属性，虽然delete命令返回true，但该属性并没有被删除，依然存在。这个例子还说明，即使delete返回true，该属性依然可能读取到值。 6）检测属性JavaScript 对象可以看做属性的集合，我们经常会检测集合中成员的所属关系（判断某个属性是否存在于某个对象中）。可以通过 in 运算符、hasOwnPreperty() 和 propertyIsEnumerable() 来完成这个工作，甚至仅通过属性查询也可以做到这一点。 in 运算符的左侧是属性名（字符串），右侧是对象。如果对象的自有属性或继承属性中包含这个属性则返回 true。例如： 1234var o = &#123; x: 1 &#125;console.log(&quot;x&quot; in o); // true，x是o的属性console.log(&quot;y&quot; in o); // false，y不是o的属性console.log(&quot;toString&quot; in o); // true，toString是继承属性 对象的 hasOwnProperty() 方法用来检测给定的名字是否是对象的自有属性。对于继承属性它将返回 false。例如： 1234var o = &#123; x: 1 &#125;console.log(o.hasOwnProperty(&quot;x&quot;)); // true，x是o的自有属性console.log(o.hasOwnProperty(&quot;y&quot;)); // false，y不是o的属性console.log(o.hasOwnProperty(&quot;toString&quot;)); // false，toString是继承属性 propertyIsEnumerable() 是 hasOwnProperty() 的增强版，只有检测到是自有属性且这个属性的可枚举性（enumerable attribute）为 true 时它才返回 true。某些内置属性是不可枚举的。通常由 JavaScript 代码创建的属性都是可枚举的，除非在 ECMAScript 5 中使用一个特殊的方法来改变属性的可枚举性。例如： 12345var o = inherit(&#123; y: 2 &#125;);o.x = 1;o.propertyIsEnumerable(&quot;x&quot;); // true:，x是o的自有属性，可枚举o.propertyIsEnumerable(&quot;y&quot;); // false，y是继承属性Object.prototype.propertyIsEnumerable(&quot;toString&quot;); // false，不可枚举 除了使用 in 运算符之外，另一种更简便的方法是使用 !== 判断一个属性是否是 undefined。例如： 1234var o = &#123; x: 1 &#125;console.log(o.x !== undefined); // true，x是o的属性console.log(o.y !== undefined); // false，y不是o的属性console.log(o.toString !== undefined); // true，toString是继承属性 然而有一种场景只能使用 in 运算符而不能使用上述属性访问的方式。in 可以区分不存在的属性和存在但值为 undefined 的属性。例如： 1234567var o = &#123; x: undefined &#125; // 属性被显式赋值为undefinedconsole.log(o.x !== undefined); // false，属性存在，但值为undefinedconsole.log(o.y !== undefined); // false，属性不存在console.log(&quot;x&quot; in o); // true，属性存在console.log(&quot;y&quot; in o); // false，属性不存在console.log(delete o.x); // true，删除了属性xconsole.log(&quot;x&quot; in o); // false，属性不再存在 7）枚举属性除了检测对象的属性是否存在，我们还会经常遍历对象的属性。通常使用 for-in 循环遍历，ECMAScript 5 提供了两个更好用的替代方案。 for-in 循环可以在循环体中遍历对象中所有可枚举的属性（包括自有属性和继承的属性），把属性名称赋值给循环变量。对象继承的内置方法不可枚举的，但在代码中给对象添加的属性都是可枚举的。例如： 123456789101112var obj = &#123;a: 1, b: 2, c: 3&#125;;for (var i in obj) &#123; console.log(&#x27;键名：&#x27;, i); console.log(&#x27;键值：&#x27;, obj[i]);&#125;// 键名： a// 键值： 1// 键名： b// 键值： 2// 键名： c// 键值： 3 for...in循环有两个使用注意点。 它遍历的是对象所有可遍历（enumerable）的属性，会跳过不可遍历的属性。 它不仅遍历对象自身的属性，还遍历继承的属性。 举例来说，对象都继承了toString属性，但是for...in循环不会遍历到这个属性。 12345678var obj = &#123;&#125;;// toString 属性是存在的obj.toString // toString() &#123; [native code] &#125;for (var p in obj) &#123; console.log(p);&#125; // 没有任何输出 上面代码中，对象obj继承了toString属性，该属性不会被for...in循环遍历到，因为它默认是“不可遍历”的。关于对象属性 的可遍历性，参见《标准库》章节中 Object 一章的介绍。 如果继承的属性是可遍历的，那么就会被for...in循环遍历到。但是，一般情况下，都是只想遍历对象自身的属性，所以使 用for...in的时候，应该结合使用hasOwnProperty方法，在循环内部判断一下，某个属性是否为对象自身的属性。 12345678var person = &#123; name: &#x27;老张&#x27; &#125;;for (var key in person) &#123; if (person.hasOwnProperty(key)) &#123; console.log(key); &#125;&#125;// name 8）属性的 getter 和 setter我们知道，对象属性是由名字、值和一组特性（attribute）构成的。在 ECMAScript 5 中，属性值可以用一个或两个方法替代，这两个方法就是 getter 和 setter。由 getter 和 setter 定义的属性称做「存取器属性（accessor property）」，它不同于「数据属性（data property）」，数据属性只有一个简单的值。 当程序查询存取器属性的值时，JavaScript 调用 getter 方法。这个方法的返回值就是属性存取表达式的值。当程序设置一个存取器属性的值时，JavaScript 调用 setter 方法，将赋值表达式右侧的值当做参数传入 setter。从某种意义上讲，这个方法负责「设置」属性值。可以忽略 setter 方法的返回值。 和数据属性不同，存取器属性不具有可写性（writable attribute）。如果属性同时具有 getter 和 setter 方法，那么它是一个读&#x2F;写属性。如果它只有 getter 方法，那么它是一个只读属性。如果它只有 setter 方法，那么它是一个只写属性，读取只写属性总是返回 undefined。定义存取器属性最简单的方法是使用对象直接量语法的一种扩展写法。例如： 12345678var o = &#123; // 普通的数据属性 data_prop: value, // 存取器属性都是成对定义的函数 get accessor_prop() &#123; /*这里是函数体 */ &#125;, set accessor_prop(value) &#123; /* 这里是函数体*/ &#125;&#125;; 存取器属性定义为一个或两个和属性同名的函数，这个函数定义没有使用 function 关键字，而是使用 get 或 set。注意，这里没有使用冒号将属性名和函数体分隔开，但在函数体的结束和下一个方法或数据属性之间有逗号分隔。 9）序列化对象（JSON）对象序列化（serialization）是指将对象的状态转换为字符串，也可将字符串还原为对象。ECMAScript 5 提供了内置函数 JSON.stringify() 和 JSON.parse() 用来序列化和还原 JavaScript 对象。这些方法都使用 JSON 作为数据交换格式，JSON 的全称是「JavaScript 对象表示法（JavaScript Object Notation）」，它的语法和 JavaScript 对象与数组直接量的语法非常相近。例如： 123o = &#123;x:1, y:&#123;z:[false,null,&quot;&quot;]&#125;&#125;; // 定义一个对象s = JSON.stringify(o); // s是 &#x27;&#123;&quot;x&quot;:1,&quot;y&quot;:&#123;&quot;z&quot;:[false,null,&quot;&quot;]&#125;&#125;&#x27;p = JSON.parse(s); // p是o的深拷贝 ECMAScript 5 中的这些函数的本地实现和 https://github.com/douglascrockford/JSON-js 中的公共域 ECMAScript 3 版本的实现非常类似，或者说完全一样，因此可以通过引入 json2.js 模块在 ECMAScript 3 的环境中使用 ECMAScript 5 中的这些函数。 JSON 的语法是 JavaScript 语法的子集，它并不能表示 JavaScript 里的所有值。它支持对象、数组、字符串、无穷大数字、true、false 和 null，可以序列化和还原它们。NaN、Infinity 和 -Infinity 序列化的结果是 null，日期对象序列化的结果是 ISO 格式的日期字符串（参照 Date.toJSON() 函数），但 JSON.parse() 依然保留它们的字符串形态，而不会将它们还原为原始日期对象。函数、RegExp、Error 对象和 undefined 值不能序列化和还原。JSON.stringify() 只能序列化对象可枚举的自有属性。对于一个不能序列化的属性来说，在序列化后的输出字符串中会将这个属性省略掉。JSON.stringify() 和 JSON.parse() 都可以接收第二个可选参数，通过传入需要序列化或还原的属性列表来定制自定义的序列化或还原操作。","categories":[{"name":"javascript","slug":"javascript","permalink":"http://example.com/categories/javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://example.com/tags/javascript/"}]},{"title":"javascript数组","slug":"javascript数组","date":"2017-05-14T03:24:06.000Z","updated":"2022-05-26T11:37:43.526Z","comments":true,"path":"2017/05/14/javascript数组/","link":"","permalink":"http://example.com/2017/05/14/javascript%E6%95%B0%E7%BB%84/","excerpt":"","text":"数组数组是值的有序集合。每个值叫做一个元素，而每个元素在数组中有一个位置，以数字表示，称为索引。 JavaScript 数组是无类型的，数组元素可以是任意类型，并且同一个数组中的不同元素也可能有不同的类型。数组的元素甚至也可能是对象或其他数组。 JavaScript 数组是动态的，根据需要它们会增长或缩减，并且在创建数组时无须声明一个固定的大小或者在数组大小变化时无须重新分配空间。 JavaScript 数组可能是稀疏的，数组元素的索引不一定要连续的，它们之间可以有空缺。每个 JavaScript 数组都有一个 length 属性。针对非稀疏数组，该属性就是数组元素的个数。针对稀疏数组，length 比所有元素的索引要大。 JavaScript 数组是 JavaScript 对象的特殊形式，数组索引实际上和碰巧是整数的属性名差不多。通常，数组的实现是经过优化的，用数字索引来访问数组元素一般来说比访问常规的对象属性要快很多。 数组继承自 Array.prototype 中的属性，它定义了一套丰富的数组操作方法。 1）创建数组1）数组字面量 12345678910var empty = []; // 没有元素的数组var primes = [2, 3, 5, 7, 11]; // 有5个数值的数组var misc = [1.1, true, &quot;a&quot;]; // 3个不同类型的元素// 数组直接量中的值不一定要是常量，可以是任意的表达式var base = 1024;var table = [base, base+1, base+2, base+3];// 也可以包含对象直接量或其他数组直接量var b = [[1, &#123;x:1, y:2&#125;], [2, &#123;x:3, y:4&#125;]]; 注意，不要忽略数组字面量的最后一个元素，仅以逗号结尾。下面几个案例，在不同的浏览器下，可能会被识别成2个元素，也有可能识别成3个元素，而造成程序bug。例如： 123var nums = [,,,]; // 不好的写法var names = [&quot;stone&quot;,,]; // 不好的写法var colors = [&quot;red&quot;,&quot;green&quot;,]; // 不好的写法 2）通过new Array()创建 12345678// 调用时没有参数var a = new Array();// 调用时有一个数值参数，它指定长度var a = new Array(10); // 显式指定多个数组元素或者数组的一个非数值元素var a = new Array(5, 4, 3, 2, 1, &quot;testing&quot;); 2）数组的读写使用 [] 操作符来访问数组中的一个元素。数组的引用位于方括号的左边。方括号中是一个返回非负整数值的任意表达式。使用该语法既可以读又可以写数组的一个元素。例如： 1234567var a = [&quot;world&quot;]; // 从一个元素的数组开始var value = a[0]; // 读第0个元素a[1] = 3.14; // 写第1个元素var i = 2; a[i] = 3; // 写第2个元素a[i + 1] = &quot;hello&quot;; // 写第3个元素a[a[i]] = a[0]; // 读第0个和第2个元素，写第3个元素 请记住，数组是对象的特殊形式，可以为其创建任意名字的属性。但如果使用的属性是数组的索引，数组的特殊行为就是将根据需要更新它们的length属性值。 注意，可以使用负数或非整数来索引数组。这种情况下，数值转换为字符串，字符串作为属性名来用。既然名字不是非负整数，它就只能当做常规的对象属性，而非数组的索引。同样，如果凑巧使用了是非负整数的字符串，它就当做数组索引，而非对象属性。当使用的一个浮点数和一个整数相等时情况也是一样的。例如： 123a[-1.23] = true; // 这将创建一个名为&quot;-1.23&quot;的属性a[&quot;1000&quot;] = 0; // 这是数组的第1001个元素a[1.000] // 和 a[1] 相等 事实上数组索引仅仅是对象属性名的一种特殊类型，这意味着 JavaScript 数组没有「越界」错误的概念。当试图查询任何对象中不存在的属性时，不会报错，只会得到 undefined 值。 3）稀疏数组稀疏数组就是包含从0开始的不连续索引的数组。通常，数组的 length 属性值代表数组中元素的个数。如果数组是稀疏的，length 属性值大于元素的个数。可以用 Array() 构造函数或简单地指定数组的索引值大于当前的数组长度来创建稀疏数组。 123a = new Array(5); // 数组没有元素，但是 a.length = 5a = []; // 创建一个空数组，a.length = 0a[1000] = 0; // 添加一个元素，a.length 被自动更新为1001 足够稀疏的数组通常在实现上比稠密的数组更慢、内存利用率更高，在这样的数组中查找元素的时间与常规对象属性的查找时间一样长。 需要注意的是，当省略数组直接量中的值时（使用连续的逗号，比如 [1,,3] ），这时所得到的数组也是稀疏数组，省略掉的值是不存在的： 1234var a1 = [,&#x27;1&#x27;,&#x27;2&#x27;]; // 此数组长度是3 var a2 = [undefined]; // 此数组包含一个值为 undefined 的元素 console.log(0 in a1); // false，a1 在索引0处没有元素console.log(0 in a2); // true，a2 在索引0处有一个值为 undefined 的元素 了解稀疏数组是了解 JavaScript 数组的真实本质的一部分。尽管如此，实际上你所碰到的绝大多数 JavaScript 数组不是稀疏数组。并且，如果你确实碰到了稀疏数组，你的代码很可能像对待非稀疏数组一样来对待它们，只不过它们包含一些 undefined 值。 4）数组的长度每个数组有一个 length 属性，就是这个属性使其区别于常规的 JavaScript 对象。针对稠密（也就是非稀疏）数组，length 属性值代表数组中元素的个数。其值比数组中最大的索引大1。例如： 12[].length // 0，数组没有元素[&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;].length // 3，最大的索引为2，length 为3 当数组是稀疏的时，length 属性值大于元素的个数。而且关于此我们可以说的一切也就是数组长度保证大于它每个元素的索引值。或者，换一种说法，在数组中（无论稀疏与否）肯定找不到一个元素的索引值大于或等于它的长度。为了维持此规则不变化，数组有两个特殊的行为。 第一个如同上面的描述：如果为一个数组元素赋值，它的索引 i 大于或等于现有数组的长度时，length 属性的值将设置为 i+1。 第二个特殊的行为就是设置 length 属性为一个小于当前长度的非负整数 n 时，当前数组中那些索引值大于或等于 n 的元素将从中删除。例如： 1234a = [1,2,3,4,5]; // 从5个元素的数组开始a.length = 3; // 现在 a 为[1,2,3]a.length = 0; // 删除所有的元素。a 为[ ]a.length = 5; // 长度为5，但是没有元素，就像 new Array(5) 还可以将数组的 length 属性值设置为大于其当前的长度。实际上这不会向数组中添加新的元素，它只是在数组尾部创建一个空的区域。 在 ECMAScript 5 中，可以用 Object.defineProperty() 让数组的 length 属性变成只读的。例如： 123a = [1,2,3]; // 从3个元素的数组开始Object.defineProperty(a, &quot;length&quot;, &#123;writable: false&#125;); // 让 length 属性只读a.length = 0; // a 不会改变 5）添加或删除数组元素push():向数组末尾添加一个或多个元素 123let a = [];a.push(&#x27;one&#x27;);a.push(&#x27;two&#x27;,&#x27;three&#x27;) pop():删除数组最后一个元素并返回该元素。 12let a = [&#x27;one&#x27;,&#x27;two&#x27;,&#x27;three&#x27;];a.pop(); shift():删除并返回数组的第一个元素 12let a = [&#x27;one&#x27;,&#x27;two&#x27;,&#x27;three&#x27;];a.shift(); unshift():想数组首位添加一个元素 123let a = [&#x27;one&#x27;,&#x27;two&#x27;,&#x27;three&#x27;];a.unshift(&#x27;four&#x27;);a.unshift(&#x27;five&#x27;,&#x27;six&#x27;); splice(index,num): 从下标index位置开始，删除num个元素 12let color = [&#x27;red&#x27;,&#x27;yellow&#x27;,&#x27;green&#x27;,&#x27;pink&#x27;];let b = color.splice(1,2);//从下标1的位置，删除两项，并将调用splice放的返回值存放在变量b中 arr.splice(index,0,val1,val2..):在下标index位置，添加多个元素 12let color = [&#x27;red&#x27;,&#x27;yellow&#x27;,&#x27;green&#x27;,&#x27;pink&#x27;];console.log(color.splice(1,0,&#x27;#fff&#x27;,&#x27;#000&#x27;)) arr.splice(index,num,val1,val2…):先删除后添加; 从index 位置开始，先删除num个元素，再添加多个新元素； 12let color = [&#x27;red&#x27;,&#x27;yellow&#x27;,&#x27;green&#x27;,&#x27;pink&#x27;];let result = color.splice(2,2,&#x27;black&#x27;,&#x27;white&#x27;) 6）数组迭代使用 for 循环是遍历数组元素最常见的方法。例如： 123456var keys = Object.keys(o); // 获得 o 对象属性名组成的数组var values = [] // 在数组中存储匹配属性的值for(var i = 0; i &lt; keys.length; i++) &#123; // 对于数组中每个索引 var key = keys[i]; // 获得索引处的键值 values[i] = o[key]; // 在 values 数组中保存属性值&#125; 在嵌套循环或其他性能非常重要的上下文中，可以看到这种基本的数组遍历需要优化，数组的长度应该只查询一次而非每次循环都要查询。例如： 123for(var i = 0, len = keys.length; i &lt; len; i++) &#123; // 循环体仍然不变&#125; 这些例子假设数组是稠密的，并且所有的元素都是合法数据。否则，使用数组元素之前应该先检测它们。例如： 123456for(var i = 0; i &lt; a.length; i++) &#123; if (!a[i]) continue; // 跳过 null、undefined 和不存在的元素 if (!(i in a)) continue ; // 跳过不存在的元素 if (a[i] === undefined) continue; // 跳过 undefined 和不存在的元素 // 循环体&#125; 还可以使用 for-in 循环处理稀疏数组。循环每次将一个可枚举的属性名（包括数组索引）赋值给循环变量，不存在的索引将不会遍历到。例如： 1234for(var index in sparseArray) &#123; var value = sparseArray[index]; // 此处可以使用索引和值做一些事情&#125; 但由于 for-in 循环能够枚举继承的属性名，如添加到 Array.prototype 中的方法。基于这个原因，在数组上不应该使用 for-in 循环，除非使用额外的检测方法来过滤不想要的属性。例如： 1234567for(var i in a) &#123; // 跳过继承的属性 if (!a.hasOwnProperty(i)) continue; // 跳过不是非负整数的 i if (String(Math.floor(Math.abs(Number(i)))) !== i) continue;&#125; JavaScript 规范允许 for-in 循环以不同的顺序遍历对象的属性。通常数组元素的遍历实现是升序的，但不能保证一定是这样的。如果数组同时拥有对象属性和数组元素，返回的属性名很可能是按照创建的顺序而非数值的大小顺序。如何处理这个问题的实现，各个浏览器都不相同，如果算法依赖于遍历的顺序，那么最好不要使用 for-in 而用常规的 for 循环。 forEach():迭代数组的每个元素，并对每个元素都调用一次指定的函数。 12345678let data = [1,2,3,4,5,6,7],sum = 0;data.forEach(function(item)&#123; sum +=item;&#125;)或data.forEach(item=&gt;&#123; sum +=item;&#125;) map():把调用它的数组的每个元素分别传给指定的函数，返回这个函数的返回值构成的数组。 123let a = [1,2,3];let result = a.map(x =&gt; x*x)console.log(result) filter():返回一个数组，该数组包含调用它的数组的子数组。 123let a = [1,2,3,4,5,6,7,8];let result = a.filter(x=&gt;x&lt;3)let res = a.filter((x,i) =&gt; i%2===0); **some()**：类似于数学上的“存在”量词，只要数组元素中有一个让断言函数返回true它就返回true,但必须数组的所有元素对断言函数都返回false才返回false. 123let a = [1,2,3,4,5]a.some(x=&gt;x%2===0);a.some(isNaN) every():与数学上的全称量词类似，它在且只有断言函数对数组的所有元素都返回true时才返回true 123let a = [1,2,3,4,5];a.every(x=&gt;x&lt;10)a.every(x=&gt; x%2 ===0); 7）数组检测给定一个未知的对象，判定它是否为数组通常非常有用。在 ECMAScript 5 中，可以使用 Array.isArray() 函数来做这件事情。例如： 12Array.isArray([]) // trueArray.isArray(&#123;&#125;) // false 但是，在 ECMAScript 5 以前，要区分数组和非数组对象很困难。typeof 运算符对数组返回 &quot;object&quot;（并且对于除了函数以外的所有对象都是如此）。instanceof 操作符也只能用于简单的情形。例如： 12[] instanceof Array // true(&#123;&#125;) instanceof Array // false 使用 instanceof 的问题是在 Web 浏览器中有可能有多个窗体存在。每个窗体都有自己的 JavaScript 环境，有自己的全局对象。并且，每个全局对象有自己的一组构造函数。因此一个窗体中的对象将不可能是另外窗体中的构造函数的实例。窗体之间的混淆不常发生，但这个问题足已证明 instanceof 操作符不能视为一个可靠的数组检测方法。 解决方案是检查对象的类属性，对数组而言该属性的值总是 &quot;Array&quot;，因此在 ECMAScript 3 中 isArray() 函数的代码可以这样书写。例如： 123var isArray = Array.isArray || function(o) &#123; return typeof o === &quot;object&quot; &amp;&amp; Object.prototype.toString.call(o) === &quot;[object Array]&quot;;&#125;; 8）反转数组reverse():数组反转 12let a = [1,2,3,4,5]a.reverse(); 9）数组排序sort():数组的排序语法：arr.sort(function(a,b){return a-b}); 1234567891011121314升序var arr = [34,7,23,9,5];arr.sort(function(a,b)&#123; return a-b;&#125;)降序var arr = [34,7,23,9,5];arr.sort(function(a,b)&#123; return b-a;&#125;)不传参：按照ASCII码排序var arr = [34,7,23,9,5];arr.sort();console.log(arr); 10）数组合并**concat()**：将多个数组内容拿出来，合并成一个新数组； 语法：arr.concat(arr,arr1,arr2,….) 123var arr = [&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;,&#x27;d&#x27;];var arr2 = [1,2,3];console.log(arr.concat(arr2)); 11）数组的截取slice():返回截取的内容 slice的截取时，包含开始位置，不包含截取位置； arr.slice(start,end);&#x2F;&#x2F;从开始start位置截取到end位置，不包含结束位置 arr.slice(start);&#x2F;&#x2F;从开始位置一直截取最后 arr.slice();&#x2F;&#x2F;不传参：表示，截取整个数组； slice();支持负值； slice()不会改变原数组 123456789101112传两个参数：var color = [&#x27;pink&#x27;,&#x27;red&#x27;,&#x27;yellow&#x27;,&#x27;blue&#x27;,&#x27;green&#x27;];console.log(color.slice(1,3))//从下标1开始截取到下标3，不包含下标3传一个参数var color = [&#x27;pink&#x27;,&#x27;red&#x27;,&#x27;yellow&#x27;,&#x27;blue&#x27;,&#x27;green&#x27;];var a = color.slice(1);//参数1表示从下标1开始一直截取到最后不传参var color = [&#x27;pink&#x27;,&#x27;red&#x27;,&#x27;yellow&#x27;,&#x27;blue&#x27;,&#x27;green&#x27;];var b = color.slice();//不传参，表示全部截取，将截取结果赋值给b参数为负值var color = [&#x27;pink&#x27;,&#x27;red&#x27;,&#x27;yellow&#x27;,&#x27;blue&#x27;,&#x27;green&#x27;];var c = color.slice(-3,4);//坐标= 负值+数组长度 -3+5 = 2(2,4) 12）数组索引indexOf():从数组前向后中搜索指定的值并返回第一个找到的元素的索引，如果没找到则返回-1. 123var color = [&#x27;pink&#x27;,&#x27;red&#x27;,&#x27;yellow&#x27;,&#x27;blue&#x27;,&#x27;green&#x27;];console.log(color.indexOf(&#x27;red&#x27;)) lastIndexOf():从数组后向前中搜索指定的值并返回第一个找到的元素的索引，如果没找到则返回-1. 12var color = [&#x27;pink&#x27;,&#x27;red&#x27;,&#x27;yellow&#x27;,&#x27;blue&#x27;,&#x27;green&#x27;];console.log(color.lastIndexOf(&#x27;red&#x27;)) 13）数组转字符串join():将数组的每一项通过连接符，拼接为一个新字符串； 12var color = [&#x27;pink&#x27;,&#x27;red&#x27;,&#x27;yellow&#x27;,&#x27;blue&#x27;,&#x27;green&#x27;];console.log(color.join(&#x27;,&#x27;))","categories":[{"name":"javascript","slug":"javascript","permalink":"http://example.com/categories/javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://example.com/tags/javascript/"}]},{"title":"javascript字符串","slug":"javascript字符串","date":"2017-05-05T03:19:08.000Z","updated":"2022-05-26T11:37:06.331Z","comments":true,"path":"2017/05/05/javascript字符串/","link":"","permalink":"http://example.com/2017/05/05/javascript%E5%AD%97%E7%AC%A6%E4%B8%B2/","excerpt":"","text":"String对象字符串的拼接可以使用“+”操作符 1let msg = &quot;Hello&quot; + &quot;World&quot;; 可以使用标准的全等&#x3D;&#x3D;&#x3D;和不全等!&#x3D;&#x3D;操作符进行字符串比较。 字符串也可以使用&lt;、&lt;&#x3D;、&gt;和&gt;&#x3D;操作符来比较，字符串比较是通过比较16位值完成的。 1）length:字符串长度12var s = &quot;hello world&quot;;console.log(s.length) 2）截取字符串1234var s = &quot;Hello World&quot;;s.substring(1,4);//取第2-4个字符s.slice(1,4);//同上s.slice(-3);最后3个字符 3）拆分字符串12var s = &quot;Hello,World&quot;;s.split(&quot;,&quot;);//[&quot;Hello&quot;,&quot;World&quot;]从定界符处拆开 4）搜索字符串1234var s = &quot;Hello World&quot;;s.indexOf(&quot;l&quot;); //第一个字母l的位置s.indexOf(&quot;l&quot;,3);//位置3后面第一个&quot;l&quot;的位置s.indexOf(&quot;zz&quot;);// -1,s并不包含子串&quot;zz&quot; 5）从后向前搜索字符串。12var s = &quot;Hello World&quot;;s.lastIndexOf(&#x27;l&#x27;)// 9 6）字符串已那些字符开头或结尾1234var s = &quot;Hello World&quot;;s.startWith(&quot;Hell&quot;);=&gt;trues.endWith(&quot;!&quot;)=&gt;falses.includes(&quot;or&quot;) ;=&gt;true 7）替换与正则表达式匹配的子串12var s = &quot;Hello World&quot;;s.replace(&quot;llo&quot;,&#x27;ya&#x27;) 8）把字符串转换为小写123var s = &quot;HELLO WORLD&quot;;s.toLowerCase();s.toLocaleLowerCase() 9）把字符串转换为大写123var s = &quot;hello world&quot;;s.toUpperCase();s.toLocaleUpperCase() 10）返回在指定位置的字符12var s = &quot;Hello World&quot;;s.charAt(0) 11）从起始索引号提取字符串中指定数目的字符12var str=&quot;Hello world!&quot;document.write(str.substr(3)) =&gt;lo world! 12）去除空格1234var s =&quot; Hello World &quot;;s.trim();//删除两侧空格s.trimStart();//删除左侧空格s.trimEnd();//删除右侧空格 13) 字符串填充123var s =&quot;Hello World&quot;;s.padStart(3,&#x27;*&#x27;);//左侧填充三个*s.padEnd(3,&#x27;*&#x27;);//右侧填充三个*","categories":[{"name":"javascript","slug":"javascript","permalink":"http://example.com/categories/javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://example.com/tags/javascript/"}]},{"title":"javascript语句","slug":"javascript语句","date":"2017-05-03T01:34:16.000Z","updated":"2022-05-26T11:37:15.367Z","comments":true,"path":"2017/05/03/javascript语句/","link":"","permalink":"http://example.com/2017/05/03/javascript%E8%AF%AD%E5%8F%A5/","excerpt":"","text":"语句表达式在 JavaScript 中是短语，那么语句就是整句命令。表达式用来计算出一个值，语句用来执行以使某件事发生。从本质上看，语句定义了 JavaScript 中的主要语法，语句通常使用一或多个关键字来完成给定任务。语句可以很简单，例如通知函数退出；也可以比较复杂，例如指定重复执行某个命令的次数。下表列出了 JavaScript 大部分语句的语法和用途： 语句 语法 用途 break break [label]; 退出最内层循环或者退出 switch 语句，又或者退出 label 指定的语句 case case expression: 在 switch 语句中标记一条语句 continue continue [label]; 重新开始最内层的循环或重新开始 label 指定的循环 debugger debugger; 断点器调试 default default; 在 switch 中标记默认的语句 do-while do statement while(expression); while 循环的一种替代形式 empty ; 什么都不做 for for(init;expr;incr) statement 简写的循环结构 for-in for(var in object) statement 遍历一个对象的属性 function function name([param[],...])&#123;statement&#125; 声明一个函数 if-else if (expression) statement1[else statement2] 执行 statement1 或者 statement2 label label:statement 给 statement 指定一个名字 label return return [expression]; 从函数返回一个值 switch switch(expression)&#123;statement&#125; 用 case 或者 default 语句标记的多分支语句 throw throw expression; 抛出异常 try try &#123;statement&#125;[catch &#123;handler statement&#125;][finally &#123;cleaup statement&#125;] 捕获异常 use strict &quot;use strict&quot; 对脚本和函数应用严格模式 var var name=[=expr][,...]; 声明并初始化一个或多个变量 while while(expression) statement 基本的循环结构 with with(object) statement 扩展作用域链 1)条件语句if-else 语句大多数编程语言中最为常用的一个语句就是 if-else 语句。以下是 if-else 语句的语法： 1if (condition) statement1 [else statement2] 其中的 condition 可以是任意表达式；而且对这个表达式求值的结果不一定是布尔值。JavaScript 会自动调用 Boolean() 转换函数将这个表达式的结果转换为一个布尔值。如果对 condition 求值的结果是 true，则执行 statement1，如果对 condition 求值的结果是 false，则执行 statement2。而且这两个语句既可以是一行代码，也可以是一个代码块（以一对花括号括起来的多行代码）。请看下面的例子： 12345if (i &gt; 25) console.log(&quot;Greater than 25.&quot;); // 单行语句else &#123; console.log(&quot;Less than or equal to 25.&quot;); // 代码块中的语句&#125; 业界普遍推崇的最佳实践是始终使用代码块，即使要执行的只有一行代码。因为这样可以消除人们的误解，否则可能让人分不清在不同条件下要执行哪些语句。 switch 语句switch 语句与 if 语句的关系最为密切，而且也是在其他语言中普遍使用的一种流控制语句。JavaScript 中 switch 语句的语法与其他基于 C 的语言非常接近，如下所示： 1234567891011switch (expression) &#123; case value: statement break; case value: statement break; case value: statement break; case value: statement break; default: statement&#125; switch 语句中的每一种情形的含义是：“如果表达式等于这个值（value），则执行后面的语句（statement）”。而 break 关键字会导致代码执行流跳出 switch 语句。如果省略 break 关键字，就会导致执行完当前 case 后，继续执行下一个 case。最后的 default 关键字则用于在表达式不匹配前面任何一种情形的时候，也相当于一个 else 语句。从根本上讲，switch 语句就是为了让开发人员免于编写像下面这样的代码： 123456789if (i === 25)&#123; console.log(&quot;25&quot;);&#125; else if (i === 35) &#123; console.log(&quot;35&quot;);&#125; else if (i === 45) &#123; console.log(&quot;45&quot;);&#125; else &#123; console.log(&quot;Other&quot;);&#125; 而与此等价的switch语句如下所示： 12345678910111213switch (i) &#123; case 25: console.log(&quot;25&quot;); break; case 35: console.log(&quot;35&quot;); break; case 45: console.log(&quot;45&quot;); break; default: console.log(&quot;Other&quot;);&#125; 通过为每个case后面都添加一个break语句，就可以避免同时执行多个case代码的情况。假如确实需要混合几种情形，不要忘了在代码中添加注释，说明你是有意省略了break关键字。 虽然 JavaScript 中的 switch 语句借鉴自其他语言，但这个语句也有自己的特色。首先，可以在 switch 语句中使用任何数据类型（在很多其他语言中只能使用数值），无论是字符串，还是对象都没有问题。其次，每个 case 的值不一定是常量，可以是变量，甚至是表达式。请看下面这两个例子： 12345678910111213141516171819202122232425switch (&quot;hello world&quot;) &#123; case &quot;hello&quot; + &quot; world&quot;: console.log(&quot;Greeting was found.&quot;); break; case &quot;goodbye&quot;: console.log(&quot;Closing was found.&quot;); break; default: console.log(&quot;Unexpected message was found.&quot;);&#125;var num = 25;switch (true) &#123; case num &lt; 0: console.log(&quot;Less than 0.&quot;); break; case num &gt;= 0 &amp;&amp; num &lt;= 10: console.log(&quot;Between 0 and 10.&quot;); break; case num &gt; 10 &amp;&amp; num &lt;= 20: console.log(&quot;Between 10 and 20.&quot;); break; default: console.log(&quot;More than 20.&quot;);&#125; switch 语句首先计算 switch 关键字后的表达式，然后按照从上到下的顺序计算每个 case 后的表达式，直到执行到 case 的表达式的值与 switch 的表达式的值相等时为止。由于对每个 case 的匹配操作实际上是 === 恒等运算符比较，而不是 == 相等运算符比较，因此，表达式和 case 的匹配并不会做任何类型转换。 2）循环while 语句while 语句属于前测试循环语句，也就是说，在循环体内的代码被执行之前，就会对出口条件求值。因引，循环体内的代码有可能永远不会被执行。以下是 while 语句的语法： 1while(expression) statement 下面是一个示例： 1234var i = 0;while (i &lt; 10) &#123; i += 2;&#125; do-while 语句do-while 语句是一种后测试循环语句，即只有在循环体中的代码执行之后，才会测试出口条件。换句话说，在对条件表达式求值之前，循环体内的代码至少会被执行一次。以下是 do-while 语句的语法： 123do &#123; statement&#125; while (expression); 下面是一个示例： 1234var i = 0;do &#123; i += 2;&#125; while (i &lt; 10); for 语句for 语句也是一种前测试循环语句，但它具有在执行循环之前初始化变量和定义循环后要执行的代码的能力。以下是 for 语句的语法： 1for (初始化变量; 条件表达式; 操作表达式) 循环体 下面是一个示例： 1234var count = 10;for (var i = 0; i &lt; count; i++)&#123; console.log(i);&#125; 这个 for 循环语句与下面的 while 语句的功能相同： 123456var count = 10;var i = 0;while (i &lt; count)&#123; console.log(i); i++;&#125; 由于 JavaScript 中不存在块级作用域，因此在循环内部定义的变量也可以在外部访问到。例如： 12345var count = 10;for (var i = 0; i &lt; count; i++)&#123; console.log(i);&#125;console.log(i); // 10 此外，for 语句中的初始化表达式、控制表达式和循环后表达式都是可选的。将这两个表达式全部省略，就会创建一个无限循环，例如： 12345// 无限循环for (;;) &#123; doSomething();&#125; for-in 语句for-in 语句是一种精准的迭代语句，可以用来枚举对象的属性。以下是 for-in 语句的语法： 1for (property in object) statement 下面是一个示例： 123for (var propName in window) &#123; console.log(propName);&#125; 在这个例子中，我们使用 for-in 循环来显示了 BOM 中 window 对象的所有属性。每次执行循环时，都会将 window 对象中存在的一个属性名赋值给变量 propName。这个过程会一直持续到对象中的所有属性都被枚举一遍为止。与 for 语句类似，这里控制语句中的 var 操作符也不是必需的。但是，为了保证使用局部变量，我们推荐上面例子中的这种做法。 JavaScript 对象的属性没有顺序。因此，通过 for-in 循环输出的属性名的顺序是不可预测的。具体来讲，所有属性都会被返回一次，但返回的先后次序可能会因浏览器而异。 如果表示要迭代的对象的变量值为 null 或 undefined，for-in 语句会抛出错误。虽然 ECMAScript 5 更正了这一行为；对这种情况不再抛出错误，而只是不执行循环体。为了保证最大限度的兼容性，建议在使用 for-in 循环之前，先检测确认该对象的值不是 null 或 undefined。 3）跳转break 和 continue 语句break 和 continue 语句用于在循环中精确地控制代码的执行。其中，break 语句会立即退出循环，强制继续执行循环后面的语句。而 continue 语句虽然也是立即退出循环，但退出循环后会从循环的顶部继续执行。请看下面的例子： 12345678910var num = 0;for (var i=1; i &lt; 10; i++) &#123; if (i % 5 == 0) &#123; break; &#125; num++;&#125;console.log(num); // 4 这个例子中的 for 循环会将变量 i 由1递增至 10。在循环体内，有一个 if 语句检查 i 的值是否可以被 5 整除（使用求模运算符）。如果是，则执行 break 语句退出循环。另一方面，变量 num 从 0 开始，用于记录循环执行的次数。在执行 break 语句之后，结果显示 4。也就是说，在变量 i 等于 5 时，循环总共执行了 4 次；而 break 语句的执行，导致了循环在 num 再次递增之前就退出了。如果在这里把 break 替换为 continue 的话，则可以看到另一种结果： 12345678910var num = 0;for (var i=1; i &lt; 10; i++) &#123;if (i % 5 == 0) &#123; continue; &#125; num++;&#125;console.log(num); // 8 例子的结果显示 8，也就是循环总共执行了 8 次。当变量 i 等于 5 时，循环会在 num 再次递增之前退出，但接下来执行的是下一次循环，即i的值等于 6 的循环。于是，循环又继续执行，直到 i 等于 10 时自然结束。而 num 的最终值之所以是 8，是因为 continue 语句导致它少递增了一次。 break 和 continue 语句都可以与 label 语句联合使用，从而返回代码中特定的位置。这种联合使用的情况多发生在循环嵌套的情况下，如下面的例子所示： 12345678910111213var num = 0;outermost:for (var i = 0; i &lt; 10; i++) &#123; for (var j = 0; j &lt; 10; j++) &#123; if (i == 5 &amp;&amp; j == 5) &#123; break outermost; &#125; num++; &#125;&#125;console.log(num); // 55 在这个例子中，outermost 标签表示外部的 for 语句。如果每个循环正常执行 10 次，则 num++ 语句就会正常执行 100 次。换句话说，如果两个循环都自然结束，num 的值应该是 100。但内部循环中的 break 语句带了一个参数：要返回到的标签。添加这个标签的结果将导致 break 语句不仅会退出内部的 for 语句（即使用变量 j 的循环），而且也会退出外部的 for 语句（即使用变量 i 的循环）。为此，当变量 i 和 j 都等于 5 时， num的值正好是 55。同样，continue 语句也可以像这样与 label 语句联用，如下面的例子所示： 12345678910111213var num = 0;outermost:for (var i = 0; i &lt; 10; i++) &#123; for (var j = 0; j &lt; 10; j++) &#123; if (i == 5 &amp;&amp; j == 5) &#123; continue outermost; &#125; num++; &#125;&#125;console.log(num); // 95 在这种情况下，continue 语句会强制继续执行循环，退出内部循环，执行外部循环。当 j 是 5 时，continue 语句执行，而这也就意味着内部循环少执行了 5 次，因此 num 的结果是 95。 虽然联用 break、continue 和 label 语句能够执行复杂的操作，但如果使用过度，也会给调试带来麻烦。在此，我们建议如果使用 label 语句，一定要使用描述性的标签，同时不要嵌套过多的循环。 return 语句return 语句的作用是指定函数调用后的返回值。return 语句的语法如下： 1return [expression]; 下面是一个示例： 12function square(x) &#123; return x*x; &#125; // 一个包含 return 语句的函数square(2); // 调用结果为 4 return 语句只能在函数体内出现，如果不是的话会报语法错误。当执行到 return 语句的时候，函数终止执行，并返回 expression 的值给调用程序。如果没有 return 语句，则函数调用仅依次执行函数体内的每一条语句直到函数结束，最后返回调用程序。这种情况下，调用表达式的结果是 undefined。return 语句经常作为函数内的最后一条语句出现，但并不是说要一定放在函数最后。return 语句可以单独使用而不必带有 expression，这样的话函数也会向调用程序返回 undefined。 由于 JavaScript 可以自动插入分号，因此在 return 关键字和它后面的表达式之间不能有换行。 4）其他with 语句with 语句的作用是将代码的作用域设置到一个特定的对象中。with 语句的语法如下： 1with (expression) statement; 定义 with 语句的目的主要是为了简化多次编写同一个对象的工作，如下面的例子所示： 123var qs = location.search.substring(1);var hostName = location.hostname;var url = location.href; 上面几行代码都包含 location 对象。如果使用 with 语句，可以把上面的代码改写成如下所示： 12345with(location)&#123; var qs = search.substring(1); var hostName = hostname; var url = href;&#125; 在这个重写后的例子中，使用 with 语句关联了 location 对象。这意味着在 with 语句的代码块内部，每个变量首先被认为是一个局部变量，而如果在局部环境中找不到该变量的定义，就会查询 location 对象中是否有同名的属性。如果发现了同名属性，则以 location 对象属性的值作为变量的值。 由于大量使用 with 语句会导致性能下降，同时也会给调试代码造成困难，因此在开发大型应用程序时，不建议使用 with 语句。严格模式下不允许使用 with 语句，否则将视为语法错误。 代码块代码块将多个语句组合为一个复合语句。代码块其实就是一系列语句，可以放在任何期待一个语句的地方： 12345&#123; x = Math.PI cx = Math.cos(x) console.log(&quot;cos(n)= &quot; + cx)&#125; 注意：1)它没有以分号结尾。块中的单条语句都以分号结尾，但块本身没有。2）块中的代码相对于包含它们的花括号缩进","categories":[{"name":"javascript","slug":"javascript","permalink":"http://example.com/categories/javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://example.com/tags/javascript/"}]},{"title":"javascript表达式和操作符","slug":"javascript表达式和操作符","date":"2017-04-23T08:18:22.000Z","updated":"2022-05-26T11:40:01.357Z","comments":true,"path":"2017/04/23/javascript表达式和操作符/","link":"","permalink":"http://example.com/2017/04/23/javascript%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%92%8C%E6%93%8D%E4%BD%9C%E7%AC%A6/","excerpt":"","text":"表达式与操作符1）表达式表达式是由数字、运算符、数字分组符号（如括号）、自由变量和约束变量等以能求得数值的有意义排列方法所得的组合。JavaScript 表达式主要有以下几种形式： 原始表达式：常量、变量、保留字。 对象、数组初始化表达式：var obj=&#123;a:1,b:2&#125;;，var arr=[1,2,3];。 函数定义表达式：var fn=function()&#123;&#125;。 属性访问表达式：Math.abs。 调用表达式：alert(&#39;hello&#39;);。 对象创建表达式：new object();。 1）函数定义表达式函数定义表达式通常用关键字function,位于括号中的逗号分隔的0或多个标识符，以及一个位于花括号中的js代码块构成。 12345let square = function(x)&#123; return x*x;&#125;或function square(x)&#123; return x*x;&#125; 2）属性访问表达式属性访问表达式求值为对象属性或数组元素的值，其语法结构为 12expression.identifierexpression[identifier] 第一种属性访问语法是表达式后跟着一个句点和一个标识符。其中，表达式指定对象，标识符指定属性名。第二种属性访问语法是表达式后跟另一个位于方括号中的表达式。这第二个表达式指定属性名或数组元素的索引。 123456let o = &#123;x:1,y:&#123;z:3&#125;&#125;;let a = [o,4,[5,6]]o.x;o.y.za[1]a[0] 2）运算符JavaScript 中的运算符用于算术表达式、比较表达式、逻辑表达式、赋值表达式等。需要注意的是，大多数运算符都是由标点符号表示的，比如 + 和 =。而另外一些运算符则是由关键字表示的，比如 typeof 和 instanceof，关键字运算符和标点符号都是正规的运算符。 下表列出了 JavaScript 中所有的运算符，并按照运算符的优先级排序的，前面的运算符优先级要高于后面的运算符优先级，被空行分隔开来的运算符具有不同的优先级。标题为 A 的列表示运算符的结合性（Associativity），L 表示从左至右、R 表示从右至左，标题为 N 的列表示操作数的个数（Number）。 运算符 操作 A N ++ 前&#x2F;后增量 R 1 -- 前&#x2F;后增量 R 1 - 求反 R 1 + 转换为数字 R 1 ~ 按位求反 R 1 ! 逻辑非 R 1 delete 删除属性 R 1 typeof 检测类型 R 1 void 返回undefined R 1 * / % 乘，除，求模 L 2 + - 加，减 L 2 + 字符串连接 L 2 &lt;&lt; 左移位 L 2 &gt;&gt; 有符号右移 L 2 &gt;&gt;&gt; 无符号右移 L 2 &lt; &lt;= &gt; &gt;= 比较数字顺序 L 2 &lt; &lt;= &gt; &gt;= 比较字母顺序 L 2 instanceof 测试对象类 L 2 in 测试属性是否存在 L 2 == 判断相等 L 2 != 判断不等 L 2 === 判断恒等 L 2 !== 判断恒不等 L 2 &amp; 按位与 L 2 ^ 按位异或 L 2 ┃ 按位或 L 2 &amp;&amp; 逻辑与 L 2 ┃┃ 逻辑或 L 2 ?: 条件运算符 R 3 = 赋值 R 2 *= /= %= += -= &amp;= &lt;&lt;= &gt;&gt;= ^= ┃= &gt;&gt;&gt;= 运算且赋值 R 2 , 忽略第一个操作数， 返回第二个操作数 L 2 因为 | 是制表符，会导致格式混乱，所以表格中的 | 均以 ┃ 代替。 1）一元运算符（1）delete 运算符delete 运算符用来删除对象属性或者数组元素，如果删除成功或所删除的目标不存在，delete 将返回 true。然而，并不是所有的属性都可删除，一些内置核心和客户端属性是不能删除的，通过 var 语句声明的变量不能删除，通过 function 语句定义的函数也是不能删除的。例如： 1234567891011121314151617var o = &#123; x: 1, y: 2&#125;; // 定义一个对象console.log(delete o.x); // true，删除一个属性console.log(delete o.x); // true，什么都没做，x 在已上一步被删除console.log(&quot;x&quot; in o); // false，这个属性在对象中不再存在console.log(delete o.toString); // true，什么也没做，toString是继承来的console.log(delete 1); // true，无意义var a = [&quot;x&quot;,&quot;y&quot;,&quot;z&quot;]; // 定义一个数组console.log(2 in a); // true，下标为2的元素，在数组中存在console.log(delete a[2]); // true，删除下标为2的元素（最后一个数组元素）console.log(2 in a); // false，下标为2的元素，在数组中不再存在console.log(a.length); // 3，数组长度并不会因 delete 而改变console.log(a[2]); // undefined，下标为2的元素，位置被空了出来console.log(delete a); // false，通过 var 语句声明的变量不能删除function f(args)&#123;&#125; // 定义一个函数console.log(delete f); // false，通过 function 语句声明的函数不能删除 （2）void 运算符void 运算符可以应用于任何表类型的表达式，表达式会被执行，但计算结果会被忽略并返回 undefined。例如： 1234567void 0;void &quot;you are useless?&quot;;void false;void [];void /(useless)/ig;void function()&#123; console.log(&quot;you are so useless?&quot;); &#125;// always return undefined （3）typeof 运算符鉴于 JavaScript 是松散类型的，因此需要有一种手段来检测给定变量的数据类型，typeof 就是负责提供这方面信息的运算符。对一个值使用 typeof 运算符可能返回下列某个字符串： &quot;undefined&quot;，如果这个值未声明或已声明但未初始化。 &quot;boolean&quot;，如果这个值是布尔值。 &quot;string&quot;，如果这个值是字符串。 &quot;number&quot;，如果这个值是数值。 &quot;object&quot;，如果这个值是对象或 null。 &quot;function&quot;，如果这个值是函数。 下面是几个使用 typeof 运算符的例子： 1234var message = &quot;some string&quot;;console.log(typeof message); // &quot;string&quot;console.log(typeof(message)); // &quot;string&quot;console.log(typeof 95); // &quot;number&quot; 从以上例子可以看出，typeof 运算符既可以对变量使用，又可以对字面量使用。由于 typeof 是一个运算符而不是函数，因此例子中的圆括号尽管可以使用，但并不提倡。 typeof null 结果是 &quot;object&quot; 是历史遗留 Bug，在 ECMAScript 6 中，曾经有提案为历史平反, 将 typeof null 的值纠正为 &quot;null&quot;，但最后该提案被拒。理由是历史遗留代码太多，不如继续将错就错。 （4）++ -- 运算符++ -- 递增递减运算符借鉴自 C 语言，它们分前置型和后置型，作用是改变一个变量的值。例如： 12345var a = 5;console.log(a++); // 5console.log(++a); // 7console.log(a--); // 7console.log(--a); // 5 （5）+ - 运算符当 + - 作为一元运算符时，应用于数值，表示数值的正负。应用于非数值，先按 Number() 转型函数对这个值执行转换，再表示该值的正负。 （6）~ ! 运算符 ~ 按位非运算符，请参见下面「位运算符」。! 逻辑非运算符，请参见下面「逻辑运算符」。 2）乘性运算符JavaScript 定义了3个乘性运算符：乘法、除法和求模。这些运算符与 C 语言的相应运算符用途类似，只不过在操作数为非数值的情况下会执行自动的类型转换。如果参与乘法计算的某个操作数不是数值，后台会先使用 Number() 转型函数将其转换为数值。也就是说，空字符串将被当作 0，布尔值 true 将被当作 1。 （1）* 乘法运算符用于计算两个数值的乘积，在处理特殊值的情况下，乘法运算符遵循下列特殊的规则： 如果操作数都是数值，执行常规的乘法计算，即两个正数或两个负数相乘的结果还是正数，而如果只有一个操作数有符号，那么结果就是负数。如果乘积超过了 JavaScript 数值的表示范围，则返回 Infinity 或 -Infinity； 如果有一个操作数是 NaN，则结果是 NaN； 如果是 Infinity 与 0 相乘，则结果是 NaN； 如果是 Infinity 与非 0 数值相乘，则结果是 Infinity 或 -Infinity，取决于有符号操作数的符号； 如果是 Infinity 与 Infinity 相乘，则结果是 Infinity；如果有一个操作数不是数值，则在后台调用 Number()将其转换为数值，然后再应用上面的规则。 （2）/ 除法运算符用于计算两个数值的商，与乘法运算符类似，除法运算符对特殊的值也有特殊的处理规则。这些规则如下： 如果操作数都是数值，执行常规的除法计算，即两个正数或两个负数相除的结果还是正数，而如果只有一个操作数有符号，那么结果就是负数。如果商超过了 JavaScript 数值的表示范围，则返回 Infinity 或 -Infinity； 如果有一个操作数是 NaN，则结果是 NaN； 如果是 Infinity 被 Infinity 除，则结果是 NaN； 如果是零被零除，则结果是 NaN； 如果是非零的有限数被零除，则结果是 Infinity 或 -Infinity，取决于有符号操作数的符号； 如果是 Infinity 被任何非零数值除，则结果是 Infinity 或 -Infinity，取决于有符号操作数的符号； 如果有一个操作数不是数值，则在后台调用 Number() 将其转换为数值，然后再应用上面的规则。 （3）% 求模运算符用于计算两个数值的余数，与另外两个乘性运算符类似，求模运算符会遵循下列特殊规则来处理特殊的值： 如果操作数都是数值，执行常规的除法计算，返回除得的余数； 如果被除数是无穷大值而除数是有限大的数值，则结果是 NaN； 如果被除数是有限大的数值而除数是零，则结果是 NaN； 如果是 Infinity 被 Infinity 除，则结果是 NaN； 如果被除数是有限大的数值而除数是无穷大的数值，则结果是被除数； 如果被除数是零，则结果是零； 如果有一个操作数不是数值，则在后台调用 Number() 将其转换为数值，然后再应用上面的规则。 3）加性运算符加法和减法这两个加性运算符应该说是编程语言中最简单的算术运算符了。但是在 JavaScript 中，这两个运算符却都有一系列的特殊行为。与乘性运算符类似，加性运算符也会在后台转换不同的数据类型。然而，对于加性运算符而言，相应的转换规则还稍微有点复杂。 + 加法运算符如果两个运算符都是数值，执行常规的加法计算，然后根据下列规则返回结果： 如果有一个操作数是 NaN，则结果是 NaN； 如果是 Infinity 加 Infinity，则结果是 Infinity； 如果是 -Infinity 加 -Infinity，则结果是 -Infinity； 如果是 Infinity 加- Infinity，则结果是 NaN； 如果是 +0 加 +0，则结果是 +0； 如果是 -0 加 -0，则结果是 -0； 如果是 +0 加 -0，则结果是 +0; 如果有一个操作数不是数值，那么就要应用如下规则： 如果两个操作数都是字符串，则将第二个操作数与第一个操作数拼接起来； 如果只有一个操作数是字符串，则将另一个操作数转换为字符串，然后再将两个字符串拼接起来。 如果有一个操作数是对象、数值或布尔值，则调用它们的 toString() 方法取得相应的字符串值，然后再应用前面关于字符串的规则。对于 undefined 和 null，则分别调用 String() 函数并取得字符串 &quot;undefined&quot; 和 &quot;null&quot;。 如果是 null 加 null，则结果是 0; 如果是 undefined 加 undefined，则结果是 NaN; 下面来举几个例子： 12345678910var result1 = 5 + 5; // 两个数值相加console.log(result1); // 10var result2 = 5 + &quot;5&quot;; // 一个数值和一个字符串相加console.log(result2); // &quot;55&quot;var num1 = 5;var num2 = 10;var message = &quot;The sum of 5 and 10 is &quot; + num1 + num2;console.log(message); // &quot;The sum of 5 and 10 is 510&quot;，如何修改？ - 减法运算符如果两个运算符都是数值，执行常规的减法计算，然后根据下列规则返回结果： 如果有一个操作数是 NaN，则结果是 NaN； 如果是 Infinity 减 Infinity，则结果是 NaN； 如果是 -Infinity 减 -Infinity，则结果是 NaN； 如果是 Infinity 减 -Infinity，则结果是 Infinity； 如果是 -Infinity 减 Infinity，则结果是 -Infinity； 如果是 +0 减 +0，则结果是 +0； 如果是 +0 减 -0，则结果是 -0； 如果是 -0 减 -0，则结果是 +0； 如果有一个操作数不是数值，那么就要应用如下规则： 如果有一个操作数是字符串、布尔值、null 或 undefined，则先在后台调用 Number() 函数将其转换为数值，然后再根据前面的规则执行减法计算。如果转换的结果是 NaN，则减法的结果就是 NaN； 如果有一个操作数是对象，则调用对象的 valueOf() 方法以取得表示该对象的数值。如果得到的值是 NaN，则减法的结果就是 NaN。如果对象没有 valueOf() 方法，则调用其 toString()方法并将得到的字符串转换为数值。 如果是 null 减 null，则结果是 0; 如果是 undefined 减 undefined，则结果是 NaN; 下面来举几个例子： 123456var result1 = 5 - true; // 4，因为true被转换成了1var result2 = NaN - 1; // NaNvar result3 = 5 - 3; // 2var result4 = 5 - &quot;&quot;; // 5，因为&quot;&quot; 被转换成了0var result5 = 5 - &quot;2&quot;; // 3，因为&quot;2&quot;被转换成了2var result6 = 5 - null; // 5，因为null被转换成了0 4）等值运算符确定两个变量是否相等是编程中的一个非常重要的操作。在比较简单数据类型之间的相等性时，问题还比较简单。但在涉及到对象之间的比较时，问题就变得复杂了。最早的 JavaScript 中的相等和不等运算符会在执行比较之前，先将对象转换成相似的类型。后来，有人提出了这种转换到底是否合理的质疑。最后，JavaScript 的解决方案就是提供两组运算符：相等和不相等（先转换再比较），恒等和不恒等（仅比较而不转换）。 == != 运算符== != 这两个运算符都会先转换操作数（通常称为强制转型），然后再比较它们的相等性。在转换不同的数据类型时，相等和不相等运算符遵循下列基本规则： 如果有一个操作数是布尔值，则在比较相等性之前先将其转换为数值（false 转换为 0，而 true 转换为 1）； 如果一个操作数是字符串，另一个操作数是数值，在比较相等性之前先将字符串转换为数值； 如果一个操作数是对象，另一个操作数不是，则调用对象的 valueOf() 方法，用得到的基本类型值按照前面的规则进行比较； null 和 undefined 是相等的。要比较相等性之前，不能将 null 和 undefined 转换成其他任何值。 如果有一个操作数是 NaN，则相等运算符返回 false，而不相等运算符返回 true。重要提示：即使两个操作数都是 NaN，相等运算符也返回 false；因为按照规则，NaN 不等于 NaN。 如果两个操作数都是对象，则比较它们是不是同一个对象。如果两个操作数都指向同一个对象，则相等运算符返回 true；否则，返回 false。 列出了一些特殊情况及比较结果： 1234567891011null == undefined // true&quot;NaN&quot; == NaN // false5 == NaN // falseNaN == NaN // falseNaN != NaN // truefalse == 0 // truetrue == 1 // truetrue == 2 // falseundefined == 0 // falsenull == 0 // false&quot;5&quot; == 5 // true === !== 运算符除了在比较之前不转换操作数之外，恒等和不恒等运算符与相等和不相等运算符没有什么区别。它只在两个操作数未经转换就相等的情况下返回 true，如下面的例子所示： 1234var result1 = (&quot;55&quot; == 55); // true，因为转换后相等var result2 = (&quot;55&quot; === 55); // false，因为不同的数据类型不相等var result3 = (null == undefined) // true，因为它们是类似的值var result4 = (null === undefined) // false，因为它们是不同类型的值 5）关系运算符&lt; &gt; &lt;= &gt;= 运算符&lt; 小于、&gt; 大于、&lt;= 小于等于、 &gt;= 大于等于 这几个关系运算符用于对两个值进行比较返回一个布尔值。与 JavaScript 中的其他运算符一样，当关系运算符的操作数使用了非数值时，也要进行数据转换或完成某些奇怪的操作。以下就是相应的规则。 如果两个操作数都是数值，则执行数值比较。 如果两个操作数都是字符串，则比较两个字符串对应的字符编码值（可以通过字符串的 charCodeAt() 函数获取字符编码值）。 如果一个操作数是数值，则将另一个操作数转换为一个数值，然后执行数值比较。 如果一个操作数是对象，则调用这个对象的 valueOf() 方法，用得到的结果按照前面的规则执行比较。如果对象没有 valueOf()方法，则调用 toString()方法，并用得到的结果根据前面的规则执行比较。 如果一个操作数是布尔值，则先将其转换为数值，然后再执行比较。 请思考下面几个例子的结果是如何得出的： 1234567var result1 = &quot;Brick&quot; &lt; &quot;alphabet&quot;; // truevar result2 = &quot;brick&quot; &lt; &quot;alphabet&quot;; // falsevar result3 = &quot;23&quot; &lt; &quot;3&quot;; // truevar result4 = &quot;23&quot; &lt; 3; // falsevar result5 = &quot;a&quot; &lt; 3; // falsevar result6 = NaN &lt; 3; // falsevar result7 = NaN &gt;= 3; // false in 运算符in 运算符希望它的左操作数是一个字符串或可以转换为字符串，希望它的右操作数是一个对象。如果右侧的对象拥有一个名为左操作数值的属性名，那么表达式返回 true，例如： 123456789var point = &#123; x:1, y:1 &#125;; // 定义一个对象&quot;x&quot; in point // true，对象有一个名为&quot;x&quot;的属性&quot;z&quot; in point // false，对象中不存在名为&quot;z&quot;的属性&quot;toString&quot; in point // true，对象继承了toString()方法var data = [7,8,9]; // 拥有三个元素的数组&quot;0&quot; in data // true，数组包含元素&quot;0&quot;1 in data // true，数字转换为字符串3 in data // false，没有索引为3的元素 instanceof 运算符instanceof 运算符希望左操作数是一个对象，右操作数标识对象的类。如果左侧的对象是右侧类的实例，则表达式返回 true；否则返回 false。后面会讲 JavaScript 中对象的类是通过初始化它们的构造函数来定义的。这样的话，instanceof 的右操作数应当是一个函数。比如： 123456789var d = new Date(); // 通过 Date() 构造函数来创建一个新对象d instanceof Date; // true，d 是由 Date() 创建的d instanceof Object; // true，所有的对象都是 Object 的实例d instanceof Number; // false，d 不是一个 Number 对象var a = [1, 2, 3]; // 通过数组字面量的写法创建一个数组a instanceof Array; // true，a 是一个数组a instanceof Object; // true，所有的数组都是对象a instanceof RegExp; // false，数组不是正则表达式 需要注意的是，所有的对象都是 Object 的实例。当通过 instanceof 判断一个对象是否是一个类的实例的时候，这个判断也会包含对「父类」的检测。如果 instanceof 的左操作数不是对象的话，instanceof 返回 false。如果右操作数不是函数，则抛出一个类型错误异常。 6）逻辑运算符逻辑运算符是对操作数进行布尔算术运算，经常和关系运算符一起配合使用，逻辑运算符将多个关系表达式组合起来组成一个更复杂的表达式。 &amp;&amp; 逻辑与逻辑与操作可以应用于任何类型的操作数，而不仅仅是布尔值。在有一个操作数不是布尔值的情况下，逻辑与操作不一定返回布尔值；此时，它遵循下列规则： 如果第一个操作数是对象，则返回第二个操作数； 如果第二个操作数是对象，则只有在第一个操作数的求值结果为 true 的情况下才会返回该对象； 如果两个操作数都是对象，则返回第二个操作数； 如果有一个操作数是 null，则返回 null； 如果有一个操作数是 NaN，则返回 NaN； 如果有一个操作数是 undefined，则返回 undefined。 逻辑与操作属于短路操作，即如果第一个操作数能够决定结果，那么就不会再对第二个操作数求值。对于逻辑与操作而言，如果第一个操作数是 false，无论第二个操作数是什么值，结果都不再可能是 true 了。 12console.log(3 &gt; 5 &amp;&amp; 3 &gt; 2); // falseconsole.log(3 &lt; 5 &amp;&amp; 3 &gt; 2); // true || 逻辑或与逻辑与操作相似，如果有一个操作数不是布尔值，逻辑或也不一定返回布尔值；此时，它遵循下列规则： 如果第一个操作数是对象，则返回第一个操作数； 如果第一个操作数的求值结果为 false，则返回第二个操作数； 如果两个操作数都是对象，则返回第一个操作数； 如果两个操作数都是 null，则返回 null； 如果两个操作数都是 NaN，则返回 NaN； 如果两个操作数都是 undefined，则返回 undefined。 与逻辑与运算符相似，逻辑或运算符也是短路运算符。也就是说，如果第一个操作数的求值结果为 true，就不会对第二个操作数求值了。 12console.log(3 &gt; 5 || 3 &gt; 2); // true console.log(3 &gt; 5 || 3 &lt; 2); // false ! 逻辑非逻辑非操作可以应用于任何类型的操作数，无论这个值是什么数据类型，这个运算符都会返回一个布尔值。逻辑非运算符首先会将它的操作数转换为一个布尔值，然后再对其求反。逻辑非运算符遵循下列规则： 如果操作数是一个对象，返回 false； 如果操作数是一个空字符串，返回 true； 如果操作数是一个非空字符串，返回 false； 如果操作数是数值 0，返回 true； 如果操作数是任意非 0 数值（包括 Infinity），返回 false； 如果操作数是 null，返回 true； 如果操作数是 NaN，返回 true； 如果操作数是 undefined，返回 true。 下面几个例子展示了应用上述规则的结果： 123456console.log(!false); // trueconsole.log(!&quot;blue&quot;); // falseconsole.log(!0); // trueconsole.log(!NaN); // trueconsole.log(!&quot;&quot;); // trueconsole.log(!12345); // false 逻辑非运算符也可以用于将一个值转换为与其对应的布尔值。而同时使用两个逻辑非运算符，实际上就会模拟 Boolean() 转型函数的行为。其中，第一个逻辑非操作会基于无论什么操作数返回一个布尔值，而第二个逻辑非操作则对该布尔值求反，于是就得到了这个值真正对应的布尔值。当然，最终结果与对这个值使用 Boolean() 函数相同，例如： 12345console.log(!!&quot;blue&quot;); //trueconsole.log(!!0); //falseconsole.log(!!NaN); //falseconsole.log(!!&quot;&quot;); //falseconsole.log(!!12345); //true 7）位运算符在 JavaScript 中，当对数值应用位运算符时，后台会发生如下转换过程：64位的数值被转换成32位数值，然后执行位操作，最后再将32位的结果转换回64位数值。这个转换过程导致了一个严重的副效应，即在对特殊的 NaN 和 Infinity 值应用位操作时，这两个值都会被当成 0 来处理。如果对非数值应用位运算符，会先使用 Number() 函数将该值转换为一个数值，然后再应用位操作，得到的结果将是一个数值。 ~ 按位非简单的理解，对任一数值 x 进行按位非操作的结果为 -(x+1)。例如： 1234567891011console.log(~null); // -1console.log(~undefined); // -1console.log(~0); // -1console.log(~&#123;&#125;); // -1console.log(~[]); // -1console.log(~(1/0)); // -1console.log(~false); // -1console.log(~true); // -2console.log(~1.2543); // -2console.log(~4.9); // -5console.log(~(-2.999)); // 1 &amp; 按位与按位与操作就是将两个数值的每一位对齐，两个数值的对应位都是 1 时才返回 1，任何一位是 0，结果都是 0。如下表所示： 第一个数值的位 第二个数值的位 结果 1 1 1 1 0 0 0 1 0 0 0 0 | 按位或按位或操作就是将两个数值的每一位对齐，两个数值只要有一个位是 1 就返回 1，只在两个位都是 0 的情况下才返回 0。如下表所示： 第一个数值的位 第二个数值的位 结果 1 1 1 1 0 1 0 1 1 0 0 0 ^ 按位异或按位异或与按位或的不同之处在于，两个数值只有一个 1 时才返回 1，如果对应的两位都是 1 或都是 0，则返回 0。 第一个数值的位 第二个数值的位 结果 1 1 0 1 0 1 0 1 1 0 0 0 &lt;&lt; 左移这个运算符会将数值的所有位向左移动指定的位数。例如： 12var oldValue = 2; // 等于二进制的 10var newValue = oldValue &lt;&lt; 5; // 等于二进制的 1000000，十进制的 64 注意，左移不会影响操作数的符号位。换句话说，如果将 -2 向左移动 5 位，结果将是 -64，而非 64。 &gt;&gt; 有符号的右移这个运算符会将数值向右移动，但保留符号位（即正负号标记）。 12var oldValue = 64; // 等于二进制的 1000000var newValue = oldValue &gt;&gt; 5; // 等于二进制的 10 ，即十进制的 2 &gt;&gt;&gt; 无符号的右移这个运算符会将数值的所有32位都向右移动。对正数来说，无符号右移的结果与有符号右移相同。 12var oldValue = 64; // 等于二进制的 1000000var newValue = oldValue &gt;&gt;&gt; 5; // 等于二进制的 10 ，即十进制的 2 无符号右移运算符会把负数的二进制码当成正数的二进制码。而且，由于负数以其绝对值的二进制补码形式表示，因此就会导致无符号右移后的结果非常之大。 12var oldValue = -64; // 等于二进制的 11111111111111111111111111000000var newValue = oldValue &gt;&gt;&gt; 5; // 等于十进制的 134217726 8）赋值运算符简单的赋值运算符由等于号 = 表示，其作用就是把右侧的值赋给左侧的变量，如下面的例子所示： 1var num = 10; 如果在等于号 = 前面再添加乘性运算符、加性运算符或位运算符，就可以完成复合赋值操作。这种复合赋值操作相当于是对下面常规表达式的简写形式： 12var num = 10;num += 10; // 等同于 num = num + 10; 每个主要算术运算符（以及个别的其他运算符）都有对应的复合赋值运算符。这些运算符如下所示： 乘&#x2F;赋值 *=； 除&#x2F;赋值 /=； 模&#x2F;赋值 %=； 加&#x2F;赋值 +=； 减&#x2F;赋值 -=； 左移&#x2F;赋值 &lt;&lt;=； 有符号右移&#x2F;赋值 &gt;&gt;=； 无符号右移&#x2F;赋值 &gt;&gt;&gt;=。 设计这些运算符的主要目的就是简化赋值操作，使用它们不会带来任何性能的提升。 9）条件运算符? : 条件运算符应该算是 JavaScript 中最灵活的一种运算符了，而且它遵循与 Java 中的条件运算符相同的语法形式，如下面的例子所示： 1variable = boolean_expression ? true_value : false_value; 10）逗号运算符逗号运算符多用于声明多个变量；但除此之外，逗号运算符还可以用于赋值。在用于赋值时，逗号运算符总会返回表达式中的最后一项，如下面的例子所示： 1var num = (5, 1, 4, 8, 0); // num 的值为 0 由于 0 是表达式中的最后一项，因此 num 的值就是 0。虽然逗号的这种使用方式并不常见，但这个例子可以帮我们理解逗号的这种行为。","categories":[{"name":"javascript","slug":"javascript","permalink":"http://example.com/categories/javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://example.com/tags/javascript/"}]},{"title":"javascript类型、值和变量","slug":"javascript类型、值和变量","date":"2017-04-23T00:08:27.000Z","updated":"2022-05-26T11:38:09.427Z","comments":true,"path":"2017/04/23/javascript类型、值和变量/","link":"","permalink":"http://example.com/2017/04/23/javascript%E7%B1%BB%E5%9E%8B%E3%80%81%E5%80%BC%E5%92%8C%E5%8F%98%E9%87%8F/","excerpt":"","text":"类型、值和变量JavaScript类型可以分为两类：原始类型和对象类型。 原始类型包括数值、字符串、布尔值、特殊值null、undefined。其中null和undefined不是数值、字符串或布尔值，通常被认为 是各自特殊类型的唯一成员。 对象是属性的集合，其中每个属性都有一个名字和一个值。 注意：任何不是数值、字符串、布尔值、符号、null和undefined的值都是对象。 在内存管理方面，js解析器会执行自动垃圾收集。当程序无法以任何方式引用这个值时，解释器会自动释放它占用的内存。 1）数值 整数 Number用于表示整数和近似实数。 Number 类型是 JavaScript 中最令人关注的数据类型，这种类型使用 IEEE 754 格式来表示整数和浮点数值（浮点数值在某些语言中也被称为双精度数值）。和其他编程语言不同，JavaScript 中的所有数字均用浮点数值表示。 在 JavaScript 中进行算术计算时，所有以八进制和十六进制表示的数值最终都将被转换成十进制数值。例如： 1234567var a = 10; // 十进制var b = 023; // 八进制var c = 0x12ac; // 十六进制0xff = 255；（15*16+15） // 十六进制0xbadcafe // =&gt;195939070 // 十六进制console.log(b); // 19console.log(c); // 4780 八进制第一位必须是0，后面跟八进制序列0到7，如果超出了范围，则忽略前导0，后面的数值当做十进制解析，例如：089会被解析为89。（八进制字面量在严格模式下是无效的，会抛出错误。） 十六进制前两位必须是 0x 或 0X，后跟十六进制序列09、af（10~15）（不区分大小写），如果超出了范围，则会报语法错误。 浮点数 所谓浮点数值，就是该数值中必须包含一个小数点，并且小数点后面必须至少有一位数字。虽然小数点前面可以没有整数，但我们不推荐这种写法。例如： 123var a = 1.1;var b = 0.1;var c = .1; // 有效，但不推荐 JavaScript 会不失时机的将浮点数转换成整数。例如： 12var a = 5.; // 解析成整数5var b = 5.0; // 解析成整数5 对于极大或者极小的数值，可采用科学技术法（也称e表示法）。JavaScript 会将那些小数点后面带有6个零以上的小于1的浮点数值转换为以e表示法表示的数值。例如： 123var a = 3.14e7; // 等于31400000var b = 3.14E-7; // 等于0.000000314console.log(0.0000003); // 3e-7 浮点数值的最高精度是17位小数，但在进行算术计算时其精确度远远不如整数，例如： 1console.log(0.1 + 0.2); // 0.30000000000000004 这个舍入误差会导致无法测试特定的浮点数值，因此，永远不要测试某个特定的浮点数值。 Js使用的IEEE~754浮点法是一种二进制表示法，这种表示法可以精确地表示如1&#x2F;2,1&#x2F;8,1&#x2F;1024等分数。然而我们常用的十进制 分数：1&#x2F;10,1&#x2F;100等等，二进制浮点表示法无法精确表示。 123456例如：let x = .3 - .2 ;//这个数值只能非常近似地表示0.1，但无法精确的表示。let y = .2 - .1;x ===y; ==&gt;falsex ===.1; ==&gt;falsey ===.1; ==&gt;true 正无穷、负无穷 由于内存限制，JavaScript 能表示的数值范围从 Number.MIN_VALUE 到 Number.MAX_VALUE，并将超出范围的数转换成 Number.POSITIVE_INFINITY 或 Number.NEGATIVE_INFINITY。0作为除数是不会报错的，正数除以0返回正无穷，负数除以0返回负无穷，0除以0返回NaN。例如： 123456789console.log(Number.MAX_VALUE); // 最大数 1.7976931348623157e+308console.log(Number.MIN_VALUE); // 最小数 5e-324console.log(Number.POSITIVE_INFINITY); // 正无穷 Infinityconsole.log(Number.NEGATIVE_INFINITY); // 负无穷 -Infinityconsole.log( 1 / 0); // Infinityconsole.log(-1 / 0); // -Infinity JavaScript 提供了 isFinite() 函数，来确定一个数是不是有穷的。例如： 12console.log(isFinite(100)); // trueconsole.log(isFinite(Infinity)); // false NaN NaN（not a number），是一个特殊的数值。之所以称它为「非数值」，是因为它不能参与算数运算，任何涉及 NaN 的操作都返回 NaN。并且 NaN 与任何值都不相等（包括自身）。例如： 12345678console.log(typeof NaN); // &quot;number&quot;console.log(0 / 0); // NaNconsole.log(NaN - NaN); // NaNconsole.log(Infinity - Infinity); // NaNvar a = NaN;console.log(a === a); // false JavaScript 提供了 isNaN() 函数，来确定一个数是不是 NaN。例如： 12345console.log(isNaN(100)); // falseconsole.log(isNaN(&quot;100&quot;)); // falseconsole.log(isNaN(true)); // falseconsole.log(isNaN(&quot;sss&quot;)); // trueconsole.log(isNaN(NaN)); // true Number()、parseInt()、parseFloat()转型函数 isNaN() 函数在接收到一个值之后，会尝试使用转型函数 Number() 将这个值转换为数值，转换规则如下： undefined 转换为 NaN； null 转换为 0； true 转换为 1、false 转换为 0； number 整数转换为十进制，小数不变； string 如果只包含十进制数和小数，则返回对应的数值，如果只包含八进制数，则忽略前导0返回剩余部分，如果只包含十六进制，则返回十进制数，空字符串转换为0，其它字符串转换为 NaN； 如果 object 具有 valueOf() 方法，且返回一个原始值（5种简单数据类型），则将这个原始值转换为数字，并返回这个数字；否则，如果 object 具有 toString() 方法，且返回一个原始值，则将这个原始值转换为数字，并返回这个数字；否则，抛出一个类型错误异常。 由于 Number() 转型函数在转换字符串时不够理想，因此还有两个专门用来转换字符串的函数 parseInt() 和 parseFloat() 函数。 parseInt() 函数会忽略字符串前面的空格，直至找到第一个非空格字符，只要第一个非空格字符不是数字或者正负号，一律返回 NaN， 如果第一个非空格字符是数字字符，parseInt() 会继续解析第二个字符，直到解析完所有后续字符或者遇到了一个非数字字符。例如： 123console.log(parseInt(&quot;&quot;)); // NaN（Number(&quot;&quot;)返回 0）console.log(parseInt(&quot;123S&quot;)); // 123console.log(parseInt(&quot;12.4&quot;)); // 12 parseFloat() 函数也会忽略字符串前面的空格，直至找到第一个非空格字符，只要第一个非空格字符不是数字或者正负号或者小数点，一律返回 NaN， 如果第一个非空格字符是上述字符之一，parseFloat() 会继续解析第二个字符，直到解析完所有后续字符或者遇到了一个非浮点数值。例如： 12console.log(parseFloat(&quot;098.2&quot;)); // 98.2console.log(parseFloat(&quot;123.23.23&quot;)); // 123.23 2）字符串字符串是16位值的不可修改的有序序列，其中每个值都表示一个Unicode字符。 在Js中可以使用单引号、双引号或者反引号(‘ ‘ ,” “,&#96;&#96;)包含起来来表示字符串，双引号和反引号可以出现在由单引号定界的字符 串中，同理由双引号和反引号定界的字符串里也可以包含另外两种引号。 12345&quot; &quot; //空字符串&#x27;testing&#x27;&quot;3.14&quot;&quot;Wouldn&#x27;t you prefer o&#x27;Reilly&#x27;s Books&quot;`&quot;she said &#x27;hi&#x27;&quot;,he said` 转义序列 12345678910\\0 Null字符\\b 退格符\\t 水平制表符\\n 换行符\\f 进制符\\r 回车符\\&quot; 双引号\\&#x27; 单引号\\\\ 反斜杠\\xnn 由2位16进制数字nn指定的Unicode字符 转义字符可出现在字符串中的任意位置，且长度为1。如要在字符串中显示 \\ ，则必须使用 \\ 进行转义。例如： 12console.log(&quot;\\n\\\\&quot;.length); // 2console.log(&quot;\\\\hello&quot;); // &quot;\\hello&quot;（长度为6） 大部分值都可以使用继承而来的 toString()方法转换为字符串，但 undefined 和 null 值没有这个方法。对数值使用 toString() 方法时，可以传入一个数字基数，以此输出对应进制的字符串值。例如： 1234567console.log(true.toString()); // &quot;true&quot;var num = 10;console.log(num.toString()); // &quot;10&quot;console.log(num.toString(2)); // &quot;1010&quot;console.log(num.toString(8)); // &quot;12&quot;console.log(num.toString(16)); // &quot;a&quot; 在不知道要转换的值是不是 undefined 或 null 的情况下，还可以使用转型函数 String()，这个函数能够将任何类型的值转换为字符串。String() 函数遵循下列转换规则： 如果值有 toString() 方法，则调用该方法（没有参数）并返回相应的结果； 如果值是 undefined，则返回 &quot;undefined&quot;； 如果值是 null，则返回 &quot;null&quot;。 12345var value;console.log(String(10)); // &quot;10&quot;console.log(String(true)); // &quot;true&quot;console.log(String(null)); // &quot;null&quot;console.log(String(value)); // &quot;undefined&quot; 3）布尔值Boolean 类型是 JavaScript 中使用得最多的一种类型，该类型只有两个字面值：true 和 false。需要注意的是，他们是区分大小写的，也就是说 True 和 False（以及其他的混合大小写形式）都不是 Boolean 值，只是标识符。 虽然 Boolean 类型的字面值只有两个，但 JavaScript 中所有类型的值都能使用 if 语句或 Boolean() 函数转换为对应的 Boolean 值，例如： 123456var message = &quot;Hello world!&quot;;if (message)&#123; console.log(&quot;Value is true.&quot;); // 被执行&#125;var messageAsBoolean = Boolean(message);console.log(messageAsBoolean); // true 下表给出了各种数据类型及其对应的转换规则。 数据类型 转换为true的值 转换为false的值 Undefined - undefined Null - null Boolean true false String 任何非空字符串 “”（空字符串） Number 任何非零数字值（包括无穷大） 0和NaN Object 任何对象 - 4）null和undefinedUndefined 类型只有1个值，即 undefined。使用 var 声明变量但未对其加以初始化时，这个变量的值就是 undefined，直接使用未声明的变量会产生错误。对未声明或已声明但未初始化的变量执行 typeof 运算符会返回 &quot;undefined&quot; 值，例如： 1234567var message; // 这个变量声明之后默认取得了 undefined 值// var age // 这个变量并没有声明console.log(message); // &quot;undefined&quot;console.log(age); // 产生错误console.log(typeof message); // &quot;undefined&quot;console.log(typeof age); // &quot;undefined&quot; Null 类型也只有1个值，即 null。它用来表示值的空缺。你可以认为 undefined 是表示系统级的、出乎意料的或类似错误的值的空缺，而 null 是表示程序级的、正常的或在意料之中的值的空缺。在下列场景中应当使用 null。 用来初始化一个变量，这个变量可能赋值为一个对象。 用来和一个已经初始化的变量比较，这个变量可以是也可以不是一个对象。 当函数的参数期望是对象时，作用参数传入。 当函数的返回值期望是对象时，作用返回值传出。 在下列场景中不应当使用 null。 不要使用 null 来检测是否传入了某个参数。 不要使用 null 来检测一个未初始化的变量。 5）全局对象全局对象的属性是全局性定义的标识符，可以在js程序的任何地方使用。js解释器启动后都会创建一个新的全局对象并为其添加一组初始的属性。 6）对象和数组JavaScript 中所有对象都继承自 Object 类型，每个对象都具有下列基本的属性和方法： constructor：保存着用于创建当前对象的函数（构造函数）。 hasOwnProperty()：用于检查给定的属性在当前对象实例中是否存在。 propertyIsEnumerable()：用于检查给定的属性是否能够使用for-in语句来枚举。 isPrototypeOf()：用于检查对象是否是传入对象的原型。 toString() 方法：返回对象的字符串表示。 toLocaleString()：返回对象的本地字符串表示。 valueOf()：返回对象的字符串、数值或布尔值表示（通常与toString()方法的返回值相同）。 Object 本质上是由一组无序的名值对组成，「名称」部分是一个 JavaScript 字符串，「值」部分可以是任何 JavaScript 的数据类型（包括对象和方法）。这使用户可以根据具体需求，创建出相当复杂的数据结构。 以下两种方法都可以创建一个空对象，这两种方法在语义上是相同的。第二种更方便的方法叫作「对象字面量」法。这也是 JSON 格式的核心语法，一般我们优先选择第二种方法。例如： 12var obj = new Object();var obj = &#123;&#125;; // 好的写法 「对象字面量」也可以用来在对象实例中定义一个对象： 12345678var obj = &#123; name: &quot;Carrot&quot;, &quot;for&quot;: &quot;Max&quot;, details: &#123; color: &quot;orange&quot;, size: 12 &#125;&#125; 对象的属性可以通过链式（chain）表示方法进行访问： 12obj.details.color; // orangeobj[&quot;details&quot;][&quot;size&quot;]; // 12 完成创建后，对象属性可以通过如下两种方式进行赋值和访问： 12345obj.name = &quot;Simon&quot; // 赋值var name = obj.name; // 访问obj[&quot;name&quot;] = &quot;Simon&quot;; // 赋值var name = obj[&quot;name&quot;]; // 访问 对象不同于原始值，对象是可修改的，即他们的值可以改变； 123456let object = &#123; x:1&#125;对象的属性访问：object.xlet arr = [1,2,3]数组的访问：arr[0] 对象不是按值比较的，两个不同的对象即使拥有完全相同的属性和值，它们也不相等。同样，两个不同的数组，即使每个元 素都相同，顺序也相同，它们也不相等。 1234let o = &#123;x:1&#125;,p = &#123;x:1&#125;o===p =&gt;falselet a = [],b = [];a===b =&gt;false 对象被称作引用类型，以区别于js的原始类型。对象值就是引用，对象是按引用比较的。两个对象值当且仅当它们引用同一个 底层对象时，才是相等的。 7）变量声明与赋值变量是通过var或let关键字声明的 1234let i;let sum;var i ;var sum; 也可以使用一条var&#x2F;let语句声明多个变量； 12let i,sum;var i,sum; 声明变量的同时也为其赋值是一个好的编程习惯； 12let msg = &quot;Hello World&quot;;let i = 0;j = 0;k = 0; 如果在var&#x2F;let语句中不为变量指定初始值，变量也会被声明，但在赋值之前它的值是undefined。 const是用来声明常量的，常量在声明是必须初始化且值不能改变，尝试给常量重新赋值会抛出TypeError 12const H0 = 74;const C = 299792.458 变量的作用域是程序源代码中的一个区域，在这个区域内变量有定义。通过let和const声明的变量和常量具有块作用域。这意味着它们只在let和const语句所在的代码块中有定义。 1234console.log(i);//抛出错误if(true)&#123; let i = 0;&#125; 在同一个作用域中使用多个let或const声明同一个名字是语法错误。在嵌套作用域中声明同名变量是合法的（最好不要这么做） 1234567const x = 1;if(x === 1)&#123; let x = 2; console.log(2)//打印2&#125;console.log(x);//打印1，回到全局作用域let x = 3;//报错 使用var和let声明的区别： 使用var声明的变量不具有块作用域，这种变量的作用域仅限于包含函数的函数体，无论它们在函数中嵌套的层次有多深。 如果在函数体外使用var声明，会声明一个全局变量。通过var声明的全局变量可以通过globalThis引用，因此，如果在函数外部写了var x &#x3D;2,则相当于globalThis.x &#x3D; 2; 使用var多次声明同名变量是合法的。 var声明变量的特性是作用域提升。在使用var声明变量时，该声明会被提高到包含函数的顶部。但变量的初始化仍然在代码所在位置完成，只有变量的定义转移到了函数顶部。","categories":[{"name":"javascript","slug":"javascript","permalink":"http://example.com/categories/javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://example.com/tags/javascript/"}]},{"title":"javascript词法结构","slug":"javascript词法结构","date":"2017-04-22T13:22:48.000Z","updated":"2022-05-31T02:40:15.175Z","comments":true,"path":"2017/04/22/javascript词法结构/","link":"","permalink":"http://example.com/2017/04/22/javascript%E8%AF%8D%E6%B3%95%E7%BB%93%E6%9E%84/","excerpt":"","text":"JavaScript简介​ js是一种专门为网页交互设计的客户端（浏览器端）的脚本语言； ​ js与html和css有相似之处，都在浏览器端解析； ​ js和java,c#,php等一样，是一门真正的编程语言 ​ javaScript简称js JavaScript组成部分 ​ ECMAScript:js的基础，主要规定了一些js的语法规范 ​ BOM：浏览器对象模型：提供了访问浏览器的一些接口； ​ DOM：文档对象模型：提供访问页面的接口； 词法结构区分大小写JavaScript 是区分大小写的。也就是说，关键字、变量、函数名和所有的标识符（identifier）都必须采取一致的大小写形式。 比如，关键字 while 必须写成 while，而不能写成 While 或者 WHILE。同样，online、Online、OnLine、ONLINE 是4个不同的 变量名。 但需要注意的是，HTML 并不区分大小写。由于它和客户端 JavaScript 联系紧密，因此这点区别很容易混淆。许多客户端 JavaScript 对象和属性与他们所表示的 HTML 标签和属性名相同。在 HTML 中，这些标签和属性名可以使用大写也可以是小 写，而在 JavaScript 中则必须是小写。例如，在 HTML 中设置事件处理程序时，onclick 属性可以写成 onClick，但在 JavaScript 代码中，必须使用小写的 onclick。 1234var userName = &#x27;张三&#x27;;var username = &#x27;李四&#x27;;console.log(userName);console.log(username) 注释JavaScript 使用 C 风格的注释，包括单行注释和块级注释。单行注释以两个斜杠 // 开头，块级注释以一个斜杠和一个星号 /* 开头，以一个星号和一个斜杠 */ 结尾。下面都是合法的 JavaScript 注释： 12345// 这是单行注释/*** * 这是多行注释 * 这是多行注释***/ 虽然上面注释中的第二和第三行都以一个星号开头，但这不是必须的，纯粹是为了提高注释的可读性 字面量所谓字面量（也可称直接量，Literal values），就是程序中直接使用的数据值。字面量只代表自身，不存储在特定位置。 JavaScript 中的字面量有：字符串、数字、布尔值、对象、数组、函数、正则表达式，以及特殊的 null 值。 12345678910&quot;hello world&quot; // 字符串123 // 数字1.2 // 小数true // 布尔值false // 布尔值/javascript/gi // 正则表达式null // 空&#123; name: &#x27;stone&#x27;, age: 20&#125; // 对象[ 1, 2, 3, 4, 5, 6, 7, 8 ] // 数组function()&#123; console.log(&#x27;good&#x27;); &#125; // 函数 标识符标识符用于在js代码中命名常量，变量，属性，函数和类，以及某些循环提供标记。 标识符命名规则 由数字、字母、下划线或$（美元符）组成； 不能以数字开头；并且区分大小写； 不能用关键字，保留字命名； 1234567//正确的命名方式my_name;_username;$str//错误的命名方式.myname1user 关键字和保留字ECMAScript 3 描述了一组具有特定用途的关键字，这些关键字可用于表示控制语句的开始或结束，或者用于执行特定操作 等。按照规则，关键字是语言保留的，不能用作标识符。以下是 ECMAScript 3 的全部关键字： 123456break delete function return typeofcase do if switch varcatch else in this voidcontinue false instanceof throw whiledebugger finally new true withdefault for null try ECMAScript 3 还将 Java 的所有关键字都作为自己的保留字，保留字也是不能当初标识符。尽管保留字还没有任何特定的用途，但他们有可能在将来被用作关键字： 123456abstract double goto native staticboolean enum implements package superbyte export import private synchronizedchar extends int protected throwsclass final interface public transientconst float long short volatile ECMAScript 5 把非严格模式下的保留字缩减为： 12class enum extends superconst export import ECMAScript 5 在严格模式下的保留字为： 123implements package publicinterface private staticlet protected yield 注意，let 和 yield 是 ECMAScript 5 新增的保留字，其他保留字都是 ECMAScript 3 定义的。为了保证兼容性，任何时候都不建议使用 ECMAScript 5 新增的保留字 let 和 yield 。 ECMAScript 还预定义了很多全局变量和函数，也应当避免把它们用作标识符： 12345678arguments Error Math RegExpArray eval NaN StringBoolean EvalError Number SyntaxErrorDate Function Object TypeErrordecodeURI Infinity parseFloat undefineddecodeURIComponent isFinite parseInt URIErrorencodeURI isNaN RangeErrorencodeURIComponent JSON ReferenceError JavaScript 的具体实现可能定义独有的全局变量和函数，每一种特定的 JavaScript 运行环境都有自己的一个全局属性列表，这一点是需要牢记的。 可选的分号js使用分号(;)分割语句，这对于保持代码的清晰很重要：如果没有分隔符，一条语句的结尾可能是另一条语句的开头。 js中如果两条语句分别写在两行，通常可以省略它们之间的分号。 123例如：var a = 4;var b = 3; 像这种方式可以省略分号。 如果是下面这种情况，必须加分号 1var a = 4;b = 3; 严格模式在 ECMAScript 5 引入了严格模式（strict mode）的概念。严格模式是为 JavaScript 定义了一种不同的解析与执行模式。在严格模式下，ECMAScript 3 中的一些不确定的行为将得到处理，而且对某些不安全的操作也会抛出错误。要在整个脚本中启用严格模式，可以在顶部添加如下代码： 1&quot;use strict&quot;; 这行代码看起来像是字符串，而且也没有赋值给任何变量，但其实它是一个编译指示（pragma），用于告诉支持的 JavaScript 引擎切换到严格模式。这是为了不破坏 ECMAScript 3 语法而特意选定的语法。 在函数内部的第一行包含这条编译指示，也可以指定函数在严格模式下执行： 1234function doSomething()&#123; &quot;use strict&quot;; // 函数体&#125;","categories":[{"name":"javascript","slug":"javascript","permalink":"http://example.com/categories/javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://example.com/tags/javascript/"}]}],"categories":[{"name":"python","slug":"python","permalink":"http://example.com/categories/python/"},{"name":"vue","slug":"vue","permalink":"http://example.com/categories/vue/"},{"name":"webpack","slug":"webpack","permalink":"http://example.com/categories/webpack/"},{"name":"http","slug":"http","permalink":"http://example.com/categories/http/"},{"name":"react","slug":"react","permalink":"http://example.com/categories/react/"},{"name":"ES6","slug":"ES6","permalink":"http://example.com/categories/ES6/"},{"name":"javascript","slug":"javascript","permalink":"http://example.com/categories/javascript/"},{"name":"AJAX","slug":"AJAX","permalink":"http://example.com/categories/AJAX/"},{"name":"css","slug":"css","permalink":"http://example.com/categories/css/"},{"name":"BOM","slug":"BOM","permalink":"http://example.com/categories/BOM/"},{"name":"DOM","slug":"DOM","permalink":"http://example.com/categories/DOM/"}],"tags":[{"name":"python","slug":"python","permalink":"http://example.com/tags/python/"},{"name":"vue","slug":"vue","permalink":"http://example.com/tags/vue/"},{"name":"webpack","slug":"webpack","permalink":"http://example.com/tags/webpack/"},{"name":"http","slug":"http","permalink":"http://example.com/tags/http/"},{"name":"react","slug":"react","permalink":"http://example.com/tags/react/"},{"name":"ES6","slug":"ES6","permalink":"http://example.com/tags/ES6/"},{"name":"javascript","slug":"javascript","permalink":"http://example.com/tags/javascript/"},{"name":"AJAX","slug":"AJAX","permalink":"http://example.com/tags/AJAX/"},{"name":"css","slug":"css","permalink":"http://example.com/tags/css/"},{"name":"BOM","slug":"BOM","permalink":"http://example.com/tags/BOM/"},{"name":"DOM","slug":"DOM","permalink":"http://example.com/tags/DOM/"}]}