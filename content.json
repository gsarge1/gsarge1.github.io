{"meta":{"title":"Valar Dohaeris","subtitle":"","description":"世上只有一种真正的英雄主义,那就是认清生活的真相后依然热爱生活","author":"烨钬","url":"http://example.com","root":"/"},"pages":[],"posts":[{"title":"vue响应式原理","slug":"vue响应式原理","date":"2019-05-25T09:28:36.000Z","updated":"2022-05-25T12:17:24.473Z","comments":true,"path":"2019/05/25/vue响应式原理/","link":"","permalink":"http://example.com/2019/05/25/vue%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8E%9F%E7%90%86/","excerpt":"","text":"数据驱动 数据响应式、双向绑定、数据驱动 数据响应式 数据模型仅仅是普通的 JavaScript 对象，而当我们修改数据时，视图会进行更新，避免了繁琐的 DOM 操作提高开发效率 双向绑定 数据改变，视图改变;视图改变，数据也随之改变 我们可以使用 v-model 在表单元素上创建双向数据绑定 数据驱动是Vue最独特的特性之一，MVVM表示的是Model-View-ViewModel 开发过程中仅需要关注数据本身，不需要关心数据是如何渲染到视图 Model：模型层，负责处理业务逻辑以及和服务器端进行交互 View：视图层：负责将数据模型转化为UI展示出来，可以简单的理解为HTML页面 ViewModel：视图模型层，用来连接Model和View，是Model和View之间的通信桥梁 数据响应式的核心原理Vue 2.x 核心是通过 ES5 的保护对象的 Object.defindeProperty 中的访问器属性中的 get 和 set 方法，data 中声明的属性都被添加了访问器属性，当读取 data 中的数据时自动调用 get 方法，当修改 data 中的数据时，自动调用 set 方法，检测到数据的变化，会通知观察者 Wacher，观察者 Wacher自动触发重新render 当前组件（子组件不会重新渲染）,生成新的虚拟 DOM 树，Vue 框架会遍历并对比新虚拟 DOM 树和旧虚拟 DOM 树中每个节点的差别，并记录下来，最后，加载操作，将所有记录的不同点，局部修改到真实 DOM树上 总结：Vue 采用数据劫持结合发布—订阅模式的方法，通过 Object.defineProperty() 来劫持各个属性的 setter，getter，在数据变动时发布消息给订阅者，触发相应的监听回调 Object.defineProperty()，那么它的用法是什么，以及优缺点是什么呢？ 可以检测对象中数据发生的修改 对于复杂的对象，层级很深的话，是不友好的，需要经行深度监听，这样子就需要递归到底，这也是它的缺点。 对于一个对象中，如果你新增加属性，删除属性，Object.defineProperty()是不能观测到的，那么应该如何解决呢？可以通过Vue.set()和Vue.delete()来实现。 1234567891011121314151617181920212223242526272829303132// 模拟 Vue 中的 data 选项 let data = &#123; msg: &#x27;hello&#x27;&#125;// 模拟 Vue 的实例 let vm = &#123;&#125;// 数据劫持:当访问或者设置 vm 中的成员的时候，做一些干预操作Object.defineProperty(vm, &#x27;msg&#x27;, &#123; // 可枚举(可遍历) enumerable: true, // 可配置(可以使用 delete 删除，可以通过 defineProperty 重新定义) configurable: true, // 当获取值的时候执行 get () &#123; console.log(&#x27;get: &#x27;, data.msg) return data.msg &#125;, // 当设置值的时候执行 set (newValue) &#123; console.log(&#x27;set: &#x27;, newValue) if (newValue === data.msg) &#123; return &#125; data.msg = newValue // 数据更改，更新 DOM 的值 document.querySelector(&#x27;#app&#x27;).textContent = data.msg &#125; &#125;)// 测试vm.msg = &#x27;Hello World&#x27; console.log(vm.msg) Vue 3.x Vue3.x改用Proxy替代Object.defineProperty。因为Proxy可以直接监听对象和数组的变化，并且有多达13种拦截方法。并且作为新标准将受到浏览器厂商重点持续的性能优化。 12345678910111213141516171819202122232425262728293031const data = [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;]const proxyData = new Proxy(data, &#123; get(target, key, receiver) &#123; // 只处理本身（非原型的）属性 const ownKeys = Reflect.ownKeys(target) if (ownKeys.includes(key)) &#123; console.log(&#x27;get&#x27;, key) // 监听 &#125; const result = Reflect.get(target, key, receiver) return result // 返回结果 &#125;, set(target, key, val, receiver) &#123; // 重复的数据，不处理 if (val === target[key]) &#123; return true &#125; const result = Reflect.set(target, key, val, receiver) console.log(&#x27;set&#x27;, key, val) // console.log(&#x27;result&#x27;, result) // true return result // 是否设置成功 &#125;, deleteProperty(target, key) &#123; const result = Reflect.deleteProperty(target, key) console.log(&#x27;delete property&#x27;, key) // console.log(&#x27;result&#x27;, result) // true return result // 是否删除成功 &#125;&#125;) Reflect作用： 和proxy能力一一对应 规范化，标准化，函数式 代替Object上的工具函数 12345678910const obj = &#123;a: 100, b: 200&#125;&#x27;a&#x27; in obj //trueReflect.has(obj,&#x27;a&#x27;) //truedelete obj.a //trueReflect.deleteProperty(obj,&#x27;a&#x27;) //trueObject.getOwnPropertyNames(obj) //[&quot;a&quot;,&quot;b&quot;]Reflect.owbKeys(obj) //[&quot;a&quot;,&quot;b&quot;] proxy创建响应式 Proxy只会代理对象的第一层，那么Vue3又是怎样处理这个问题的呢？ 判断当前Reflect.get的返回值是否为Object，如果是则再通过reactive方法做代理， 这样就实现了深度观测。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172// 创建响应式function reactive(target = &#123;&#125;) &#123; if (typeof target !== &#x27;object&#x27; || target == null) &#123; // 不是对象或数组，则返回 return target &#125; // 代理配置 const proxyConf = &#123; get(target, key, receiver) &#123; // 只处理本身（非原型的）属性 const ownKeys = Reflect.ownKeys(target) if (ownKeys.includes(key)) &#123; console.log(&#x27;get&#x27;, key) // 监听 &#125; const result = Reflect.get(target, key, receiver) // 深度监听 // 性能如何提升的？ return reactive(result) &#125;, set(target, key, val, receiver) &#123; // 重复的数据，不处理 if (val === target[key]) &#123; return true &#125; const ownKeys = Reflect.ownKeys(target) if (ownKeys.includes(key)) &#123; console.log(&#x27;已有的 key&#x27;, key) &#125; else &#123; console.log(&#x27;新增的 key&#x27;, key) &#125; const result = Reflect.set(target, key, val, receiver) console.log(&#x27;set&#x27;, key, val) // console.log(&#x27;result&#x27;, result) // true return result // 是否设置成功 &#125;, deleteProperty(target, key) &#123; const result = Reflect.deleteProperty(target, key) console.log(&#x27;delete property&#x27;, key) // console.log(&#x27;result&#x27;, result) // true return result // 是否删除成功 &#125; &#125; // 生成代理对象 const observed = new Proxy(target, proxyConf) return observed&#125;// 测试数据const data = &#123; name: &#x27;zhangsan&#x27;, age: 20, info: &#123; city: &#x27;beijing&#x27;, a: &#123; b: &#123; c: &#123; d: &#123; e: 100 &#125; &#125; &#125; &#125; &#125;&#125;const proxyData = reactive(data) Proxy 相比于 defineProperty 的优势 数组变化也能监听到 不需要深度遍历监听","categories":[{"name":"vue","slug":"vue","permalink":"http://example.com/categories/vue/"}],"tags":[{"name":"vue","slug":"vue","permalink":"http://example.com/tags/vue/"}]},{"title":"javascript词法结构","slug":"javascript词法结构","date":"2017-04-22T13:22:48.000Z","updated":"2022-05-25T11:26:48.009Z","comments":true,"path":"2017/04/22/javascript词法结构/","link":"","permalink":"http://example.com/2017/04/22/javascript%E8%AF%8D%E6%B3%95%E7%BB%93%E6%9E%84/","excerpt":"","text":"词法结构1）区分大小写JavaScript 是区分大小写的。也就是说，关键字、变量、函数名和所有的标识符（identifier）都必须采取一致的大小写形式。 比如，关键字 while 必须写成 while，而不能写成 While 或者 WHILE。同样，online、Online、OnLine、ONLINE 是4个不同的 变量名。 但需要注意的是，HTML 并不区分大小写。由于它和客户端 JavaScript 联系紧密，因此这点区别很容易混淆。许多客户端 JavaScript 对象和属性与他们所表示的 HTML 标签和属性名相同。在 HTML 中，这些标签和属性名可以使用大写也可以是小 写，而在 JavaScript 中则必须是小写。例如，在 HTML 中设置事件处理程序时，onclick 属性可以写成 onClick，但在 JavaScript 代码中，必须使用小写的 onclick。 1234var userName = &#x27;张三&#x27;;var username = &#x27;李四&#x27;;console.log(userName);console.log(username) 2）注释JavaScript 使用 C 风格的注释，包括单行注释和块级注释。单行注释以两个斜杠 // 开头，块级注释以一个斜杠和一个星号 /* 开头，以一个星号和一个斜杠 */ 结尾。下面都是合法的 JavaScript 注释： 12345// 这是单行注释/*** * 这是多行注释 * 这是多行注释***/ 虽然上面注释中的第二和第三行都以一个星号开头，但这不是必须的，纯粹是为了提高注释的可读性 3）字面量所谓字面量（也可称直接量，Literal values），就是程序中直接使用的数据值。字面量只代表自身，不存储在特定位置。 JavaScript 中的字面量有：字符串、数字、布尔值、对象、数组、函数、正则表达式，以及特殊的 null 值。 12345678910&quot;hello world&quot; // 字符串123 // 数字1.2 // 小数true // 布尔值false // 布尔值/javascript/gi // 正则表达式null // 空&#123; name: &#x27;stone&#x27;, age: 20&#125; // 对象[ 1, 2, 3, 4, 5, 6, 7, 8 ] // 数组function()&#123; console.log(&#x27;good&#x27;); &#125; // 函数 4）标识符标识符用于在js代码中命名常量，变量，属性，函数和类，以及某些循环提供标记。 标识符命名规则 由数字、字母、下划线或$（美元符）组成； 不能以数字开头；并且区分大小写； 不能用关键字，保留字命名； 1234567//正确的命名方式my_name;_username;$str//错误的命名方式.myname1user 5）关键字和保留字ECMAScript 3 描述了一组具有特定用途的关键字，这些关键字可用于表示控制语句的开始或结束，或者用于执行特定操作 等。按照规则，关键字是语言保留的，不能用作标识符。以下是 ECMAScript 3 的全部关键字： 123456break delete function return typeofcase do if switch varcatch else in this voidcontinue false instanceof throw whiledebugger finally new true withdefault for null try ECMAScript 3 还将 Java 的所有关键字都作为自己的保留字，保留字也是不能当初标识符。尽管保留字还没有任何特定的用途，但他们有可能在将来被用作关键字： 123456abstract double goto native staticboolean enum implements package superbyte export import private synchronizedchar extends int protected throwsclass final interface public transientconst float long short volatile ECMAScript 5 把非严格模式下的保留字缩减为： 12class enum extends superconst export import ECMAScript 5 在严格模式下的保留字为： 123implements package publicinterface private staticlet protected yield 注意，let 和 yield 是 ECMAScript 5 新增的保留字，其他保留字都是 ECMAScript 3 定义的。为了保证兼容性，任何时候都不建议使用 ECMAScript 5 新增的保留字 let 和 yield 。 ECMAScript 还预定义了很多全局变量和函数，也应当避免把它们用作标识符： 12345678arguments Error Math RegExpArray eval NaN StringBoolean EvalError Number SyntaxErrorDate Function Object TypeErrordecodeURI Infinity parseFloat undefineddecodeURIComponent isFinite parseInt URIErrorencodeURI isNaN RangeErrorencodeURIComponent JSON ReferenceError JavaScript 的具体实现可能定义独有的全局变量和函数，每一种特定的 JavaScript 运行环境都有自己的一个全局属性列表，这一点是需要牢记的。 6）可选的分号js使用分号(;)分割语句，这对于保持代码的清晰很重要：如果没有分隔符，一条语句的结尾可能是另一条语句的开头。 js中如果两条语句分别写在两行，通常可以省略它们之间的分号。 123例如：var a = 4;var b = 3; 像这种方式可以省略分号。 如果是下面这种情况，必须加分号 1var a = 4;b = 3; 7）严格模式在 ECMAScript 5 引入了严格模式（strict mode）的概念。严格模式是为 JavaScript 定义了一种不同的解析与执行模式。在严格模式下，ECMAScript 3 中的一些不确定的行为将得到处理，而且对某些不安全的操作也会抛出错误。要在整个脚本中启用严格模式，可以在顶部添加如下代码： 1&quot;use strict&quot;; 这行代码看起来像是字符串，而且也没有赋值给任何变量，但其实它是一个编译指示（pragma），用于告诉支持的 JavaScript 引擎切换到严格模式。这是为了不破坏 ECMAScript 3 语法而特意选定的语法。 在函数内部的第一行包含这条编译指示，也可以指定函数在严格模式下执行： 1234function doSomething()&#123; &quot;use strict&quot;; // 函数体&#125;","categories":[],"tags":[]}],"categories":[{"name":"vue","slug":"vue","permalink":"http://example.com/categories/vue/"}],"tags":[{"name":"vue","slug":"vue","permalink":"http://example.com/tags/vue/"}]}