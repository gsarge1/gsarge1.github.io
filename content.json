{"meta":{"title":"Valar Dohaeris","subtitle":"","description":"世上只有一种真正的英雄主义,那就是认清生活的真相后依然热爱生活","author":"烨钬","url":"http://example.com","root":"/"},"pages":[{"title":"分类","date":"2022-05-26T09:18:55.000Z","updated":"2022-05-26T09:20:04.365Z","comments":true,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""},{"title":"link","date":"2022-05-26T09:20:37.000Z","updated":"2022-05-26T09:20:52.753Z","comments":true,"path":"link/index.html","permalink":"http://example.com/link/index.html","excerpt":"","text":""},{"title":"标签页","date":"2022-05-26T09:17:40.000Z","updated":"2022-05-26T11:07:48.162Z","comments":true,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"vue响应式原理","slug":"vue响应式原理","date":"2021-05-25T09:28:36.000Z","updated":"2022-05-28T03:19:48.453Z","comments":true,"path":"2021/05/25/vue响应式原理/","link":"","permalink":"http://example.com/2021/05/25/vue%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8E%9F%E7%90%86/","excerpt":"","text":"数据驱动 数据响应式、双向绑定、数据驱动 数据响应式 数据模型仅仅是普通的 JavaScript 对象，而当我们修改数据时，视图会进行更新，避免了繁琐的 DOM 操作提高开发效率 双向绑定 数据改变，视图改变;视图改变，数据也随之改变 我们可以使用 v-model 在表单元素上创建双向数据绑定 数据驱动是Vue最独特的特性之一，MVVM表示的是Model-View-ViewModel 开发过程中仅需要关注数据本身，不需要关心数据是如何渲染到视图 Model：模型层，负责处理业务逻辑以及和服务器端进行交互 View：视图层：负责将数据模型转化为UI展示出来，可以简单的理解为HTML页面 ViewModel：视图模型层，用来连接Model和View，是Model和View之间的通信桥梁 数据响应式的核心原理Vue 2.x 核心是通过 ES5 的保护对象的 Object.defindeProperty 中的访问器属性中的 get 和 set 方法，data 中声明的属性都被添加了访问器属性，当读取 data 中的数据时自动调用 get 方法，当修改 data 中的数据时，自动调用 set 方法，检测到数据的变化，会通知观察者 Wacher，观察者 Wacher自动触发重新render 当前组件（子组件不会重新渲染）,生成新的虚拟 DOM 树，Vue 框架会遍历并对比新虚拟 DOM 树和旧虚拟 DOM 树中每个节点的差别，并记录下来，最后，加载操作，将所有记录的不同点，局部修改到真实 DOM树上 总结：Vue 采用数据劫持结合发布—订阅模式的方法，通过 Object.defineProperty() 来劫持各个属性的 setter，getter，在数据变动时发布消息给订阅者，触发相应的监听回调 Object.defineProperty()，那么它的用法是什么，以及优缺点是什么呢？ 可以检测对象中数据发生的修改 对于复杂的对象，层级很深的话，是不友好的，需要经行深度监听，这样子就需要递归到底，这也是它的缺点。 对于一个对象中，如果你新增加属性，删除属性，Object.defineProperty()是不能观测到的，那么应该如何解决呢？可以通过Vue.set()和Vue.delete()来实现。 1234567891011121314151617181920212223242526272829303132// 模拟 Vue 中的 data 选项 let data = &#123; msg: &#x27;hello&#x27;&#125;// 模拟 Vue 的实例 let vm = &#123;&#125;// 数据劫持:当访问或者设置 vm 中的成员的时候，做一些干预操作Object.defineProperty(vm, &#x27;msg&#x27;, &#123; // 可枚举(可遍历) enumerable: true, // 可配置(可以使用 delete 删除，可以通过 defineProperty 重新定义) configurable: true, // 当获取值的时候执行 get () &#123; console.log(&#x27;get: &#x27;, data.msg) return data.msg &#125;, // 当设置值的时候执行 set (newValue) &#123; console.log(&#x27;set: &#x27;, newValue) if (newValue === data.msg) &#123; return &#125; data.msg = newValue // 数据更改，更新 DOM 的值 document.querySelector(&#x27;#app&#x27;).textContent = data.msg &#125; &#125;)// 测试vm.msg = &#x27;Hello World&#x27; console.log(vm.msg) Vue 3.x Vue3.x改用Proxy替代Object.defineProperty。因为Proxy可以直接监听对象和数组的变化，并且有多达13种拦截方法。并且作为新标准将受到浏览器厂商重点持续的性能优化。 12345678910111213141516171819202122232425262728293031const data = [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;]const proxyData = new Proxy(data, &#123; get(target, key, receiver) &#123; // 只处理本身（非原型的）属性 const ownKeys = Reflect.ownKeys(target) if (ownKeys.includes(key)) &#123; console.log(&#x27;get&#x27;, key) // 监听 &#125; const result = Reflect.get(target, key, receiver) return result // 返回结果 &#125;, set(target, key, val, receiver) &#123; // 重复的数据，不处理 if (val === target[key]) &#123; return true &#125; const result = Reflect.set(target, key, val, receiver) console.log(&#x27;set&#x27;, key, val) // console.log(&#x27;result&#x27;, result) // true return result // 是否设置成功 &#125;, deleteProperty(target, key) &#123; const result = Reflect.deleteProperty(target, key) console.log(&#x27;delete property&#x27;, key) // console.log(&#x27;result&#x27;, result) // true return result // 是否删除成功 &#125;&#125;) Reflect作用： 和proxy能力一一对应 规范化，标准化，函数式 代替Object上的工具函数 12345678910const obj = &#123;a: 100, b: 200&#125;&#x27;a&#x27; in obj //trueReflect.has(obj,&#x27;a&#x27;) //truedelete obj.a //trueReflect.deleteProperty(obj,&#x27;a&#x27;) //trueObject.getOwnPropertyNames(obj) //[&quot;a&quot;,&quot;b&quot;]Reflect.owbKeys(obj) //[&quot;a&quot;,&quot;b&quot;] proxy创建响应式 Proxy只会代理对象的第一层，那么Vue3又是怎样处理这个问题的呢？ 判断当前Reflect.get的返回值是否为Object，如果是则再通过reactive方法做代理， 这样就实现了深度观测。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172// 创建响应式function reactive(target = &#123;&#125;) &#123; if (typeof target !== &#x27;object&#x27; || target == null) &#123; // 不是对象或数组，则返回 return target &#125; // 代理配置 const proxyConf = &#123; get(target, key, receiver) &#123; // 只处理本身（非原型的）属性 const ownKeys = Reflect.ownKeys(target) if (ownKeys.includes(key)) &#123; console.log(&#x27;get&#x27;, key) // 监听 &#125; const result = Reflect.get(target, key, receiver) // 深度监听 // 性能如何提升的？ return reactive(result) &#125;, set(target, key, val, receiver) &#123; // 重复的数据，不处理 if (val === target[key]) &#123; return true &#125; const ownKeys = Reflect.ownKeys(target) if (ownKeys.includes(key)) &#123; console.log(&#x27;已有的 key&#x27;, key) &#125; else &#123; console.log(&#x27;新增的 key&#x27;, key) &#125; const result = Reflect.set(target, key, val, receiver) console.log(&#x27;set&#x27;, key, val) // console.log(&#x27;result&#x27;, result) // true return result // 是否设置成功 &#125;, deleteProperty(target, key) &#123; const result = Reflect.deleteProperty(target, key) console.log(&#x27;delete property&#x27;, key) // console.log(&#x27;result&#x27;, result) // true return result // 是否删除成功 &#125; &#125; // 生成代理对象 const observed = new Proxy(target, proxyConf) return observed&#125;// 测试数据const data = &#123; name: &#x27;zhangsan&#x27;, age: 20, info: &#123; city: &#x27;beijing&#x27;, a: &#123; b: &#123; c: &#123; d: &#123; e: 100 &#125; &#125; &#125; &#125; &#125;&#125;const proxyData = reactive(data) Proxy 相比于 defineProperty 的优势 数组变化也能监听到 不需要深度遍历监听","categories":[{"name":"vue","slug":"vue","permalink":"http://example.com/categories/vue/"}],"tags":[{"name":"vue","slug":"vue","permalink":"http://example.com/tags/vue/"}]},{"title":"防抖与节流","slug":"防抖与节流","date":"2018-02-27T07:58:47.000Z","updated":"2022-05-27T08:24:19.863Z","comments":true,"path":"2018/02/27/防抖与节流/","link":"","permalink":"http://example.com/2018/02/27/%E9%98%B2%E6%8A%96%E4%B8%8E%E8%8A%82%E6%B5%81/","excerpt":"","text":"一、是什么本质上是优化高频率执行代码的一种手段 如：浏览器的 resize、scroll、keypress、mousemove 等事件在触发时，会不断地调用绑定在事件上的回调函数，极大地浪费资源，降低前端性能 为了优化体验，需要对这类事件进行调用次数的限制，对此我们就可以采用 防抖（debounce） 和 节流（throttle） 的方式来减少调用频率 定义 节流: n 秒内只运行一次，若在 n 秒内重复触发，只有一次生效 防抖: n 秒后在执行该事件，若在 n 秒内被重复触发，则重新计时 一个经典的比喻: 想象每天上班大厦底下的电梯。把电梯完成一次运送，类比为一次函数的执行和响应 假设电梯有两种运行策略 debounce 和 throttle，超时设定为15秒，不考虑容量限制 电梯第一个人进来后，15秒后准时运送一次，这是节流 电梯第一个人进来后，等待15秒。如果过程中又有人进来，15秒等待重新计时，直到15秒后开始运送，这是防抖 代码实现节流1234567891011121314151617181920212223242526272829&lt;div id=&quot;div1&quot; draggable=&quot;true&quot;&gt;可拖拽&lt;div&gt;&lt;style&gt;#div1 &#123; border: 1px solid #ccc; width: 200px; height: 100px;&#125;&lt;/style&gt; &lt;script&gt; // 节流 const div1 = document.getElementById(&#x27;div1&#x27;) function throttle(fn, delay = 500) &#123; let timer = null return function () &#123; if (timer) &#123; return &#125; timer = setTimeout(() =&gt; &#123; fn.apply(this, arguments) timer = null &#125;, delay) &#125; &#125; div1.addEventListener(&#x27;drag&#x27;, throttle(function (e) &#123; console.log(e.offsetX, e.offsetY) &#125;)) &lt;/script&gt; 防抖123456789101112131415161718192021222324&lt;input type=&quot;text&quot; id=&quot;input1&quot;&gt; &lt;script&gt; // 防抖 const input1 = document.getElementById(&#x27;input1&#x27;) function debounce(fn, delay = 500) &#123; let timer = null return function () &#123; if (timer) &#123; clearTimeout(timer) &#125; timer = setTimeout(() =&gt; &#123; fn.apply(this, arguments) timer = null &#125;, delay) &#125; &#125; input1.addEventListener(&#x27;keyup&#x27;, debounce(function () &#123; console.log(input1.value) &#125;, 600)) &lt;/script&gt; 二、区别相同点： 都可以通过使用 setTimeout 实现 目的都是，降低回调执行频率，节省计算资源 不同点： 函数防抖，在一段连续操作结束后，处理回调，利用clearTimeout和 setTimeout实现。函数节流，在一段连续操作中，每一段时间只执行一次，频率较高的事件中使用来提高性能 函数防抖关注一定时间连续触发的事件，只在最后执行一次，而函数节流一段时间内只执行一次 三、应用场景防抖在连续的事件，只需触发一次回调的场景有： 搜索框搜索输入。只需用户最后一次输入完，再发送请求 手机号、邮箱验证输入检测 窗口大小resize。只需窗口调整完成后，计算窗口大小。防止重复渲染。 登录时防止用户多次点击登录，造成重复发送请求 节流在间隔一段时间执行一次回调的场景有： 滚动加载，加载更多或滚到底部监听 搜索框，搜索联想功能","categories":[{"name":"javascript","slug":"javascript","permalink":"http://example.com/categories/javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://example.com/tags/javascript/"}]},{"title":"AJAX","slug":"AJAX","date":"2017-11-04T02:35:00.000Z","updated":"2022-05-28T03:10:26.718Z","comments":true,"path":"2017/11/04/AJAX/","link":"","permalink":"http://example.com/2017/11/04/AJAX/","excerpt":"","text":"AJAX定义ajax全称“Asynchronous Javascript And XML”，是由javascript、xml、XMLHttpRequest组合在一起、能实现异步提交的功能，是一种创建交互式网页应用的网页开发技术。 前后台分离的项目架构 ajax包含哪些技术AJAX:(Asynchronous JavaScript and XML)并不是一项新技术,其实是多种技术的综合，包括Javascript、XHTML和CSS、DOM、XML和XMLHttpRequest。 服务器端语言：服务器需要具备向浏览器发送特定信息的能力。Ajax与服务器端语言无关。 XML (eXtensible Markup Language，可扩展标记语言) 是一种描述数据的格式。AJAX程序需要某种格式化的格式来在服务器和客户端之间传递信息，XML 是其中的一种选择。 XHTMLXHTML（eXtended Hypertext Markup Language,使用扩展超媒体标记语言）和 CSS（Cascading Style Sheet,级联样式单）标准化呈现； DOM（Document Object Model,文档对象模型）实现动态显示和交互； 使用XMLHTTP组件XMLHttpRequest对象进行异步数据读取 使用JavaScript绑定和处理所有数据。 同步和异步同步处理：我们通过实践触发ajax，请求服务器，在这个期间等待服务器处理请求，在这个期间客户端不能做任何处理。当 ajax 执行完毕才会继续执行其他代码。 异步处理：就是我们通过事件触发到ajax，请求服务器，在这个期间无论服务器有没有响应，客户端的其他代码一样可以运行。 同步机制流程图 Ajax异步交互原理AJAX采用异步交互过程。AJAX在用户与服务器之间引入一个中间媒介，从而消除了网络交互过程中的处理—等待—处理—等待缺点。 用户的浏览器在执行任务时即装载了AJAX引擎。AJAX引擎用JavaScript语言编写，通常藏在一个隐藏的框架中。它负责编译用户界面及与服务器之间的交互。 AJAX引擎允许用户与应用软件之间的交互过程异步进行，独立于用户与网络服务器间的交流。现在，可以用Javascript调用AJAX引擎来代替产生一个HTTP的用户动作，内存中的数据编辑、页面导航、数据校验这些不需要重新载入整个页面的需求可以交给AJAX来执行。 使用AJAX，可以为开发人员、终端用户带来可见的便捷： XMLHttpRequst对象XMLHttpRequest是XMLHTTP组件的对象，通过这个对象，AJAX可以像桌面应用程序一样只同服务器进行数据层面的交换，而不用每次都刷新界面，也不用每次将数据处理的工作都交给服务器来做；这样既减轻了服务器负担又加快了响应速度、缩短了用户等待的时间。 XMLHttpRequest最早是在IE5中以ActiveX组件的形式实现的。非W3C标准。 创建XMLHttpRequest对象（由于非标准所以实现方法不统一） Internet Explorer把XMLHttpRequest实现为一个ActiveX对象 其他浏览器（Firefox、Safari、Opera…）把它实现为一个本地的JavaScript对象。 XMLHttpRequest在不同浏览器上的实现是兼容的，所以可以用同样的方式访问XMLHttpRequest实例的属性和方法，而不论这个实例创建的方法是什么。 12345678910111213141516//兼容性写法function createXmlHttpRequest()&#123; var xmlHttp; try&#123; //Firefox, Opera 8.0+, Safari xmlHttp=new XMLHttpRequest(); &#125;catch (e)&#123; try&#123; //Internet Explorer xmlHttp=new ActiveXObject(&quot;Msxml2.XMLHTTP&quot;); &#125;catch (e)&#123; try&#123; xmlHttp=new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;); &#125;catch (e)&#123;&#125; &#125; &#125; return xmlHttp; &#125; XMLHttpRequest方法 XMLHttpRequst对象属性 发送请求利用XMLHttpRequest 实例与服务器进行异步通信包含以下3个关键部分： onreadystatechange 事件处理函数 open 方法 send 方法 open(method, url, asynch) XMLHttpRequest 对象的 open 方法允许程序员用一个Ajax调用向服务器发送请求。 method：请求类型，类似 “GET”或”POST”的字符串。若只想从服务器检索一个文件，而不需要发送任何数据，使用GET(可以在GET请求里通过附加在URL上的查询字符串来发送数据，不过数据大小限制为2000个字符)。若需要向服务器发送数据，用POST。 在某些情况下，有些浏览器会把多个XMLHttpRequest请求的结果缓存在同一个URL。如果对每个请求的响应不同，这就会来不好的结果。把当前时间戳追加到URL的最后，就能确保URL的惟一性，从而避免浏览器缓存结果。 onreadystatechange: 该事件处理函数由服务器触发，而不是用户 在 Ajax 执行过程中，服务器会通知客户端当前的通信状态。这依靠更新 XMLHttpRequest 对象的 readyState 来实现。改变 readyState 属性是服务器对客户端连接操作的一种方式。 每次 readyState 属性的改变都会触发 readystatechange事件 参数设置 url：路径字符串，指向你所请求的服务器上的那个文件。可以是绝对路径或相对路径。 async：表示请求是否要异步传输，默认值为true(异步)。指定true，在读取后面的脚本之前，不需要等待服务器的相应。指定false，当脚本处理过程经过这点时，会停下来，一直等到Ajax请求执行完毕再继续执行。 send方法send(data)： open 方法定义了 Ajax 请求的一些细节。send 方法可为已经待命的请求发送指令 data：将要传递给服务器的字符串。 若选用的是 GET 请求，则不会发送任何数据， 给 send 方法传递 null 即可：request.send(null); 当向send()方法提供参数时，要确保open()中指定的方法是POST，如果没有数据作为请求体的一部分发送，则使用null. 完整的 Ajax 的 GET 请求示例： 123456789101112131415const xhr = new XMLHttpRequest()xhr.open(&#x27;GET&#x27;, &#x27;/data/test.json&#x27;, true)xhr.onreadystatechange = function () &#123; if (xhr.readyState === 4) &#123; if (xhr.status === 200) &#123; // console.log( // JSON.parse(xhr.responseText) // ) alert(xhr.responseText) &#125; else if (xhr.status === 404) &#123; console.log(&#x27;404 not found&#x27;) &#125; &#125;&#125;xhr.send(null) 注意：使用get请求时send方法参数时null,如果传值的话，服务器也接收不到 发送Post请求setRequestHeader(header,value)当浏览器向服务器请求页面时，它会伴随这个请求发送一组首部信息。这些首部信息是一系列描述请求的元数据(metadata)。 首部信息用来声明一个请求是 GET 还是 POST。 Ajax 请求中，发送首部信息的工作可以由 setRequestHeader完成参数header： 首部的名字; 参数value：首部的值。 如果用 POST 请求向服务器发送数据，需要将 “Content-type” 的首部设置为 “application&#x2F;x-www-form-urlencoded”.它会告知服务器正在发送数据，并且数据已经符合URL编码了。 该方法必须在open()之后才能调用完整的 Ajax 的 POST 请求示例： 12345678910111213141516171819function ajax(url) &#123; const p = new Promise((resolve, reject) =&gt; &#123; const xhr = new XMLHttpRequest() xhr.open(&#x27;POST&#x27;, url, true) xhr.onreadystatechange = function () &#123; if (xhr.readyState === 4) &#123; if (xhr.status === 200) &#123; resolve( JSON.parse(xhr.responseText) ) &#125; else if (xhr.status === 404 || xhr.status === 500) &#123; reject(new Error(&#x27;404 not found&#x27;)) &#125; &#125; &#125; xhr.send(null) &#125;) return p&#125; 接收数据的方法和属性用XMLHttpRequest的方法可向服务器发送请求。在Ajax处理过程中，XMLHttpRequest的如下属性可被服务器更改： readyState status responseText responseXML readyState（请求状态）readyState 属性表示Ajax请求的当前状态。它的值用数字代表。 0 代表未初始化。 还没有调用 open 方法 1 代表正在加载。 open 方法已被调用，但 send 方法还没有被调用 2 代表已加载完毕。send 已被调用。请求已经开始 3 代表交互中。服务器正在发送响应 4 代表完成。响应发送完毕 每次 readyState 值的改变，都会触发 readystatechange 事件。如果把 onreadystatechange 事件处理函数赋给一个函数，那么每次 readyState 值的改变都会引发该函数的执行。 readyState 值的变化会因浏览器的不同而有所差异。但是，当请求结束的时候，每个浏览器都会把 readyState 的值统一设为 4。 status（服务器状态码）服务器发送的每一个响应也都带有首部信息。三位数的状态码是服务器发送的响应中最重要的首部信息，并且属于超文本传输协议中的一部分。 在 XMLHttpRequest 对象中，服务器发送的状态码都保存在 status 属性里。通过把这个值和 200 或 304 比较，可以确保服务器是否已发送了一个成功的响应。 常用状态码及其含义： 404 没找到页面(not found) 403 禁止访问(forbidden) 500 内部服务器出错(internal service error) 200 一切正常(ok) 304 没有被修改(not modified)(服务器返回304状态，表示源文件没有被修改 ) responseTextXMLHttpRequest 的 responseText 属性包含了从服务器发送的数据。它是一个HTML,XML或普通文本，这取决于服务器发送的内容。 当 readyState 属性值变成 4 时, responseText 属性才可用，表明 Ajax 请求已经结束。 1234567891011//指定响应处理函数XMLHttpReq.onreadystatechange=function()&#123; //判断对象状态 4代表完成 if(XMLHttpReq.readyState==4)&#123; //信息已经成功返回，开始处理信息 if(XMLHttpReq.status==200 || XMLHttpReq.status==304)&#123; // 开始处理信息 alert(XMLHttpReq.responseText); &#125; &#125;&#125; 两种数据格式XMLHttpRequest对成功返回的信息有两种处理方式： responseText：将传回的信息当字符串使用； responseXML：将传回的信息当XML文档使用，可以用DOM处理。 如果服务器返回的是 XML， 那么数据将储存在 responseXML 属性中只用服务器发送了带有正确首部信息的数据时， responseXML 属性才是可用的。 MIME 类型必须为 text&#x2F;xml 12345678//处理返回信息的函数function processResponse()&#123; if(XMLHttpReq.readyState==4)&#123; //判断对象状态 4代表完成 if(XMLHttpReq.status==200)&#123; //信息已经成功返回，开始处理信息 document.getElementById(&quot;chatArea&quot;).value=XMLHttpReq.responseText; &#125; &#125;&#125; get和post区别","categories":[{"name":"AJAX","slug":"AJAX","permalink":"http://example.com/categories/AJAX/"}],"tags":[{"name":"AJAX","slug":"AJAX","permalink":"http://example.com/tags/AJAX/"}]},{"title":"BOM","slug":"BOM","date":"2017-08-02T00:06:25.000Z","updated":"2022-05-28T03:18:50.715Z","comments":true,"path":"2017/08/02/BOM/","link":"","permalink":"http://example.com/2017/08/02/BOM/","excerpt":"","text":"BOM定义BOM（Browser Object Model）即浏览器对象模型。 BOM提供了独立于内容而与浏览器窗口进行交互的对象； 由于BOM主要用于管理窗口与窗口之间的通讯，因此其核心对象是window； BOM由一系列相关的对象构成，并且每个对象都提供了很多方法与属性； BOM组成 window：代表整个浏览器窗口） Navigator：代表浏览器当前的信息； Location：代表浏览器当前的地址信息 History：代表浏览器的历史信息 Screen：代表用户的屏幕信息 Window对象BOM的核心是window对象,表示浏览器的实例。window对象在浏览器中有两重身份，一个是ECMAScript中的Global对象，另一个就是浏览器窗口的JavaScript接口。这意味着网页中定义的所有对象、变量和函数都以window作为其Global对象，都可以访问其上定义的parseInt()等全局方法。 Global作用域因为window对象被复用为ECMAScript的Global对象，所以通过var声明的所有全局变量和函数都会变成window对象的属性和方法。 12345var age = 29;var sayAge = () =&gt;alert(this.age);alert(window.age);sayAge();window.sayAge(); 这里，变量age和函数sayAge()被定义在全局作用域中，它们自动成为了window对象的成员。因此，变量age可以通过window.age来访问，而函数sayAge()也可以通过window.sayAge()来访问。因为sayAge()存在于全局作用域，this.age映射到window.age，所以就可以显示正确的结果了。 如果在这里使用let或const替代var，则不会把变量添加给全局对象: 12345let age = 29;const sayAge = () =&gt; alert(this.age);alert(window.age); // undefinedsayAge(); // undefinedwindow.sayAge(); // TypeError: window.sayAge is not a function 导航与打开新窗口window.open()方法可以用于导航到指定URL，也可以用于打开新浏览器窗口。这个方法接收4个参数：要加载的URL、目标窗口、特性字符串和表示新窗口在浏览器历史记录中是否替代当前加载页面的布尔值。通常，调用这个方法时只传前3个参数，最后一个参数只有在不打开新窗口时才会使用。 如果window.open()的第二个参数是一个已经存在的窗口或窗格（frame）的名字，则会在对应的窗口或窗格中打开URL。下面是一个例子： 1window.open(&quot;http://www.wrox.com/&quot;, &quot;topFrame&quot;); 执行这行代码的结果就如同用户点击了一个href属性为”http://www.wrox.com&quot;，target属性为&quot;topFrame&quot;的链接。如果有一个窗口名叫&quot;topFrame&quot;，则这个窗口就会打开这个URL；否则就会打开一个新窗口并将其命名为&quot;topFrame&quot;。第二个参数也可以是一个特殊的窗口名，比如_self、_parent、_top或_blank。 弹出窗口 如果window.open()的第二个参数不是已有窗口，则会打开一个新窗口或标签页。第三个参数，即特性字符串，用于指定新窗口的配置。如果没有传第三个参数，则新窗口（或标签页）会带有所有默认的浏览器特性（工具栏、地址栏、状态栏等都是默认配置）。如果打开的不是新窗口，则忽略第三个参数。 特性字符串是一个逗号分隔的设置字符串，用于指定新窗口包含的特性。下表列出了一些选项。 这些设置需要以逗号分隔的名值对形式出现，其中名值对以等号连接。 来看下面的例子： 1window.open(&quot;http://www.wrox.com/&quot;,&quot;wroxWindow&quot;,&quot;height=400,width=400,top=10,left=10,resizable=yes&quot;); 这行代码会打开一个可缩放的新窗口，大小为400像素×400像素，位于离屏幕左边及顶边各10像素的位置。 window.open()方法返回一个对新建窗口的引用。这个对象与普通window对象没有区别，只是为控制新窗口提供了方便。例如，某些浏览器默认不允许缩放或移动主窗口，但可能允许缩放或移动通过window.open()创建的窗口。跟使用任何window对象一样，可以使用这个对象操纵新打开的窗口。 123456let wroxWin = window.open(&quot;http://www.wrox.com/&quot;,&quot;wroxWindow&quot;,&quot;height=400,width=400,top=10,left=10,resizable=yes&quot;);// 缩放wroxWin.resizeTo(500, 500);// 移动wroxWin.moveTo(100, 100);wroxWin.close();//关闭新打开的窗口 定时器setTimeout()的参数 code&#x2F;function：必需。要调用一个代码串，也可以是一个函数，或者函数名。 milliseconds：可选。执行或调用 code&#x2F;function 需要等待的时间，以毫秒计。默认为 0。 param1, …：可选，多个。 传给执行函数的其他参数（IE9 及其更早版本不支持该参数）。 使用函数名称 12345678function myFunction() &#123; myVar = setTimeout(alertFunc, 3000);&#125; function alertFunc() &#123; alert(&quot;Hello!&quot;);&#125; 使用匿名函数 12345var myWindow = window.open(&quot;&quot;, &quot;&quot;, &quot;width=200, height=100&quot;);myWindow.document.write(&quot;&lt;p&gt;新窗口&#x27;&lt;/p&gt;&quot;);setTimeout(function()&#123; myWindow.close() &#125;, 3000); 给函数传参 12345678910function alertFunc(r, g)&#123; alert(r + g); &#125;function myStartFunction() &#123; myVar = setTimeout(alertFunc, 2000, &quot;Runoob&quot;, &quot;Google&quot;);&#125;//使用匿名函数function myStartFunction() &#123; myVar = setTimeout(function()&#123; alertFunc(&quot;Runoob&quot;, &quot;Google&quot;); &#125;, 2000);&#125; setTimeout的特点 setTimeout() 方法用于在指定的毫秒数后调用函数或计算表达式。 方法只会被调用一次1000的单位是毫秒，1000毫秒&#x3D;1秒 setInterval()的特点 setInterval() 方法可按照指定的周期来调用函数或计算表达式。 setInterval() 方法会不停地调用函数1000的单位是毫秒，1000毫秒&#x3D;1秒 12345678910111213141516var myVar;function myFunction() &#123; myVar = setTimeout(function()&#123; alert(&quot;Hello&quot;); &#125;, 3000);&#125;function myStopFunction() &#123; clearTimeout(myVar);&#125;var myVar;function myFunction() &#123; myVar = setInterval(function()&#123; alert(&quot;Hello&quot;); &#125;, 3000);&#125; function myStopFunction() &#123; clearInterval(myVar);&#125; clearTimeout():可取消由 setTimeout() 方法设置的定时操作 clearInterval():可取消由 setInterval() 函数设定的定时执行操作 看到了setTimeout函数。 它会在给定的毫秒数之后，调度另一个函数在稍后调用。 有时需要取消调度的函数。可以存储setTimeout的返回值，并将作为参数调用clearTimeout。 12345678let bombTimer = setTimeout(() =&gt; &#123; console.log(&quot;BOOM!&quot;);&#125;, 500);if (Math.random() &lt; 0.5) &#123; // 50% chance console.log(&quot;Defused.&quot;); clearTimeout(bombTimer);&#125; 函数cancelAnimationFrame作用与clearTimeout相同，使用requestAnimationFrame的返回值调用该函数，可以取消帧（假定函数还没有被调用）。 还有setInterval和clearInterval这种相似的函数，用于设置计时器，每隔一定毫秒数重复执行一次。 12345678let ticks = 0;let clock = setInterval(() =&gt; &#123; console.log(&quot;tick&quot;, ticks++); if (ticks == 10) &#123; clearInterval(clock); console.log(&quot;stop.&quot;); &#125;&#125;, 200); 降频某些类型的事件可能会连续、迅速触发多次（例如mousemove和scroll事件）。处理这类事件时，你必须小心谨慎，防止处理任务耗时过长，否则处理器会占据过多事件，导致用户与文档交互变得非常慢。 若你需要在这类处理器中编写一些重要任务，可以使用setTimeout来确保不会频繁进行这些任务。我们通常称之为“事件降频（Debounce）”。有许多方法可以完成该任务。 在第一个示例中，当用户输入某些字符时，我们想要有所反应，但我们不想在每个按键事件中立即处理该任务。当用户输入过快时，我们希望暂停一下然后进行处理。我们不是立即在事件处理器中执行动作，而是设置一个定时器。我们也会清除上一次的定时器（如果有），因此当两个事件触发间隔过短（比定时器延时短），就会取消上一次事件设置的定时器。 123456789&lt;textarea&gt;Type something here...&lt;/textarea&gt;&lt;script&gt; let textarea = document.querySelector(&quot;textarea&quot;); let timeout; textarea.addEventListener(&quot;input&quot;, () =&gt; &#123; clearTimeout(timeout); timeout = setTimeout(() =&gt; console.log(&quot;Typed!&quot;), 500); &#125;);&lt;/script&gt; 将undefined传递给clearTimeout或在一个已结束的定时器上调用clearTimeout是没有效果的。因此，我们不需要关心何时调用该方法，只需要每个事件中都这样做即可。 如果我们想要保证每次响应之间至少间隔一段时间，但不希望每次事件发生时都重置定时器，而是在一连串事件连续发生时能够定时触发响应，那么我们可以使用一个略有区别的方法来解决问题。例如，我们想要响应&quot;mousemove&quot;事件来显示当前鼠标坐标，但频率只有 250ms。 12345678910111213&lt;script&gt; let scheduled = null; window.addEventListener(&quot;mousemove&quot;, event =&gt; &#123; if (!scheduled) &#123; setTimeout(() =&gt; &#123; document.body.textContent = `Mouse at $&#123;scheduled.pageX&#125;, $&#123;scheduled.pageY&#125;`; scheduled = null; &#125;, 250); &#125; scheduled = event; &#125;);&lt;/script&gt; location对象location是最有用的BOM对象之一，提供了当前窗口中加载文档的信息，以及通常的导航功能。这个对象独特的地方在于，它既是window的属性，也是document的属性。也就是说，window.location和document.location指向同一个对象。location对象不仅保存着当前加载文档的信息，也保存着把URL解析为离散片段后能够通过属性访问的信息。 假设浏览器当前加载的URL是http://foouser:barpassword@www.wrox.com:80/WileyCDA/?q=javascript#contents，location对象的内容如下表所示。 查找字符串location的多数信息都可以通过上面的属性获取。但是URL中的查询字符串并不容易使用。虽然location.search返回了从问号开始直到URL末尾的所有内容，但没有办法逐个访问每个查询参数。下面的函数解析了查询字符串，并返回一个以每个查询参数为属性的对象： 123456789101112131415let getQueryStringArgs = function() &#123; // 取得没有开头问号的查询字符串 let qs = (location.search.length &gt; 0 ? location.search.substring(1) : &quot;&quot;), // 保存数据的对象 args = &#123;&#125;; // 把每个参数添加到 args 对象 for (let item of qs.split(&quot;&amp;&quot;).map(kv =&gt; kv.split(&quot;=&quot;))) &#123; let name = decodeURIComponent(item[0]), value = decodeURIComponent(item[1]); if (name.length) &#123; args[name] = value; &#125; &#125; return args;&#125; 这个函数首先删除了查询字符串开头的问号，当然前提是location.search必须有内容。解析后的参数将被保存到args对象，这个对象以字面量形式创建。接着，先把查询字符串按照&amp;分割成数组，每个元素的形式为name&#x3D;value。for循环迭代这个数组，将每一个元素按照&#x3D;分割成数组，这个数组第一项是参数名，第二项是参数值。参数名和参数值在使用decodeURIComponent()解码后（这是因为查询字符串通常是被编码后的格式）分别保存在name和value变量中。最后，name作为属性而value作为该属性的值被添加到args对象。这个函数可以像下面这样使用： 1234// 假设查询字符串为?q=javascript&amp;num=10let args = getQueryStringArgs();alert(args[&quot;q&quot;]); // &quot;javasalert(args[&quot;num&quot;]); // &quot;10&quot; 操作地址可以通过修改location对象修改浏览器的地址。首先，最常见的是使用assign()方法并传入一个URL，如下所示： 1location.assign(&quot;http://www.wrox.com&quot;) 这行代码会立即启动导航到新URL的操作，同时在浏览器历史记录中增加一条记录。如果给location.href或window.location设置一个URL，也会以同一个URL值调用assign()方法。比如，下面两行代码都会执行与显式调用assign()一样的操作： 12window.location=&quot;http://www.wrox.com&quot;;location.href=&quot;http://www.wrox.com&quot;; 在这3种修改浏览器地址的方法中，设置location.href是最常见的。 修改location对象的属性也会修改当前加载的页面。其中，hash、search、hostname、pathname和port属性被设置为新值之后都会修改当前URL，如下面的例子所示： 1234567891011//假设当前URL为http://www.wrox.com/WileyCDA///把URL修改为http://www.wrox.com/WileyCDA/#section1location.hash=&quot;#section1&quot;;//把URL修改为http://www.wrox.com/WileyCDA/?q=javascriptlocation.search=&quot;?q=javascript&quot;;//把URL修改为http://www.somewhere.com/WileyCDA/location.hostname=&quot;www.somewhere.com&quot;;//把URL修改为http://www.somewhere.com/mydir/location.pathname=&quot;mydir&quot;;//把URL修改为http://www.somewhere.com:8080/WileyCDA/location.port=8080; 除了hash之外，只要修改location的一个属性，就会导致页面重新加载新URL。 注意修改hash的值会在浏览器历史中增加一条新记录。在早期的IE中，点击“后退”和“前进”按钮不会更新hash属性，只有点击包含散列的URL才会更新hash的值。 在以前面提到的方式修改URL之后，浏览器历史记录中就会增加相应的记录。当用户单击“后退”按钮时，就会导航到前一个页面。如果不希望增加历史记录，可以使用replace()方法。这个方法接收一个URL参数，但重新加载后不会增加历史记录。调用replace()之后，用户不能回到前一页。比如下面的例子： 123456789101112&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;title&gt;You won&#x27;t be able to get back here&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;Enjoy this page for a second, because you won&#x27;t be coming back here.&lt;/p&gt;&lt;script&gt; setTimeout(() =&gt; location.replace(&quot;http://www.wrox.com/&quot;), 1000);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 浏览器加载这个页面1秒之后会重定向到www.wrox.com。此时，“后退”按钮是禁用状态，即不能返回这个示例页面，除非手动输入完整的URL。 最后一个修改地址的方法是reload()，它能重新加载当前显示的页面。调用reload()而不传参数，页面会以最有效的方式重新加载。也就是说，如果页面自上次请求以来没有修改过，浏览器可能会从缓存中加载页面。如果想强制从服务器重新加载，可以像下面这样给reload()传个true： location.reload();&#x2F;&#x2F;重新加载，可能是从缓存加载 location.reload(true);&#x2F;&#x2F;重新加载，从服务器加载 脚本中位于reload()调用之后的代码可能执行也可能不执行，这取决于网络延迟和系统资源等因素。为此，最好把reload()作为最后一行代码。 navigator对象navigator是由NetscapeNavigator2最早引入浏览器的，现在已经成为客户端标识浏览器的标准。只要浏览器启用JavaScript，navigator对象就一定存在。但是与其他BOM对象一样，每个浏览器都支持自己的属性。 navigator属性如下表： appCodeName ：返回浏览器的代码名。 appMinorVersion：返回浏览器的次级版本。 appName：返回浏览器的名称。 appVersion ：返回浏览器的平台和版本信息。 browserLanguage ：返回当前浏览器的语言。 cookieEnabled：返回指明浏览器中是否启用 cookie 的布尔值。 cpuClass ：返回浏览器系统的 CPU 等级。 onLine：返回指明系统是否处于脱机模式的布尔值。 platform：返回运行浏览器的操作系统平台。 systemLanguage：返回 OS 使用的默认语言。 userAgent ：返回由客户机发送服务器的 user-agent 头部的值。 userLanguage ：返回 OS 的自然语言设置。 我们使用的比较多的是他的userAgent，经常需要判断的情况有： （1）PC还是移动端 （2）安卓还是IOS （3）浏览器的类型 示例代码： 123456789101112131415161718var browser=&#123; versions:function()&#123; var u = navigator.userAgent, app = navigator.appVersion; return &#123; //移动终端浏览器版本信息 trident: u.indexOf(&#x27;Trident&#x27;) &gt; -1, //IE内核 presto: u.indexOf(&#x27;Presto&#x27;) &gt; -1, //opera内核 webKit: u.indexOf(&#x27;AppleWebKit&#x27;) &gt; -1, //苹果、谷歌内核 gecko: u.indexOf(&#x27;Gecko&#x27;) &gt; -1 &amp;&amp; u.indexOf(&#x27;KHTML&#x27;) == -1, //火狐内核 mobile: !!u.match(/AppleWebKit.*Mobile.*/), //是否为移动终端 ios: !!u.match(/\\(i[^;]+;( U;)? CPU.+Mac OS X/), //ios终端 android: u.indexOf(&#x27;Android&#x27;) &gt; -1 || u.indexOf(&#x27;Linux&#x27;) &gt; -1, //android终端或uc浏览器 iPhone: u.indexOf(&#x27;iPhone&#x27;) &gt; -1 , //是否为iPhone或者QQHD浏览器 iPad: u.indexOf(&#x27;iPad&#x27;) &gt; -1, //是否iPad webApp: u.indexOf(&#x27;Safari&#x27;) == -1 //是否web应该程序，没有头部与底部 &#125;; &#125;(), language:(navigator.browserLanguage || navigator.language).toLowerCase()&#125; screen对象window的另一个属性screen对象，是为数不多的几个在编程中很少用的JavaScript对象。这个对象中保存的纯粹是客户端能力信息，也就是浏览器窗口外面的客户端显示器的信息，比如像素宽度和像素高度。每个浏览器都会在screen对象上暴露不同的属性。 下表总结了这些属性: availHeight 屏幕像素高度减去系统组件高度（只读） availLeft 没有被系统组件占用的屏幕的最左侧像素（只读） availTop 没有被系统组件占用的屏幕的最顶端像素（只读） availWidth 屏幕像素宽度减去系统组件宽度（只读） colorDepth 表示屏幕颜色的位数；多数系统是 32（只读） height 屏幕像素高度 left 当前屏幕左边的像素距离 pixelDepth 屏幕的位深（只读） top 当前屏幕顶端的像素距离 width 屏幕像素宽度 orientation 返回 Screen Orientation API中屏幕的朝向 history对象history对象表示当前窗口首次使用以来用户的导航历史记录。因为history是window的属性，所以每个window都有自己的history对象。出于安全考虑，这个对象不会暴露用户访问过的 URL，但可以通过它在不知道实际URL的情况下前进和后退。 导航go()方法可以在用户历史记录中沿任何方向导航，可以前进也可以后退。这个方法只接收一个参数，这个参数可以是一个整数，表示前进或后退多少步。负值表示在历史记录中后退，而正值表示在历史记录中前进。 下面来看几个例子： 123456// 后退一页history.go(-1);// 前进一页history.go(1);// 前进两页history.go(2); go()有两个简写方法：back()和forward()。顾名思义，这两个方法模拟了浏览器的后退按钮和前进按钮： 1234//后退一页history.back();//前进一页history.forward(); history对象还有一个length属性，表示历史记录中有多个条目。这个属性反映了历史记录的数量，包括可以前进和后退的页面。对于窗口或标签页中加载的第一个页面，history.length等于1。 通过以下方法测试这个值，可以确定用户浏览器的起点是不是你的页面： 123if (history.length == 1)&#123;// 这是用户窗口中的第一个页面&#125; history对象通常被用于创建“后退”和“前进”按钮，以及确定页面是不是用户历史记录中的第一条记录。","categories":[{"name":"BOM","slug":"BOM","permalink":"http://example.com/categories/BOM/"}],"tags":[{"name":"BOM","slug":"BOM","permalink":"http://example.com/tags/BOM/"}]},{"title":"DOM事件","slug":"DOM事件","date":"2017-07-21T13:37:27.000Z","updated":"2022-05-28T02:30:02.728Z","comments":true,"path":"2017/07/21/DOM事件/","link":"","permalink":"http://example.com/2017/07/21/DOM%E4%BA%8B%E4%BB%B6/","excerpt":"","text":"事件DOM事件的定义定义:DOM事件是由DOM中的事件源触发，可以引发事件响应的操作。 DOM事件流事件发生时会在元素节点与根节点之间按照特定的顺序传播，路径经过的所有节点都会收到该事件，这个传播过程即DOM事件流。 DOM标准规定事件流包括三个阶段： 捕获阶段： 事件自上而下传播，从Document根节点到再到 处理阶段： 目标节点（）处理事件的阶段 冒泡阶段： 事件自下而上传播，依次传播回Document根节点。 案例—–DOM事件流 三个逐层嵌套的圆，最里层的圆被点击，事件逐层传播。 123456789101112131415161718192021&lt;div id=&quot;outer&quot;&gt; &lt;div id=&quot;middle&quot;&gt; &lt;div id=&quot;inner&quot;&gt; Click me! &lt;/div&gt; &lt;/div&gt;&lt;/div&gt;&lt;script&gt; var innerCircle = document.getElementById(&#x27;inner&#x27;); innerCircle.onclick = function()&#123; alert(&quot;最内层的圆&quot;); &#125; var middleCircle = document.getElementById(&#x27;middle&#x27;); middleCircle.onclick = function()&#123; alert(&quot;中间层的圆&quot;); &#125; var outerCircle = document.getElementById(&#x27;outer&#x27;); outerCircle.onclick = function()&#123; alert(&quot;最外层的圆&quot;); &#125;&lt;/script&gt; 备注：触发一个DOM事件，会产生一个事件对象；JavaScript通过事件对象获取事件的信息。 事件对象触发DOM事件时，在事件处理函数中产生一个对应的事件对象 事件对象是在触发DOM事件时，在事件处理函数中产生并代表该事件状态的对象。 事件对象包含所有与事件有关的信息，包括导致事件被触发的元素、事件的类型，以及与特定事件相关的其他信息。 事件对象通常用event表示，可以作为参数传递给事件处理函数。 1）标准属性：type ：返回当前 Event 对象表示的事件的名称； bubbles ：返回布尔值，指示事件是否是起泡事件类型； cancelable ：返回布尔值，指示事件是否可拥可取消的默认动作； currentTarget ：返回其事件监听器触发该事件的元素； eventPhase ：返回事件传播的当前阶段； target ：返回触发此事件的元素（事件的目标节点）； timeStamp ：返回事件生成的日期和时间； 2）鼠标&#x2F;键盘属性altKey ：返回当事件被触发时，”ALT” 是否被按下； button ：返回当事件被触发时，哪个鼠标按钮被点击； clientX ：返回当事件被触发时，鼠标指针的水平坐标； clientY ：返回当事件被触发时，鼠标指针的垂直坐标； ctrlKey ：返回当事件被触发时，”CTRL” 键是否被按下； metaKey ：返回当事件被触发时，”meta” 键是否被按下； relatedTarget ：返回与事件的目标节点相关的节点； screenX ：返回当某个事件被触发时，鼠标指针的水平坐标； screenY ：返回当某个事件被触发时，鼠标指针的垂直坐标； shiftKey ：返回当事件被触发时，”SHIFT” 键是否被按下； 内联模式事件绑定直接写在html上 这里button的click事件的绑定直接写在html中 脚本模型脚本模型是通过DOM选择器选中操作元素，单独封装事件操作在Js中，把事件操作与HTML代码分离的一种事件操作形式。 上一节讲了内联模式,内联模式的缺点：函数违反了标记&#x2F;行为展现&#x2F;Javascript分离的层次分离原则。 案例：灯泡点亮 创建html页面，页面内如图有一图片；编写JS代码，给图片增加鼠标移过事件，触发函数；编写JS函数，实现给页面元素属性赋值。 事件函数鼠标事件 鼠标点击 鼠标点击事件包括 4 个：click（单击）、dblclick（双击）、mousedown（按下）和 mouseup（松开）。其中 click 事件类型比较常用，而 mousedown 和 mouseup 事件类型多用在鼠标拖放、拉伸操作中。当这些事件处理函数的返回值为 false 时，会禁止绑定对象的默认行为。 示例 在下面示例中，当定义超链接指向自身时（多在设计过程中 href 属性值暂时使用 “#”或“?”表示），可以取消超链接被单击时的默认行为，即刷新页面。 123456789101112&lt;a name=&quot;tag&quot; id=&quot;tag&quot; href=&quot;#&quot;&gt;a&lt;/a&gt;&lt;script&gt;var a = document.getElementsByTagName(&quot;a&quot;); //获取页面中所有超链接元素for (var i = 0; i &lt; a.length; i ++) &#123; //遍历所有a元素 if ((new RegExp(window.location.href)).test(a[i].href)) &#123; //如果当前超链接href属性中包含本页面的URL信息 a[i].onclick = function () &#123; //则为超链接注册鼠标单击事件 return false; //将禁止超链接的默认行为 &#125; &#125;&#125;&lt;/script&gt; 鼠标移动 mousemove 事件类型是一个实时响应的事件，当鼠标指针的位置发生变化时（至少移动一个像素），就会触发 mousemove 事件。该事件响应的灵敏度主要参考鼠标指针移动速度的快慢以及浏览器跟踪更新的速度。 示例下面示例演示了如何综合应用各种鼠标事件实现页面元素拖放操作的设计过程。实现拖放操作设计需要解决以下几个问题。定义拖放元素为绝对定位以及设计事件的响应过程，这个比较容易实现。 清楚几个坐标概念：按下鼠标时的指针坐标，移动中当前鼠标指针坐标，松开鼠标时的指针坐标，拖放元素的原始坐标，拖动中的元素坐标。 算法设计：按下鼠标时，获取被拖放元素和鼠标指针的位置，在移动中实时计算鼠标偏移的距离，并利用该偏移距离加上被拖放元素的原坐标位置，获得拖放元素的实时坐标。 如下图所示，其中变量 ox 和 oy 分别记录按下鼠标时被拖放元素的纵横坐标值，它们可以通过事件对象的 offsetLeft 和 offsetTop 属性获取。变量 mx 和 my 分别表示按下鼠标时，鼠标指针的坐标位置。而 event.mx 和 event.my 是事件对象的自定义属性，用它们来存储当鼠标移动时鼠标指针的实时位置。 当获取了上面 3 对坐标值之后，就可以动态计算拖动中元素的实时坐标位置，即 x 轴值为 ox+event.mx-mx，y 轴为 oy+event.my-my。当释放鼠标按钮时，就可以释放事件类型，并记下松开鼠标指针时拖动元素的坐标值，以及鼠标指针的位置，留待下一次拖放操作时调用。 整个拖放操作的示例代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;div id=&quot;box&quot; &gt;&lt;/div&gt;&lt;script&gt; // 初始化拖放对象 var box = document.getElementById(&quot;box&quot;); // 获取页面中被拖放元素的引用指针 box.style.position = &quot;absolute&quot;; // 绝对定位 box.style.width = &quot;160px&quot;; // 定义宽度 box.style.height = &quot;120px&quot;; // 定义高度 box.style.backgroundColor = &quot;red&quot;; // 定义背景色 // 初始化变量，标准化事件对象 var mx, my, ox, oy; // 定义备用变量 function e(event)&#123; // 定义事件对象标准化函数 if( ! event)&#123; // 兼容IE浏览器 event = window.event; event.target = event.srcElement; event.layerX = event.offsetX; event.layerY = event.offsetY; &#125; event.mx = event.pageX || event.clientX + document.body.scrollLeft; // 计算鼠标指针的x轴距离 event.my = event.pageY || event.clientY + document.body.scrollTop; // 计算鼠标指针的y轴距离 return event; // 返回标准化的事件对象 &#125; // 定义鼠标事件处理函数 document.onmousedown = function(event)&#123; // 按下鼠标时，初始化处理 event = e(event); // 获取标准事件对象 o = event.target; // 获取当前拖放的元素 ox = parseInt(o.offsetLeft); // 拖放元素的x轴坐标 oy = parseInt(o.offsetTop); // 拖放元素的y轴坐标 mx = event.mx; // 按下鼠标指针的x轴坐标 my = event.my; // 按下鼠标指针的y轴坐标 document.onmousemove = move; // 注册鼠标移动事件处理函数 document.onmouseup = stop; // 注册松开鼠标事件处理函数 &#125; function move(event)&#123; // 鼠标移动处理函数 event = e(event); o.style.left = ox + event.mx - mx + &quot;px&quot;; // 定义拖动元素的x轴距离 o.style.top = oy + event.my - my + &quot;px&quot;; // 定义拖动元素的y轴距离 &#125; function stop(event)&#123; // 松开鼠标处理函数 event = e(event); ox = parseInt(o.offsetLeft); // 记录拖放元素的x轴坐标 oy = parseInt(o.offsetTop); // 记录拖放元素的y轴坐标 mx = event.mx ; // 记录鼠标指针的x轴坐标 my = event.my ; // 记录鼠标指针的y轴坐标 o = document.onmousemove = document.onmouseup = null; // 释放所有操作对象 &#125;&lt;/script&gt; 鼠标经过 鼠标经过包括移过和移出两种事件类型。当移动鼠标指针到某个元素上时，将触发 mouseover 事件；而当把鼠标指针移出某个元素时，将触发 mouseout 事件。如果从父元素中移到子元素中时，也会触发父元素的 mouseover 事件类型。 示例 在下面示例中，分别为3个嵌套的div元素定义了mouseover和mouseout事件处理函数，这样当从外层的父元素中移动到内部的子元素中时，将会触发父元素的 mouseover 事件类型，但是不会触发 mouseout 事件类型。 1234567891011121314151617&lt;div&gt; &lt;div&gt; &lt;div&gt;盒子&lt;/div&gt; &lt;/div&gt;&lt;/div&gt;&lt;script&gt; var div = document.getElementsByTagName(&quot;div&quot;); // 获取3个嵌套的div元素 for(var i=0;i&lt;div.length;i++)&#123; // 遍历嵌套的div元素 div[i].onmouseover = function(e)&#123; // 注册移过事件处理函数 this.style.border = &quot;solid blue&quot;; &#125; div[i].onmouseout = function()&#123; // 注册移出事件处理函数 this.style.border = &quot;solid red&quot;; &#125; &#125;&lt;/script&gt; 鼠标来源 当一个事件发生后，可以使用事件对象的 target 属性获取发生事件的节点元素。如果在 IE 事件模型中实现相同的目标，可以使用 srcElement 属性。 示例： 在下面示例中，当鼠标移过页面中的 div 元素时，会弹出提示对话框，提示当前元素的节名称。 123456789&lt;div&gt;div元素&lt;/div&gt;&lt;script&gt; var div = document.getElementsByTagName(&quot;div&quot;)[0]; div.onmouseover = function(e)&#123; // 注册mouseover事件处理函数 var e = e || window.event; // 标准化事件对象，兼容DOM和IE事件模型 var o = e.target || e.srcElement; // 标准化事件属性，获取当前事件的节点 alert(o.tagName); // 返回字符串“DIV” &#125;&lt;/script&gt; 在 DOM 事件模型中还定义了 currentTarget 属性，当事件在传播过程中（如捕获和冒泡阶段）时，该属性值与 target 属性值不同。因此，一般在事件处理函数中，有你哥哥使用该属性而不是 this 关键词获取当前对象。 除了使用上面提到的通用事件属性外，如果想获取鼠标指针来移动某个元素，在 DOM 事件模型中可以使用 relatedTarget 属性获取当前事件对象的相关节点元素；而在 IE 事件模型中，可以使用 fromElement 获取 mouseover 事件中鼠标移到过的元素，使用 toElement 属性获取在 mouseout 事件中鼠标移到的文档元素。 示例2： 在下面示例中，当鼠标移到 div 元素上时，会弹出“BODY”字符提示信息，说明鼠标指针是从 body 元素过来的；而移开鼠标指针时，又弹出“BODY”字符提示信息，说明离开 div 元素将要移到的元素。 1234567891011121314&lt;div&gt;div元素&lt;/div&gt;&lt;script&gt; var div = document.getElementsByTagName(&quot;div&quot;)[0]; div.onmouseover = function(e)&#123; var e = e || window.event; var o = e.relatedTarget || e.fromElement; //标准化事件属性，获取与当前事件相关的节点 alert(o.tagName); &#125; div.onmouseout = function(e)&#123; var e = e || window.event; var o = e.relatedTarget || e.toElement; // 标准化事件属性，获取与当前事件相关的节点 alert(o.tagName); &#125;&lt;/script&gt; 键盘事件在JavaScript中，当用户操作键盘时，会触发键盘事件，键盘事件主要包括下面3种类型： keydown：在键盘上按下某个键时触发。如果按住某个键，会不断触发该事件，但是Opera浏览器不支持这种连续操作。该事件处理函数返回false时，会取消默认的动作（如输入的键盘字符，在IE和Safari浏览器下还会禁止keypress事件响应）。 keypress：按下某个键盘键并释放时触发。如果按住某个键，会不断触发该事件。该事件处理函数返回false时，会取消默认的动作（如输入的键盘字符）。 keyup：释放某个键盘键时触发。该事件仅在松开键盘时触发一次，不是一个持续的响应状态。 当获取用户正按下键码时，可以使用keydown、keypress和keyup事件获取这些信息。其中keydown和keypress事件基本上是同义事件，它们的表现也完全一致，不过一些浏览器不允许使用keypress事件获取按键信息。所有元素都支持键盘事件，但键盘事件多被应用在表单输入中。 示例 下面示例实时捕获键盘操作的各种细节，即键盘响应事件类型及对应的键值。 123456789101112&lt;textarea id=&quot;key&quot;&gt;&lt;/textarea&gt;&lt;script&gt; var key = document.getElementById(&quot;key&quot;); key.onkeydown =f; //注册keydown事件处理函数 key.onkeyup = f; //注册keyup事件处理函数 key.onkeypress = f; //注册keypress事件处理函数 function f (e) &#123; var e = e || window.event; //标准化事件处理 var s = e.type + &quot; &quot; + e.keyCode; //获取键盘事件类型和按下的值 key.value = s; &#125;&lt;/script&gt; 键盘事件属性 键盘定义了很多属性，如下表所示。利用这些属性可以精确控制键盘操作。键盘事件属性一般只在键盘相关事件发生时才会存在于事件对象中，但是 ctrlKey 和 shiftKey 属性除外，因为它们可以在水保事件中存在。例如，当按下 Ctrl 或Shift 键时单击鼠标操作。 keyCode ：该属性包含键盘中对应键位的键值 charCode ：该属性包含键盘中对应键位的 Unicode 编码，仅 DOM 支持 target：发生事件的节点（包含元素），仅 DOM 支持 srcElement ：发生事件的元素，仅 IE 支持 shiftKey：是否按下 Shift 键，如果按下返回 true，否则为false ctrlKey：是否按下 Ctrl 键，如果按下返回 true，否则为false altKey：是否按下 Alt 键，如果按下返回 true，否则为false metaKey：是否按下 Mtea 键，如果按下返回 true，否则为false，仅 DOM 支持 示例： ctrlKey和shiftKey属性可存在于键盘和鼠标事件中，表示键盘上的Ctrl和Shift键是否被按住。下面示例能够监测Ctrl 和Shift键是否被同时按下。如果同时按下，且鼠标单击某个页面元素，则会把该元素从页面中删除。 1234567document.onclick = function (e) &#123; var e = e || window.event; //标准化事件对象 var t = e.target || e.srcElement; //获取发生事件的元素，兼容IE和DOM if (e.ctrlKey &amp;&amp; e.shiftKey) &#123; //如果同时按下Ctrl和Shift键 t.parentNode.removeChild(t); //移出当前元素 &#125;&#125; 09（数字键）：4857 AZ（字母键）：6590 Backspace（退格键）：8 Tab（制表键）：9 Enter（回车键）：13 Space（空格键）：32 Left arrow（左箭头键）：37 Top arrow（上箭头键）：38 Right arrow（右箭头键）：39 Down arrow（下箭头键）：40 示例2： 下面示例演示了如何使用方向键控制页面元素的移动效果。 12345678910111213141516171819202122232425262728&lt;div id=&quot;box&quot;&gt;&lt;/div&gt;&lt;script&gt; var box = document.getElementById(&quot;box&quot;); // 获取页面元素的引用指针 box.style.position = &quot;absolute&quot;; // 色块绝对定位 box.style.width = &quot;20px&quot;; // 色块宽度 box.style.height = &quot;20px&quot;; // 色块高度 box.style.backgroundColor = &quot;red&quot;; // 色块背景 document.onkeydown = keyDown; //在Document对象中注册keyDown事件处理函数 function keyDown(event)&#123; // 方向键控制元素移动函数 var event = event || window.event; // 标准化事件对象 switch(event.keyCode)&#123; // 获取当前按下键盘键的编码 case 37 : // 按下左箭头键，向左移动5个像素 box.style.left = box.offsetLeft - 5 + &quot;px&quot;; break; case 39 : // 按下右箭头键，向右移动5个像素 box.style.left = box.offsetLeft + 5 + &quot;px&quot;; break; case 38 : // 按下上箭头键，向上移动5个像素 box.style.top = box.offsetTop - 5 + &quot;px&quot;; break; case 40 : // 按下下箭头键，向下移动5个像素 box.style.top = box.offsetTop + 5 + &quot;px&quot;; break; &#125; return false &#125;&lt;/script&gt; 在上面示例中，首先获取页面元素，通过 CSS 脚本控制元素绝对定位、大小和背景色。然后在 document 对象上注册鼠标按下事件类型处理函数，在事件回调函数 keyDown() 中侦测当前按下的方向键，并决定定位元素在窗口中的位置。其中元素的 offsetLeft 和 offsetTop 属性可以存取它在页面中的位置。 键盘响应顺序 当按下键盘时，会连续触发多个事件，它们将按如下顺序发生。 对于字符键来说，键盘事件的响应顺序：keydown → keypress → keyup。 对于非字符键（如功能键或特殊键）来说，键盘事件的相应顺序：keydown → keyup。 如果按下字符键不放，则 keydown 和 keypress 事件将逐个持续发生，直至松开按键。 如果按下非字符键不放，则只有 keydown 事件持续发生，直至松开按键。 示例 下面设计一个简单示例，以获取键盘事件相应顺序。 12345678910111213&lt;textarea id=&quot;text&quot; cols=&quot;26&quot; rows=&quot;16&quot;&gt;&lt;/textarea&gt;&lt;script&gt; var n = 1; // 定义编号变量 var text = document.getElementById(&quot;text&quot;); // 获取文本区域的引用指针 text.onkeydown = f; // 注册keydown事件处理函数 text.onkeyup = f; // 注册keyup事件处理函数 text.onkeypress = f; // 注册keypress事件处理函数 function f(e)&#123; // 事件调用函数 var e = e || window.event; // 标准化事件对象 text.value += (n++) + &quot;=&quot; + e.type +&quot; (keyCode=&quot; + e.keyCode + &quot;)\\n&quot;; //捕获事件响应信息 &#125;&lt;/script&gt; 表单事件onblur:元素失去焦点时触发 123456789101112&lt;script type=&quot;text/javascript&quot;&gt;function upperCase()&#123; var x=document.getElementById(&quot;fname&quot;).value document.getElementById(&quot;fname&quot;).value=x.toUpperCase()&#125;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;输入您的姓名：&lt;input type=&quot;text&quot; id=&quot;fname&quot; onblur=&quot;upperCase()&quot; /&gt;&lt;/body&gt; onfocus:元素获取焦点时触发 123456789101112131415&lt;html&gt;&lt;head&gt;&lt;script type=&quot;text/javascript&quot;&gt;function setStyle(x)&#123; document.getElementById(x).style.background=&quot;yellow&quot;&#125;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;First name: &lt;input type=&quot;text&quot; onfocus=&quot;setStyle(this.id)&quot; id=&quot;fname&quot; /&gt;&lt;br /&gt;Last name: &lt;input type=&quot;text&quot; onfocus=&quot;setStyle(this.id)&quot; id=&quot;lname&quot; /&gt;&lt;/body&gt;&lt;/html&gt; onsubmit:表单提交时触发 12345678910111213141516171819202122232425262728&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;onsubmit用户提交,submit属性,事件&lt;/title&gt;&lt;/head&gt;&lt;script type=&quot;text/javascript&quot;&gt; function test()&#123; var s1 =document.mianform.user.value; var s2 = document.mianform.pwd.value ; if(s1 == &quot;&quot;||s2 ==&quot;&quot;)&#123; alert(&#x27;请将内容填写完整&#x27;); return false ;//false不提交 &#125; return true ; // true提交 &#125;&lt;/script&gt;&lt;body&gt; &lt;form name=&quot;mianform&quot; onsubmit=&quot;return test()&quot;&gt; &lt;label&gt;姓名:&lt;/label&gt; &lt;input type=&quot;text&quot; name=&quot;user&quot; onfocus=&quot;console.log(&#x27;点击这里输入用户名&#x27;);&quot; onblur=&quot;console.log(&#x27;文本失去焦点&#x27;);&quot;&gt; &lt;br&gt; &lt;label&gt;密码:&lt;/label&gt; &lt;input type=&quot;password&quot; name=&quot;pwd&quot; &gt; &lt;br&gt; &lt;input type=&quot;submit&quot; value=&quot;提交&quot; &gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; onreset:表单重置时触发 onchange:表单域里的内容改变时触发 onselect:用户选取表单域里的文本时触发 12345678910111213141516&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot;&gt;&lt;title&gt; 内容选中事件 &lt;/title&gt;&lt;script type=&quot;text/javascript&quot;&gt; function message()&#123; alert(&quot;您触发了选中事件！&quot;); &#125;&lt;/script&gt; &lt;/head&gt;&lt;body&gt; &lt;form&gt; 个人简介：&lt;br&gt; &lt;textarea name=&quot;summary&quot; cols=&quot;60&quot; rows=&quot;5&quot; onselect=&quot;message()&quot;&gt;请写入个人简介，不少于200字！&lt;/textarea&gt; &lt;/form&gt;&lt;/body&gt; 绑定和删除事件addEventListener()方法用于向指定元素添加事件句柄 removeEventListener()方法用于移除由addEventLister()方法添加的事件句柄 其他事件1）页面事件 onload 页面载入完毕时触发 onunload 用户退出页面时触发 2）窗口事件 onresize 窗口被调整大小时触发 onscroll 元素滚动条在滚动时触发","categories":[{"name":"DOM","slug":"DOM","permalink":"http://example.com/categories/DOM/"}],"tags":[{"name":"DOM","slug":"DOM","permalink":"http://example.com/tags/DOM/"}]},{"title":"DOM","slug":"DOM","date":"2017-07-15T13:19:55.000Z","updated":"2022-05-28T02:29:45.829Z","comments":true,"path":"2017/07/15/DOM/","link":"","permalink":"http://example.com/2017/07/15/DOM/","excerpt":"","text":"DOM简介Document Object Model 文档对象模型 DOM包含了所有HTML元素的属性和方法，以及访问操作他们的方式； 认识dom树和dom节点什么是Dom操作？ DOM是一个使程序和脚本有能力动态地访问和更新文档的内容、结构以及样式的平台和语言中立的接口 在HTML和JavaScript的学习中，DOM操作可谓时重中之重 Dom树 DOM节点的分类：DOM节点分为三大类：元素（标签）节点、属性节点、文本节点； 节点之间的关系：由DOM树我们可以看到，文本节点、属性节点属于元素节点的子节点 在操作元素节点和文本节点前，一定要先获取到元素节点。 访问节点通过ID名查找dom元素语法：document.getElementById(“id名”) 功能：找页面中对应id名的元素； 返回值：dom元素 返回值类型：object; 说明：getELementById()前面必须的document对象（即文档对象）如果页面中没有这个id元素，返回null; 通过标签名找元素语法1：document.getElementsByTagName(“标签名”) 功能：获取页面中所有指定标签； 返回值：返回一个类数组（即一个集合）；换句话说，就是将页面中所有的指定标签放在一个方括号的集合里面。 获取具体的某个元素； 通过name属性找元素document.getElementByName: 方法可返回带有指定名称的对象的集合 通过指定的类名获取元素语法：document.getElementsByClassName() 功能：返回文档中所有指定类名的元素集合，作为 NodeList 对象。 HTML 5 为 document 对象和 HTML 元素新增了 getElementsByClassName() 方法，使用该方法可以选择指定类名的元素。 getElementsByClassName() 方法可以接收一个字符串参数，包含一个或多个类名，类名通过空格分隔，不分先后顺序，方法返回带有指定类的所有元素 NodeList。 浏览器支持状态：IE 9+、Firefox 3.0+、Safari 3+、Chrome 和 Opera 9.5+。 如果不考虑兼容早期 IE 浏览器或者怪异模式，用户可以放心使用。 示例1 下面示例使用 getElementsByClassName(“red”) 方法选择文档中所有包含 red 类的元素。 123456789&lt;div class=&quot;red&quot;&gt;红盒子&lt;/div&gt;&lt;div class=&quot;blue red&quot;&gt;蓝盒子&lt;/div&gt;&lt;div class=&quot;green red&quot;&gt;绿盒子&lt;/div&gt;&lt;script&gt; var divs = document.getElementsByClassName(&quot;red&quot;); for (var i = 0; i &lt; divs.length; i ++) &#123; console.log(divs[i].innerHTML); &#125;&lt;/script&gt; 示例2 下面示例使用 document.getElementById(“box”) 方法先获取 ，然后在它下面使用 getElementsByClassName(“blue red”) 选择同时包含 red 和 blue 类的元素。 12345678910&lt;div id=&quot;box&quot;&gt; &lt;div class=&quot;blue red green&quot;&gt;blue red green&lt;/div&gt;&lt;/div&gt;&lt;div class=&quot;blue red black&quot;&gt;blue red black&lt;/div&gt;&lt;script&gt; var divs = document.getElementById(&quot;box&quot;).getElementsByClassName(&quot;blue red&quot;); for (var i = 0; i &lt; divs.length; i ++) &#123; console.log(divs[i].innerHTML); &#125;&lt;/script&gt; 在 document 对象上调用 getElementsByClassName() 会返回与类名匹配的所有元素，在元素上调用该方法就只会返回后代元素中匹配的元素。 通过样式查找单个元素语法：元素.querySelector(“css选择器”); 功能：返回文档中匹配指定 CSS 选择器的一个元素 返回值：DOM对象 传递一个标签选择器 传递一个类选择器 传递一个交集选择器 获取文档中有 “target” 属性的第一个 元素 并集选择器 通过样式获取所有元素语法：元素.querySelectorAll(“css选择器”);语法：元素.querySelectorAll(“css选择器”); 功能：该方法和document.querySelector()用法类似，不同的是它会将符合条件的元素封装到一个数组中返回。即使符合条件的元素只有一个，它也会返回数组. 返回值：类数组 Document类型JavaScript 通过 Document 类型表示文档。在浏览器中，document 对象是 HTMLDocument（继承自 Document 类型）的一个实例，表示整个 HTML 页面。而且，document 对象是 window 对象的一个属性，因此可以将其作为全局对象来访问。Document 节点具有下列特征： nodeType 的值为9； nodeName 的值为 &quot;#document&quot;； nodeValue 的值为 null； parentNode 的值为 null； ownerDocument 的值为 null； 其子节点可能是一个 DocumentType（最多一个）、Element（最多一个）、ProcessingInstruction 或 Comment。 Document 类型可以表示 HTML 页面或者其他基于 XML 的文档。不过，最常见的应用还是作为 HTMLDocument 实例的 document 对象。通过这个文档对象，不仅可以取得与页面有关的信息，而且还能操作页面的外观及其底层结构。 文档的子节点虽然 DOM 标准规定 Document 节点的子节点可以是DocumentType、Element、ProcessingInstruction 或 Comment，但还有两个内置的访问其子节点的快捷方式。第一个就是documentElement 属性，该属性始终指向 HTML 页面中的 html 元素。另一个就是通过 childNodes 列表访问文档元素，但通过 documentElement 属性则能更快捷、更直接地访问该元素。以下面这个简单的页面为例。 1234&lt;html&gt; &lt;body&gt; &lt;/body&gt;&lt;/html&gt; 这个页面在经过浏览器解析后，其文档中只包含一个子节点，即 html 元素。可以通过 documentElement 或 childNodes 列表来访问这个元素，如下所示。 123var html = document.documentElement; // 取得对&lt;html&gt;的引用console.log(html === document.childNodes[0]); // trueconsole.log(html === document.firstChild); // true 这个例子说明，documentElement、firstChild 和 childNodes[0] 的值相同，都指向 &lt;html&gt; 元素。 作为 HTMLDocument 的实例，document 对象还有一个 body 属性，直接指向 &lt;body&gt; 元素。因为开发人员经常要使用这个元素，所以 document.body 在 JavaScript 代码中出现的频率非常高，其用法如下。 1var body = document.body; // 取得对&lt;body&gt;的引用 所有浏览器都支持 document.documentElement 和 document.body 属性。 Document 另一个可能的子节点是 DocumentType。通常将 &lt;!DOCTYPE&gt; 标签看成一个与文档其他部分不同的实体，可以通过 doctype 属性（在浏览器中是 document.doctype ）来访问它的信息。 1var doctype = document.doctype; // 取得对&lt;!DOCTYPE&gt;的引用 浏览器对 document.doctype 的支持差别很大，可以给出如下总结。 IE8 及之前版本：如果存在文档类型声明，会将其错误地解释为一个注释并把它当作 Comment 节点；而 document.doctype 的值始终为 null。 IE9+ 及 Firefox：如果存在文档类型声明，则将其作为文档的第一个子节点；document.doctype 是一个 DocumentType 节点，也可以通过 document.firstChild 或 document.childNodes[0] 访问同一个节点。 Safari、Chrome 和 Opera：如果存在文档类型声明，则将其解析，但不作为文档的子节点。document.doctype 是一个 DocumentType 节点，但该节点不会出现在 document.childNodes 中。 由于浏览器对 document.doctype 的支持不一致，因此这个属性的用处很有限。 文档信息作为 HTMLDocument 的一个实例，document 对象还有一些标准的 Document 对象所没有的属性。这些属性提供了 document 对象所表现的网页的一些信息。其中第一个属性就是 title，包含着 &lt;title&gt; 元素中的文本——显示在浏览器窗口的标题栏或标签页上。通过这个属性可以取得当前页面的标题，也可以修改当前页面的标题并反映在浏览器的标题栏中。 12345// 取得文档标题var originalTitle = document.title;// 设置文档标题document.title = &quot;New page title&quot;; 接下来要介绍的3个属性都与对网页的请求有关，它们是 URL、domain 和 referrer。URL 属性中包含页面完整的 URL（即地址栏中显示的URL），domain 属性中只包含页面的域名，而 referrer 属性中则保存着链接到当前页面的那个页面的 URL。在没有来源页面的情况下，referrer 属性中可能会包含空字符串。所有这些信息都存在于请求的 HTTP 头部，只不过是通过这些属性让我们能够在 JavaScrip 中访问它们而已，如下面的例子所示。 12345678// 取得完整的URLvar url = document.URL;// 取得域名var domain = document.domain;// 取得来源页面的URLvar referrer = document.referrer; 更改节点内容 获取元素的内容 语法：元素.innerHTML; 说明：获取到的内容都是string 类型； 修改设置元素的内容 语法：元素.innerHTML &#x3D; ‘内容’ 元素的行内样式获取元素的行内样式 style 语法：元素.style.css属性； 注意：复合属性需要转驼峰； 设置元素的行内样式语法：元素.style.css属性 &#x3D; 属性值； 获取元素的html属性语法：元素.html属性 Eg: 元素.id 元素.src 元素.alt 元素.value 等； 设置修改元素的html属性语法：元素.属性 &#x3D; 属性值； 初始 修改后 Node 属性概述Node 常用属性主要有以下10个，接下来我们会着重讲解部分属性。 nodeType：显示节点的类型 nodeName：显示节点的名称 nodeValue：显示节点的值 attributes：获取一个属性节点 firstChild：表示某一节点的第一个节点 lastChild：表示某一节点的最后一个子节点 childNodes：表示所在节点的所有子节点 parentNode：表示所在节点的父节点 nextSibling：紧挨着当前节点的下一个节点 previousSibling：紧挨着当前节点的上一个节点 nodeName 和 nodeValue 属性要了解节点的具体信息，可以使用 nodeName 和 nodeValue 这两个属性。这两个属性的值完全取决于节点的类型。在使用这两个值以前，最好是像下面这样先检测一下节点的类型。 123if (someNode.nodeType == 1)&#123; value = someNode.nodeName; // nodeName的值是元素的标签名&#125; 在这个例子中，首先检查节点类型，看它是不是一个元素。如果是，则取得并保存 nodeName 的值。对于元素节点，nodeName 中保存的始终都是元素的标签名，而 nodeValue 的值则始终为 null。 属性节点的主要特征值：nodeType 等于 2、nodeName 等于属性的名称、nodeValue 等于属性的值、parentNode 等于 null，在 HTML 中不包含子节点。属性节点继承于 Node 类型，包含以下 3 个专用属性。 name：表示属性名称，等效于 nodeName。 value：表示属性值，可读可写，等效于 nodeValue。 specified：如果属性值是在代码中设置的，则返回 true；如果为默认值，则返回 false。 创建属性节点使用 document 对象的 createAttribute() 方法可以创建属性节点，具体用法如下： 1document.createAttribute(name) 参数 name 表示新创建的属性的名称。 示例1 下面示例创建一个属性节点，名称为 align，值为 center，然后为标签 设置属性 align，最后分别使用 3 种方法读取属性 align 的值。 12345678910&lt;div id=&quot;box&quot;&gt;document.createAttribute(name)&lt;/div&gt;&lt;script&gt; var element = document.getElementById(&quot;box&quot;); var attr = document.createAttribute(&quot;align&quot;); attr.value = &quot;center&quot;; element.setAttributeNode(attr); console.log(element.attributes[&quot;align&quot;].value); //&quot;center&quot; console.log(element.getAttributeNode(&quot;align&quot;).value); //&quot;center&quot; console.log(element.getAttribute(&quot;align&quot;)); //&quot;center&quot;&lt;/script&gt; 属性节点一般位于元素的头部标签中。元素的属性列表会随着元素信息预先加载，并被存储在关联数组中。例如，针对下面 HTML 结构。 1&lt;div id=&quot;div1&quot; class=&quot;style1&quot; lang=&quot;en&quot; title=&quot;div&quot;&gt;&lt;/div&gt; 当 DOM 加载后，表示 HTML div 元素的变量 divElement 就会自动生成一个关联集合，它以名值对形式检索这些属性。 123456divElement.attributes = &#123; id : &quot;div1&quot;, class : &quot;style1&quot;, lang : &quot;en&quot;, title : &quot;div&quot;&#125; 在传统 DOM 中，常用点语法通过元素直接访问 HTML 属性，如 img.src、a.href 等，这种方式虽然不标准，但是获得了所有浏览器的支持。 示例2 img 元素拥有 src 属性，所有图像对象都拥有一个 src 脚本属性，它与 HTML 的 src 特性关联在一起。下面两种用法都可以很好地工作在不同浏览器中。 123456&lt;img id=&quot;img1&quot; src=&quot;&quot; /&gt;&lt;script&gt; var img = document.getElementById(&quot;img1&quot;); img.setAttribute(&quot;src&quot;, &quot;http://www.w3.org&quot;); //HTML 属性 img.src = &quot;http://www.w3.org&quot;; //JavaScript 属性&lt;/script&gt; 类似的还有 onclick、style 和 href 等。为了保证 JavaScript 脚本在不同浏览器中都能很好地工作，建议采用标准用法，而且很多 HTML 属性并没有被 JavaScript 映射，所以也就无法直接通过脚本属性进行读写。 读取属性值使用元素的 getAttribute() 方法可以读取指定属性的值。用法如下： 1getAttribute(name) 参数 name 表示属性名称。 使用元素的 attributes 属性、getAttributeNode() 方法可以返回对应属性节点。 示例1 下面示例访问红色盒子和蓝色盒子，然后读取这些元素所包含的 id 属性值。 12345678&lt;div id=&quot;red&quot;&gt;红盒子&lt;/div&gt;&lt;div id=&quot;blue&quot;&gt;蓝盒子&lt;/div&gt;&lt;script&gt; var red = document.getElementById(&quot;red&quot;); //获取红色盒子 console.log(red.getAttribute(&quot;id&quot;)); //显示红色盒子的id属性值 var blue = document.getElementById(&quot;blue&quot;); //获取蓝色盒子 console.log(blue.getAttribute(&quot;id&quot;)); //显示蓝色盒子的id属性值&lt;/script&gt; 示例2 HTML DOM 也支持使用点语法读取属性值，使用比较简便，也获得了所有浏览器的支持。 1234var red = document.getElementById(&quot;red&quot;);console.log(red.id);var blue = document.getElementById(&quot;blue&quot;);console.log(blue.id); 对于 class 属性，则必须使用 className 属性名，因为 class 是 JavaScript 的保留字；对于 for 属性，则必须使用 htmlFor 属性名，这与 CSS 脚本中 float 和 text 属性被改名为 cssFloat 和 cssText 是一个道理。 示例3 使用 className 读写样式类。 12345678&lt;label id=&quot;label1&quot; class=&quot;class1&quot; for=&quot;textfield&quot;&gt;文本框： &lt;input type=&quot;text&quot; name=&quot;textfield&quot; id=&quot;textfield&quot; /&gt;&lt;/label&gt;&lt;script&gt; var label = document.getElementById(&quot;label1&quot;); console.log(label.className); console.log(label.htmlFor);&lt;/script&gt; 示例4 对于复合类样式，需要使用 split() 方法劈开返回的字符串，然后遍历读取类样式。 12345678&lt;div id=&quot;red&quot; class=&quot;red blue&quot;&gt;红盒子&lt;/div&gt;&lt;script&gt; //所有类名生成的数组 var classNameArray = document.getElementById(&quot;red&quot;).className.split(&quot; &quot;); for (var i in classNameArray) &#123; //遍历数组 console.log(classNameArray[i]); //当前class名 &#125;&lt;/script&gt; 设置属性值使用元素的 setAttribute() 方法可以设置元素的属性值。用法如下： 1setAttribute(name) 参数 name 和 value 分别表示属性名称和属性值。属性名和属性值必须以字符串的形式进行传递。如果元素中存在指定的属性，它的值将被刷新；如果不存在，则 setAttribute() 方法将为元素创建该属性并赋值。 示例1 下面示例分别为页面中 div 元素设置 title 属性。 12345678&lt;div id=&quot;red&quot;&gt;红盒子&lt;/div&gt;&lt;div id=&quot;blue&quot;&gt;蓝盒子&lt;/div&gt;&lt;script&gt; var red = document.getElementById(&quot;red&quot;); //获取红盒子的引用 var blue= document.getElementById(&quot;blue&quot;); //获取蓝盒子的引用 red.setAttribute(&quot;title&quot;, &quot;这是红盒子&quot;); //为红盒子对象设置title属性和值 blue.setAttribute(&quot;title&quot;, &quot;这是蓝盒子&quot;); //为蓝盒子对象设置title属性和值&lt;/script&gt; 示例2 下面示例定义了一个文本节点和元素节点，并为一级标题元素设置 title 属性，最后把它们添加到文档结构中。 12345var hello = document.createTextNode(&quot;Hello World!&quot;); //创建一个文本节点var h1 = document.createElement(&quot;h1&quot;); //创建一个一级标题h1.setAttribute(&quot;title&quot;, &quot;你好，欢迎光临！&quot;); //为以及标题定义title 属性h1.appendChild(hello); //把文本节点增加到一级标题中document.body.appendChild(h1); //把一级标题增加到文档 示例3 也可以使用快捷方法设置 HTML DOM 文档中元素的属性值。 12345678&lt;label id=&quot;label1&quot;&gt;文本框： &lt;input type=&quot;text&quot; name=&quot;textfield&quot; id=&quot;textfield&quot; /&gt;&lt;/label&gt;&lt;script&gt; var label1 = document.getElementById(&quot;label1&quot;); label.className = &quot;class1&quot;; label.htmlFor = &quot;textfield&quot;;&lt;/script&gt; DOM 支持使用 getAttribute() 和 setAttribute() 方法读写自定义属性，不过 IE 6.0 及其以下版本浏览器对其的支持不是很完善。 示例4 直接使用 className 添加类样式，会覆盖掉元素原来的类样式。这时可以采用叠加的方式添加类。 123456&lt;div id=&quot;red&quot;&gt;红盒子&lt;/div&gt;&lt;script&gt; var red = document.getElementById(&quot;red&quot;); red.className = &quot;red&quot;; red.className += &quot;blue&quot;;&lt;/script&gt; 示例5 使用叠加的方式添加类也存在问题，这样容易添加大量重复的类。为此，定义一个检测函数，判断元素是否包含指定的类，然后再决定是否添加类。 12345678910111213141516&lt;script&gt; function hasClass (element, className) &#123; //检测类名函数 var reg = new RegExp(&#x27;(\\\\s|^)&#x27; + className + &#x27;(\\\\s|$)&#x27;); return reg.test(element.className); //使用正则检测是否有相同的样式 &#125; function addClass (element, className) &#123; //添加类名函数 if (! hasClass (element, className)) element.className += &#x27; &#x27; + className; &#125;&lt;/script&gt;&lt;div id=&quot;red&quot;&gt;红盒子&lt;/div&gt;&lt;script&gt; var red = document.getElementById(&quot;red&quot;); addClass(red, &#x27;red&#x27;); addClass(red, &#x27;blue&#x27;);&lt;/script&gt; 删除属性使用元素的 removeAttribute() 方法可以删除指定的属性。用法如下： 1removeAttribute(name) 参数 name 表示元素的属性名。 示例1 下面示例演示了如何动态设置表格的边框 123456789101112131415161718&lt;script&gt; window.onload = function () &#123; //绑定页面加载完毕时的事件处理函数 var table = document.getElementByTagName(&quot;table&quot;)[0]; //获取表格外框的引用 var del = document.getElementById(&quot;del&quot;); var reset = document.getElementById(&quot;reset&quot;); del.onclick = function () &#123; table.removeAttribute(&quot;border&quot;); &#125; reset.onclick = function () &#123; table.setAttribute(&quot;border&quot;, &quot;2&quot;); &#125;&lt;/script&gt;&lt;table width=&quot;100%&quot; border=&quot;2&quot;&gt; &lt;tr&gt; &lt;td&gt;数据表格&lt;/td&gt; &lt;tr&gt;&lt;/table&gt;&lt;button id=&quot;del&quot;&gt;删除&lt;/button&gt;&lt;button id=&quot;reset&quot;&gt;恢复&lt;/button&gt; 在上面示例中设计了两个按钮，并分别绑定了不同的事件处理函数。单击“删除”按钮即可调用表格的 removeAttribute() 方法清除表格边框，单击“恢复”按钮即可调用表格的 setAttribute() 方法重新设置表哥便可的粗细。 示例2 下面示例演示了如何自定义删除类函数，并调用该函数删除指定类名。 12345678910111213141516&lt;script&gt; function hasClass (element, className) &#123; //类名检测函数 var reg = new RegExp (&#x27;(\\\\s|^)&#x27; + className + &#x27;(\\\\s|$)&#x27;); return reg.test (element, className); //使用正则检测是否有相同的样式 &#125; function deleteClass (element, className) &#123; if (hasClass (element, className)) &#123; element.className.replace (reg, &#x27; &#x27;); //捕获要删除样式，然后替换为空白字符串 &#125; &#125;&lt;/script&gt;&lt;div id=&quot;red&quot; class=&quot;red blue bold&quot;&gt;盒子&lt;/div&gt;&lt;script&gt; var red = document.getElementById (&quot;red&quot;); deleteClass (red, &#x27;blue&#x27;);&lt;/script&gt; 上面代码使用正则表达式检测 className 属性值字符串中是否包含指定的类名，如果存在，则使用空字符串替换掉匹配到的子字符串，从而实现删除类名的目的。 创建节点createElement() 方法创建新的元素节点。 document.createElement()是在对象中创建一个对象，要与appendChild()或insertBefore()方法联合使用。其中，appendChild()方法在节点的子节点列表末添加新的子节点。insertBefore()方法在节点的子节点列表任意位置插入新的节点。 添加节点appendChild() 方法向已存在的节点添加子节点。 示例： 12345678&lt;div id=&quot;board&quot;&gt;&lt;/div&gt;&lt;script&gt;var board = document.getElementById(&quot;board&quot;);var e = document.createElement(&quot;input&quot;);e.type = &quot;button&quot;;e.value = &quot;这是测试加载的小例子&quot;;var object = board.appendChild(e);&lt;/script&gt; 示例2： 12345678&lt;script type=&quot;text/javascript&quot;&gt; var board = document.getElementById(&quot;board&quot;); var e2 = document.createElement(&quot;select&quot;); e2.options[0] = new Option(&quot;加载项1&quot;, &quot;&quot;); e2.options[1] = new Option(&quot;加载项2&quot;, &quot;&quot;); e2.size = &quot;2&quot;; var object = board.appendChild(e2);&lt;/script&gt; 示例3： 123456789&lt;script type=&quot;text/javascript&quot;&gt; var board = document.getElementById(&quot;board&quot;); var e3 = document.createElement(&quot;input&quot;); e4.setAttribute(&quot;type&quot;, &quot;text&quot;); e4.setAttribute(&quot;name&quot;, &quot;q&quot;); e4.setAttribute(&quot;value&quot;, &quot;使用setAttribute&quot;); e4.setAttribute(&quot;onclick&quot;, &quot;javascript:alert(&#x27;This is a test!&#x27;);&quot;); var object = board.appendChild(e3);&lt;/script&gt; 替换节点replaceChild() 方法可以将某个子节点替换为另一个。 语法： 1nodeObject.replaceChild(new_node, old_node) 其中参数 new_node 为指定新的节点，old_node 为被替换的节点。如果替换成功，则返回被替换的节点；如果替换失败，则返回 null。 示例1： 以上示例为基础重写脚本，新建一个二级标题元素并替换掉红色盒子中的一级标题元素。 1234567var ok = document.getElementById(&quot;ok&quot;); //获取按钮元素的引用ok.onclick = function () &#123; //为按钮注册一个鼠标单击事件处理函数 var red = document.getElementById(&quot;red&quot;); //获取红色盒子的引用 var h1 = document.getElementsByTagName(&quot;h1&quot;)[0]; //获取一级标题的引用 var h2 = documeng.createElement(&quot;h2&quot;); //创建二级标题元素并引用 red.replaceChild(h2, h1); //把一级标题替换为二级标题&#125; 示例2： 在下面示例中使用蓝盒子替换掉红盒子中包含的一级标题元素。此时可以看到，蓝盒子原来显示的位置已经被删除显示，同时被替换元素 h1 也被删除。 1234567var ok = document.getElementById(&quot;ok&quot;); //获取按钮元素的引用ok.onclick = function () &#123; //为按钮注册一个鼠标单击事件处理函数 var red = document.getElementById(&quot;red&quot;); //获取红色盒子的引用 var blue= document.getElementById(&quot;blue&quot;); //获取蓝色盒子的引用 var h1 = document.getElementsByTagName(&quot;h1&quot;)[0]; //获取一级标题的引用 red.replaceChild(blue, h1); //把红盒子中包含的一级标题替换为蓝盒子&#125; 示例3： replaceChild() 方法能够返回被替换掉的节点引用，因此还可以把被替换掉的元素给找回来，并增加到文档中的指定节点中。 针对上面示例，使用一个变量 del_h1 存储被替换掉的一级标题，然后再把它插入到红色盒子前面。 12345678var ok = document.getElementById(&quot;ok&quot;); //获取按钮元素的引用ok.onclick = function () &#123; //为按钮注册一个鼠标单击事件处理函数 var red = document.getElementById(&quot;red&quot;); //获取红色盒子的引用 var blue= document.getElementById(&quot;blue&quot;); //获取蓝色盒子的引用 var h1 = document.getElementsByTagName(&quot;h1&quot;)[0]; //获取一级标题的引用 var del_h1 = red,replaceChild(blue, h1); //把红盒子中包含的一级标题替换为蓝盒子 red.parentNode.insertBefore(del_h1, red); //把替换掉的一级标题插入到红盒子前面&#125; 自定义属性HTML 5 允许用户为元素自定义属性，但要求添加 data- 前缀，目的是为元素提供与渲染无关的附加信息，或者提供语义信息。例如： 1&lt;div id=&quot;box&quot; data-myid=&quot;12345&quot; data-myname=&quot;zhangsan&quot; data-mypass=&quot;zhang123&quot;&gt;自定义数据属性&lt;/div&gt; 添加自定义属性之后，可以通过元素的 dataset 属性访问自定义属性。dataset 属性的值是一个 DOMStringMap 实例，也就是一个名值对的映射。在这个映射中，每个 data-name 形式的属性都会有一个对应的属性，只不过属性名没有 data- 前缀。 浏览器支持状态：Firefox 6+ 和 Chrome。 示例 下面代码演示了如何自定义属性，以及如何读取这些附加信息。 12345678910111213var div = document.getElementById(&quot;box&quot;);//访问自定义属性值var id = div.dataset.myid;var name = div.dataset.myname;var pass = div.dataset.mypass;//重置自定义属性值div.dataset.myid = &quot;66666&quot;;div.dataset.myname = &quot;zhangsan&quot;;div.dataset.mypass = &quot;zhangsan666&quot;;//检测自定义属性if (div.dataset.myname) &#123; console.log(div.dataset.myname);&#125; 虽然上述用法未获得所有浏览器支持，但是我们仍然可以使用这种方式为元素添加自定义属性，然后使用 getAttribute() 方法读取元素附加的信息。 节点关系识别空白文本元素.firstChild 第一个子节点 元素.lastChild 最后一个子节点 元素.childNodes 获取所有的子节点 元素.attributes 获取某个元素的所有属性节点 元素.nextSibling 获取下一个兄弟节点 元素.previousSibling 获取上一个兄弟节点 不识别空白文本元素.children 获取所有的元素子节点 元素.firstElementChild 获取第一个元素子节点 元素.lastElementChild 获取最后一个元素子节点 元素.nextElementSibling 获取下一个元素兄弟节点 元素.previousElementSibling 获取上一个元素兄弟节点 元素.parentNode 父节点","categories":[{"name":"DOM","slug":"DOM","permalink":"http://example.com/categories/DOM/"}],"tags":[{"name":"DOM","slug":"DOM","permalink":"http://example.com/tags/DOM/"}]},{"title":"javascript函数","slug":"javascript函数","date":"2017-05-26T03:24:17.000Z","updated":"2022-05-26T11:38:23.302Z","comments":true,"path":"2017/05/26/javascript函数/","link":"","permalink":"http://example.com/2017/05/26/javascript%E5%87%BD%E6%95%B0/","excerpt":"","text":"函数函数是一个代码块，定义之后，可以被执行或调用任意多次。Js函数是参数化的，即函数定义可以包含一组标识符，称为参数或形参。 定义函数在Js中定义函数最直观的方式就是使用function关键字，这个关键字可以用作声明或表达式。 命名函数的标识符 一对圆括号，中间包含逗号分隔的零或多个标识符。 一对花括号，其中包含零或多个Js语句。 123function 函数名(参数,参数2,......)&#123; 表达式&#125; 例如，这段代码定义了square，来引用一个函数，它产生给定数字的平方： 123456const square = function(x) &#123; return x * x;&#125;;console.log(square(12));// → 144 变量和作用域每个变量都有一个作用域，它是程序的一部分，其中变量是可见的。 对于在任何函数或块之外定义的变量，作用域是整个程序 - 您可以在任何地方引用这种变量。它们被称为全局的。 但是为函数参数创建的，或在函数内部声明的变量，只能在该函数中引用，所以它们被称为局部变量。 每次调用该函数时，都会创建这些变量的新实例。 这提供了函数之间的一些隔离 - 每个函数调用，都在它自己的小世界（它的局部环境）中运行，并且通常可以在不知道全局环境中发生的事情的情况下理解。 用let和const声明的变量，实际上是它们的声明所在的块的局部对象，所以如果你在循环中创建了一个，那么循环之前和之后的代码就不能“看见”它。JavaScript 2015 之前，只有函数创建新的作用域，因此，使用var关键字创建的旧式变量，在它们出现的整个函数中内都可见，或者如果它们不在函数中，在全局作用域可见。 12345678910let x = 10;if (true) &#123; let y = 20; var z = 30; console.log(x + y + z); // → 60&#125;// y is not visible hereconsole.log(x + z);// → 40 每个作用域都可以“向外查看”它周围的作用域，所以示例中的块内可以看到x。 当多个变量具有相同名称时例外 - 在这种情况下，代码只能看到最内层的那个。 例如，当halve函数中的代码引用n时，它看到它自己的n，而不是全局的n。 12345678const halve = function(n) &#123; return n / 2;&#125;let n = 10;console.log(halve(100));// → 50console.log(n);// → 10 嵌套作用域JavaScript 不仅区分全局和局部变量。 块和函数可以在其他块和函数内部创建，产生多层局部环境。 例如，这个函数的内部有另一个函数： 123456789101112131415const hummus = function(factor) &#123; const ingredient = function(amount, unit, name) &#123; let ingredientAmount = amount * factor; if (ingredientAmount &gt; 1) &#123; unit += &quot;s&quot;; &#125; console.log(`$&#123;ingredientAmount&#125; $&#123;unit&#125; $&#123;name&#125;`); &#125;; ingredient(1, &quot;can&quot;, &quot;chickpeas&quot;); ingredient(0.25, &quot;cup&quot;, &quot;tahini&quot;); ingredient(0.25, &quot;cup&quot;, &quot;lemon juice&quot;); ingredient(1, &quot;clove&quot;, &quot;garlic&quot;); ingredient(2, &quot;tablespoon&quot;, &quot;olive oil&quot;); ingredient(0.5, &quot;teaspoon&quot;, &quot;cumin&quot;);&#125;; ingredient函数中的代码，可以从外部函数中看到factor变量。 但是它的局部变量，比如unit或ingredientAmount，在外层函数中是不可见的。 简而言之，每个局部作用域也可以看到所有包含它的局部作用域。 块内可见的变量集，由这个块在程序文本中的位置决定。 每个局部作用域也可以看到包含它的所有局部作用域，并且所有作用域都可以看到全局作用域。 这种变量可见性方法称为词法作用域。 作为值的函数函数变量通常只充当程序特定部分的名称。 这样的变量被定义一次，永远不会改变。 这使得容易混淆函数和名称。 123456let launchMissiles = function(value) &#123; missileSystem.launch(&quot;now&quot;);&#125;;if (safeMode) &#123; launchMissiles = function() &#123;/* do nothing */&#125;;&#125; 箭头函数箭头函数的一般形式是圆括号中逗号分隔的参数列表，后跟箭头&#x3D;&gt;，再跟包含在花括号中的函数体： 1const sum = (x,y) =&gt;&#123;return x+y&#125; 调用函数语法： 123456function add(参数,参数2....)&#123;&#125;调用方法：add(参数,参数2....) 对象中方法调用 12345678let calculator = &#123; operand1 : 1, operand2 : 2, add()&#123; this.result = this.operand1 + this.operand2 &#125;&#125;calculator.add(); this关键字不具有变量那样的作用域机制，除了箭头函数，嵌套函数不会继承包含函数的this值。如果嵌套函数被当做方法来调用，那它的this值就是调用它的对象。 可选参数与默认值当调用函数时传入的实参少于声明的形参时，额外的形参会获得默认值，通常是undefined. 1234567891011121314//把对象o的可枚举属性名放到数组a中，返回a//如果不传a,则创建一个新数组function getPropertyNames(o,a)&#123; if(a === undefined)&#123; a = []; &#125; for(let property in o)&#123; a.push(property) &#125; return a;&#125;let o = &#123;x:1&#125;,p=&#123;y:2,z:3&#125;let a = getPropertyNames(o);getPropertyNames(p,a); 现在可以直接在函数形参列表中为每个参数定义默认值。语法是形参名后面加上等于号和默认值，这样在没有给该形参传值时就会使用这个默认值。 123456function getPropertyNames(o ,a = [])&#123; for(let property in o)&#123; a.push(property) &#125; return a;&#125; 闭包闭包（closure）就是能够读取其他函数内部变量的函数。 由于在Javascript语言中，只有函数内部的子函数才能读取局部变量，因此可以把闭包简单理解成”定义在一个函数内部的函数”。 所以，在本质上，闭包就是将函数内部和函数外部连接起来的一座桥梁。 变量作用域要理解闭包，首先必须理解Javascript特殊的变量作用域。 变量的作用域无非就是两种：全局变量和局部变量。 Javascript语言的特殊之处，就在于函数内部可以直接读取全局变量。 12345var n=999;function f1()&#123; alert(n);&#125;f1(); // 999 另一方面，在函数外部自然无法读取函数内的局部变量。 12345function f1()&#123; var n=999;&#125;alert(n); // error 这里有一个地方需要注意，函数内部声明变量的时候，一定要使用var命令。如果不用的话，你实际上声明了一个全局变量！ 1234567function f1()&#123; n=999;&#125;f1();alert(n); // 999 如何从外部获取内部变量出于种种原因，我们有时候需要得到函数内的局部变量。但是，前面已经说过了，正常情况下，这是办不到的，只有通过变通方法才能实现。 那就是在函数的内部，再定义一个函数。 1234567function f1()&#123; var n=999; function f2()&#123; alert(n); // 999 &#125;&#125; 在上面的代码中，函数f2就被包括在函数f1内部，这时f1内部的所有局部变量，对f2都是可见的。但是反过来就不行，f2内部的局部变量，对f1就是不可见的。这就是Javascript语言特有的”链式作用域”结构（chain scope），子对象会一级一级地向上寻找所有父对象的变量。所以，父对象的所有变量，对子对象都是可见的，反之则不成立。 既然f2可以读取f1中的局部变量，那么只要把f2作为返回值，我们不就可以在f1外部读取它的内部变量了吗！ 123456789101112131415function f1()&#123; var n=999; function f2()&#123; alert(n); &#125; return f2;&#125;var result=f1();result(); // 999 闭包的用途闭包可以用在许多地方。它的最大用处有两个，一个是前面提到的可以读取函数内部的变量，另一个就是让这些变量的值始终保持在内存中。 123456789101112131415161718192021function f1()&#123; var n=999; nAdd=function()&#123;n+=1&#125; function f2()&#123; alert(n); &#125; return f2;&#125;var result=f1();result(); // 999nAdd();result(); // 1000 在这段代码中，result实际上就是闭包f2函数。它一共运行了两次，第一次的值是999，第二次的值是1000。这证明了，函数f1中的局部变量n一直保存在内存中，并没有在f1调用后被自动清除。 为什么会这样呢？原因就在于f1是f2的父函数，而f2被赋给了一个全局变量，这导致f2始终在内存中，而f2的存在依赖于f1，因此f1也始终在内存中，不会在调用结束后，被垃圾回收机制（garbage collection）回收。 这段代码中另一个值得注意的地方，就是”nAdd&#x3D;function(){n+&#x3D;1}”这一行，首先在nAdd前面没有使用var关键字，因此nAdd是一个全局变量，而不是局部变量。其次，nAdd的值是一个匿名函数（anonymous function），而这个匿名函数本身也是一个闭包，所以nAdd相当于是一个setter，可以在函数外部对函数内部的局部变量进行操作。 立即执行函数立即执行函数通常有下面两种写法： 12345678//第一种写法(function()&#123; ...&#125;)();//第二种写法(function()&#123; ...&#125;()); 立即执行函数的作用 立即执行函数只有一个作用：创建一个独立的作用域。这个作用域里面的变量，外面访问不到（即避免了「变量污染」）。 123456var liList = ul.getElementsByTagName(&#x27;li&#x27;)for(var i=0; i&lt;6; i++)&#123; liList[i].onclick = function()&#123; alert(i) // 为什么 alert 出来的总是 6，而不是 0、1、2、3、4、5 &#125;&#125; 因为输出的 i 是全局作用域的，当循环结束后 i 的值是 6，所以输出的 i 就是6。 用立即执行函数可以解决这个问题。 12345678var liList = document.getElementsByTagName(&#x27;li&#x27;);for(var i=0; i&lt;6; i++)&#123; (function(j)&#123; liList[j].onclick = function()&#123; alert(j) // 0、1、2、3、4、5 &#125; &#125;)(i)&#125; 因为 JS 中调用函数传递参数都是值传递 ，所以当立即执行函数执行时，首先会把参数 i 的值复制一份，然后再创建函数作用域来执行函数，循环5次就会创建5个作用域，所以每个 li 元素访问的都是不同作用域的 i 的值 。","categories":[{"name":"javascript","slug":"javascript","permalink":"http://example.com/categories/javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://example.com/tags/javascript/"}]},{"title":"javascript对象","slug":"javascript对象","date":"2017-05-26T02:54:56.000Z","updated":"2022-05-26T11:38:46.781Z","comments":true,"path":"2017/05/26/javascript对象/","link":"","permalink":"http://example.com/2017/05/26/javascript%E5%AF%B9%E8%B1%A1/","excerpt":"","text":"对象对象是一种复合值，它汇聚多个值并允许它们按名字存储和获取这些值。对象是一个属性的无序集合，每个属性都有名字和值。 1）创建对象对象可以通过对象字面量、new关键字和object.create()函数来创建。 对象字面量创建对象最简单的方式是js代码中直接包含对象字面量。对象字面量的最简单形式是包含在一对花括号中的一组逗号分隔的“键:值”对。属性名是js标识符或字符串字面量。属性值是任何js的表达式，这个表达式的值会变成属性的值。 12let empty = &#123;&#125;let point = &#123;x:0,y:0&#125; 使用New创建对象new操作符用于创建和初始化一个新对象。new关键字后面必须跟一个函数调用。以这种方式使用的函数被称为构造函数，目的是初始化新创建的对象。 12let o = new Object(); //&#123;&#125;let a = new Array();//[] Object.create()ECMAScript 5 定义了一个名为 Object.create() 的方法，它创建一个新对象，其中第一个参数是这个对象的原型。Object.create() 提供第二个可选参数，用以对对象的属性进行进一步描述。Object.create() 是一个静态函数，而不是提供给某个对象调用的方法。使用它的方法很简单，只须传入所需的原型对象即可。例如： 123var person = Object.create(Object.prototype);person.name = &quot;stone&quot;;person.age = 28; 其中 var person = Object.create(Object.prototype); 也等价于 var person = &#123;&#125;; 。 2）原型所有通过对象字面量创建的对象都具有同一个原型对象，并可以通过 JavaScript 代码 Object.prototype 获得对原型对象的引用。通过关键字 new 和构造函数调用创建的对象的原型就是构造函数的 prototype 属性的值。因此，同使用 &#123;&#125; 创建对象一样，通过 new Object() 创建的对象也继承自 Object.prototype。同样，通过 new Array() 创建的对象的原型就是 Array.prototype，通过 new Date() 创建的对象的原型就是 Date.prototype。 没有原型的对象为数不多，Object.prototype 就是其中之一。它不继承任何属性。其他原型对象都是普通对象，普通对象都具有原型。所有的内置构造函数（以及大部分自定义的构造函数）都具有一个继承自 Object.prototype 的原型。例如，Date.prototype 的属性继承自 Object.prototype，因此由 new Date() 创建的 Date 对象的属性同时继承自 Date.prototype 和 Object.prototype。 3）查询或设置属性前面有提到过，可以通过点 . 或方括号 [] 运算符来获取属性的值。对于点 . 来说，左侧应当是一个对象，右侧必须是一个以属性名称命名的简单标识符。对于方括号来说 [] ，方括号内必须是一个计算结果为字符串的表达式，这个字符串就是属性的名称。例如： 1234567// 推荐写法console.log(person.name); // &quot;stone&quot;console.log(person.age); // &quot;28&quot;// 也可以写成console.log(person[&quot;name&quot;]); // stoneconsole.log(person[&quot;age&quot;]); // 28 和获取属性的值写法一样，通过点和方括号也可以创建属性或给属性赋值，但需要将它们放在赋值表达式的左侧。例如： 123456789// 推荐写法person.name = &quot;sophie&quot;; // 赋值person.age = 30; // 赋值person.weight = 38; // 创建// 也可以写成person[&quot;name&quot;] = &quot;sophie&quot;; // 赋值person[&quot;age&quot;] = 30; // 赋值person[&quot;weight&quot;] = 38; // 创建 当使用方括号时，方括号内的表达式必须返回字符串。更严格地讲，表达式必须返回字符串或返回一个可以转换为字符串的值。 查看一个对象本身的所有属性，可以使用Object.keys方法。 1234567var obj = &#123; key1: 1, key2: 2&#125;;Object.keys(obj);// [&#x27;key1&#x27;, &#x27;key2&#x27;] 4）属性的访问错误查询一个不存在的属性并不会报错，如果在对象 o 自身的属性或继承的属性中均未找到属性 x，属性访问表达式 o.x 返回 undefined。例如： 12var person = &#123;&#125;;person.wife; // undefined 但是，如果对象不存在，那么试图查询这个不存在的对象的属性就会报错。null 和 undefined 值都没有属性，因此查询这些值的属性会报错。例如： 12var person = &#123;&#125;;person.wife.name; // Uncaught TypeError: Cannot read property &#x27;name&#x27; of undefined. 除非确定 person 和 person.wife 都是对象，否则不能这样写表达式 person.wife.name，因为会报「未捕获的错误类型」，下面提供了两种避免出错的方法： 123456789// 冗余但易懂的写法var name;if (person) &#123; if (person.wife) name = person.wife.name;&#125;// 简练又常用的写法（推荐写法）var name = person &amp;&amp; person.wife &amp;&amp; person.wife.name; 5）删除属性delete操作符用于从对象中移除属性。它唯一的操作数应该是一个属性访问表达式。 123456var obj = &#123; p: 1 &#125;;Object.keys(obj) // [&quot;p&quot;]delete obj.p // trueobj.p // undefinedObject.keys(obj) // [] 上面代码中，delete命令删除对象obj的p属性。删除后，再读取p属性就会返回undefined，而且Object.keys方法的返回值也不再包括该属性。 注意，删除一个不存在的属性，delete不报错，而且返回true。 12var obj = &#123;&#125;;delete obj.p // true 上面代码中，对象obj并没有p属性，但是delete命令照样返回true。因此，不能根据delete命令的结果，认定某个属性是存在的。 另外，需要注意的是，delete命令只能删除对象本身的属性，无法删除继承的属性。 123var obj = &#123;&#125;;delete obj.toString // trueobj.toString // function toString() &#123; [native code] &#125; 上面代码中，toString是对象obj继承的属性，虽然delete命令返回true，但该属性并没有被删除，依然存在。这个例子还说明，即使delete返回true，该属性依然可能读取到值。 6）检测属性JavaScript 对象可以看做属性的集合，我们经常会检测集合中成员的所属关系（判断某个属性是否存在于某个对象中）。可以通过 in 运算符、hasOwnPreperty() 和 propertyIsEnumerable() 来完成这个工作，甚至仅通过属性查询也可以做到这一点。 in 运算符的左侧是属性名（字符串），右侧是对象。如果对象的自有属性或继承属性中包含这个属性则返回 true。例如： 1234var o = &#123; x: 1 &#125;console.log(&quot;x&quot; in o); // true，x是o的属性console.log(&quot;y&quot; in o); // false，y不是o的属性console.log(&quot;toString&quot; in o); // true，toString是继承属性 对象的 hasOwnProperty() 方法用来检测给定的名字是否是对象的自有属性。对于继承属性它将返回 false。例如： 1234var o = &#123; x: 1 &#125;console.log(o.hasOwnProperty(&quot;x&quot;)); // true，x是o的自有属性console.log(o.hasOwnProperty(&quot;y&quot;)); // false，y不是o的属性console.log(o.hasOwnProperty(&quot;toString&quot;)); // false，toString是继承属性 propertyIsEnumerable() 是 hasOwnProperty() 的增强版，只有检测到是自有属性且这个属性的可枚举性（enumerable attribute）为 true 时它才返回 true。某些内置属性是不可枚举的。通常由 JavaScript 代码创建的属性都是可枚举的，除非在 ECMAScript 5 中使用一个特殊的方法来改变属性的可枚举性。例如： 12345var o = inherit(&#123; y: 2 &#125;);o.x = 1;o.propertyIsEnumerable(&quot;x&quot;); // true:，x是o的自有属性，可枚举o.propertyIsEnumerable(&quot;y&quot;); // false，y是继承属性Object.prototype.propertyIsEnumerable(&quot;toString&quot;); // false，不可枚举 除了使用 in 运算符之外，另一种更简便的方法是使用 !== 判断一个属性是否是 undefined。例如： 1234var o = &#123; x: 1 &#125;console.log(o.x !== undefined); // true，x是o的属性console.log(o.y !== undefined); // false，y不是o的属性console.log(o.toString !== undefined); // true，toString是继承属性 然而有一种场景只能使用 in 运算符而不能使用上述属性访问的方式。in 可以区分不存在的属性和存在但值为 undefined 的属性。例如： 1234567var o = &#123; x: undefined &#125; // 属性被显式赋值为undefinedconsole.log(o.x !== undefined); // false，属性存在，但值为undefinedconsole.log(o.y !== undefined); // false，属性不存在console.log(&quot;x&quot; in o); // true，属性存在console.log(&quot;y&quot; in o); // false，属性不存在console.log(delete o.x); // true，删除了属性xconsole.log(&quot;x&quot; in o); // false，属性不再存在 7）枚举属性除了检测对象的属性是否存在，我们还会经常遍历对象的属性。通常使用 for-in 循环遍历，ECMAScript 5 提供了两个更好用的替代方案。 for-in 循环可以在循环体中遍历对象中所有可枚举的属性（包括自有属性和继承的属性），把属性名称赋值给循环变量。对象继承的内置方法不可枚举的，但在代码中给对象添加的属性都是可枚举的。例如： 123456789101112var obj = &#123;a: 1, b: 2, c: 3&#125;;for (var i in obj) &#123; console.log(&#x27;键名：&#x27;, i); console.log(&#x27;键值：&#x27;, obj[i]);&#125;// 键名： a// 键值： 1// 键名： b// 键值： 2// 键名： c// 键值： 3 for...in循环有两个使用注意点。 它遍历的是对象所有可遍历（enumerable）的属性，会跳过不可遍历的属性。 它不仅遍历对象自身的属性，还遍历继承的属性。 举例来说，对象都继承了toString属性，但是for...in循环不会遍历到这个属性。 12345678var obj = &#123;&#125;;// toString 属性是存在的obj.toString // toString() &#123; [native code] &#125;for (var p in obj) &#123; console.log(p);&#125; // 没有任何输出 上面代码中，对象obj继承了toString属性，该属性不会被for...in循环遍历到，因为它默认是“不可遍历”的。关于对象属性 的可遍历性，参见《标准库》章节中 Object 一章的介绍。 如果继承的属性是可遍历的，那么就会被for...in循环遍历到。但是，一般情况下，都是只想遍历对象自身的属性，所以使 用for...in的时候，应该结合使用hasOwnProperty方法，在循环内部判断一下，某个属性是否为对象自身的属性。 12345678var person = &#123; name: &#x27;老张&#x27; &#125;;for (var key in person) &#123; if (person.hasOwnProperty(key)) &#123; console.log(key); &#125;&#125;// name 8）属性的 getter 和 setter我们知道，对象属性是由名字、值和一组特性（attribute）构成的。在 ECMAScript 5 中，属性值可以用一个或两个方法替代，这两个方法就是 getter 和 setter。由 getter 和 setter 定义的属性称做「存取器属性（accessor property）」，它不同于「数据属性（data property）」，数据属性只有一个简单的值。 当程序查询存取器属性的值时，JavaScript 调用 getter 方法。这个方法的返回值就是属性存取表达式的值。当程序设置一个存取器属性的值时，JavaScript 调用 setter 方法，将赋值表达式右侧的值当做参数传入 setter。从某种意义上讲，这个方法负责「设置」属性值。可以忽略 setter 方法的返回值。 和数据属性不同，存取器属性不具有可写性（writable attribute）。如果属性同时具有 getter 和 setter 方法，那么它是一个读&#x2F;写属性。如果它只有 getter 方法，那么它是一个只读属性。如果它只有 setter 方法，那么它是一个只写属性，读取只写属性总是返回 undefined。定义存取器属性最简单的方法是使用对象直接量语法的一种扩展写法。例如： 12345678var o = &#123; // 普通的数据属性 data_prop: value, // 存取器属性都是成对定义的函数 get accessor_prop() &#123; /*这里是函数体 */ &#125;, set accessor_prop(value) &#123; /* 这里是函数体*/ &#125;&#125;; 存取器属性定义为一个或两个和属性同名的函数，这个函数定义没有使用 function 关键字，而是使用 get 或 set。注意，这里没有使用冒号将属性名和函数体分隔开，但在函数体的结束和下一个方法或数据属性之间有逗号分隔。 9）序列化对象（JSON）对象序列化（serialization）是指将对象的状态转换为字符串，也可将字符串还原为对象。ECMAScript 5 提供了内置函数 JSON.stringify() 和 JSON.parse() 用来序列化和还原 JavaScript 对象。这些方法都使用 JSON 作为数据交换格式，JSON 的全称是「JavaScript 对象表示法（JavaScript Object Notation）」，它的语法和 JavaScript 对象与数组直接量的语法非常相近。例如： 123o = &#123;x:1, y:&#123;z:[false,null,&quot;&quot;]&#125;&#125;; // 定义一个对象s = JSON.stringify(o); // s是 &#x27;&#123;&quot;x&quot;:1,&quot;y&quot;:&#123;&quot;z&quot;:[false,null,&quot;&quot;]&#125;&#125;&#x27;p = JSON.parse(s); // p是o的深拷贝 ECMAScript 5 中的这些函数的本地实现和 https://github.com/douglascrockford/JSON-js 中的公共域 ECMAScript 3 版本的实现非常类似，或者说完全一样，因此可以通过引入 json2.js 模块在 ECMAScript 3 的环境中使用 ECMAScript 5 中的这些函数。 JSON 的语法是 JavaScript 语法的子集，它并不能表示 JavaScript 里的所有值。它支持对象、数组、字符串、无穷大数字、true、false 和 null，可以序列化和还原它们。NaN、Infinity 和 -Infinity 序列化的结果是 null，日期对象序列化的结果是 ISO 格式的日期字符串（参照 Date.toJSON() 函数），但 JSON.parse() 依然保留它们的字符串形态，而不会将它们还原为原始日期对象。函数、RegExp、Error 对象和 undefined 值不能序列化和还原。JSON.stringify() 只能序列化对象可枚举的自有属性。对于一个不能序列化的属性来说，在序列化后的输出字符串中会将这个属性省略掉。JSON.stringify() 和 JSON.parse() 都可以接收第二个可选参数，通过传入需要序列化或还原的属性列表来定制自定义的序列化或还原操作。","categories":[{"name":"javascript","slug":"javascript","permalink":"http://example.com/categories/javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://example.com/tags/javascript/"}]},{"title":"javascript数组","slug":"javascript数组","date":"2017-05-14T03:24:06.000Z","updated":"2022-05-26T11:37:43.526Z","comments":true,"path":"2017/05/14/javascript数组/","link":"","permalink":"http://example.com/2017/05/14/javascript%E6%95%B0%E7%BB%84/","excerpt":"","text":"数组数组是值的有序集合。每个值叫做一个元素，而每个元素在数组中有一个位置，以数字表示，称为索引。 JavaScript 数组是无类型的，数组元素可以是任意类型，并且同一个数组中的不同元素也可能有不同的类型。数组的元素甚至也可能是对象或其他数组。 JavaScript 数组是动态的，根据需要它们会增长或缩减，并且在创建数组时无须声明一个固定的大小或者在数组大小变化时无须重新分配空间。 JavaScript 数组可能是稀疏的，数组元素的索引不一定要连续的，它们之间可以有空缺。每个 JavaScript 数组都有一个 length 属性。针对非稀疏数组，该属性就是数组元素的个数。针对稀疏数组，length 比所有元素的索引要大。 JavaScript 数组是 JavaScript 对象的特殊形式，数组索引实际上和碰巧是整数的属性名差不多。通常，数组的实现是经过优化的，用数字索引来访问数组元素一般来说比访问常规的对象属性要快很多。 数组继承自 Array.prototype 中的属性，它定义了一套丰富的数组操作方法。 1）创建数组1）数组字面量 12345678910var empty = []; // 没有元素的数组var primes = [2, 3, 5, 7, 11]; // 有5个数值的数组var misc = [1.1, true, &quot;a&quot;]; // 3个不同类型的元素// 数组直接量中的值不一定要是常量，可以是任意的表达式var base = 1024;var table = [base, base+1, base+2, base+3];// 也可以包含对象直接量或其他数组直接量var b = [[1, &#123;x:1, y:2&#125;], [2, &#123;x:3, y:4&#125;]]; 注意，不要忽略数组字面量的最后一个元素，仅以逗号结尾。下面几个案例，在不同的浏览器下，可能会被识别成2个元素，也有可能识别成3个元素，而造成程序bug。例如： 123var nums = [,,,]; // 不好的写法var names = [&quot;stone&quot;,,]; // 不好的写法var colors = [&quot;red&quot;,&quot;green&quot;,]; // 不好的写法 2）通过new Array()创建 12345678// 调用时没有参数var a = new Array();// 调用时有一个数值参数，它指定长度var a = new Array(10); // 显式指定多个数组元素或者数组的一个非数值元素var a = new Array(5, 4, 3, 2, 1, &quot;testing&quot;); 2）数组的读写使用 [] 操作符来访问数组中的一个元素。数组的引用位于方括号的左边。方括号中是一个返回非负整数值的任意表达式。使用该语法既可以读又可以写数组的一个元素。例如： 1234567var a = [&quot;world&quot;]; // 从一个元素的数组开始var value = a[0]; // 读第0个元素a[1] = 3.14; // 写第1个元素var i = 2; a[i] = 3; // 写第2个元素a[i + 1] = &quot;hello&quot;; // 写第3个元素a[a[i]] = a[0]; // 读第0个和第2个元素，写第3个元素 请记住，数组是对象的特殊形式，可以为其创建任意名字的属性。但如果使用的属性是数组的索引，数组的特殊行为就是将根据需要更新它们的length属性值。 注意，可以使用负数或非整数来索引数组。这种情况下，数值转换为字符串，字符串作为属性名来用。既然名字不是非负整数，它就只能当做常规的对象属性，而非数组的索引。同样，如果凑巧使用了是非负整数的字符串，它就当做数组索引，而非对象属性。当使用的一个浮点数和一个整数相等时情况也是一样的。例如： 123a[-1.23] = true; // 这将创建一个名为&quot;-1.23&quot;的属性a[&quot;1000&quot;] = 0; // 这是数组的第1001个元素a[1.000] // 和 a[1] 相等 事实上数组索引仅仅是对象属性名的一种特殊类型，这意味着 JavaScript 数组没有「越界」错误的概念。当试图查询任何对象中不存在的属性时，不会报错，只会得到 undefined 值。 3）稀疏数组稀疏数组就是包含从0开始的不连续索引的数组。通常，数组的 length 属性值代表数组中元素的个数。如果数组是稀疏的，length 属性值大于元素的个数。可以用 Array() 构造函数或简单地指定数组的索引值大于当前的数组长度来创建稀疏数组。 123a = new Array(5); // 数组没有元素，但是 a.length = 5a = []; // 创建一个空数组，a.length = 0a[1000] = 0; // 添加一个元素，a.length 被自动更新为1001 足够稀疏的数组通常在实现上比稠密的数组更慢、内存利用率更高，在这样的数组中查找元素的时间与常规对象属性的查找时间一样长。 需要注意的是，当省略数组直接量中的值时（使用连续的逗号，比如 [1,,3] ），这时所得到的数组也是稀疏数组，省略掉的值是不存在的： 1234var a1 = [,&#x27;1&#x27;,&#x27;2&#x27;]; // 此数组长度是3 var a2 = [undefined]; // 此数组包含一个值为 undefined 的元素 console.log(0 in a1); // false，a1 在索引0处没有元素console.log(0 in a2); // true，a2 在索引0处有一个值为 undefined 的元素 了解稀疏数组是了解 JavaScript 数组的真实本质的一部分。尽管如此，实际上你所碰到的绝大多数 JavaScript 数组不是稀疏数组。并且，如果你确实碰到了稀疏数组，你的代码很可能像对待非稀疏数组一样来对待它们，只不过它们包含一些 undefined 值。 4）数组的长度每个数组有一个 length 属性，就是这个属性使其区别于常规的 JavaScript 对象。针对稠密（也就是非稀疏）数组，length 属性值代表数组中元素的个数。其值比数组中最大的索引大1。例如： 12[].length // 0，数组没有元素[&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;].length // 3，最大的索引为2，length 为3 当数组是稀疏的时，length 属性值大于元素的个数。而且关于此我们可以说的一切也就是数组长度保证大于它每个元素的索引值。或者，换一种说法，在数组中（无论稀疏与否）肯定找不到一个元素的索引值大于或等于它的长度。为了维持此规则不变化，数组有两个特殊的行为。 第一个如同上面的描述：如果为一个数组元素赋值，它的索引 i 大于或等于现有数组的长度时，length 属性的值将设置为 i+1。 第二个特殊的行为就是设置 length 属性为一个小于当前长度的非负整数 n 时，当前数组中那些索引值大于或等于 n 的元素将从中删除。例如： 1234a = [1,2,3,4,5]; // 从5个元素的数组开始a.length = 3; // 现在 a 为[1,2,3]a.length = 0; // 删除所有的元素。a 为[ ]a.length = 5; // 长度为5，但是没有元素，就像 new Array(5) 还可以将数组的 length 属性值设置为大于其当前的长度。实际上这不会向数组中添加新的元素，它只是在数组尾部创建一个空的区域。 在 ECMAScript 5 中，可以用 Object.defineProperty() 让数组的 length 属性变成只读的。例如： 123a = [1,2,3]; // 从3个元素的数组开始Object.defineProperty(a, &quot;length&quot;, &#123;writable: false&#125;); // 让 length 属性只读a.length = 0; // a 不会改变 5）添加或删除数组元素push():向数组末尾添加一个或多个元素 123let a = [];a.push(&#x27;one&#x27;);a.push(&#x27;two&#x27;,&#x27;three&#x27;) pop():删除数组最后一个元素并返回该元素。 12let a = [&#x27;one&#x27;,&#x27;two&#x27;,&#x27;three&#x27;];a.pop(); shift():删除并返回数组的第一个元素 12let a = [&#x27;one&#x27;,&#x27;two&#x27;,&#x27;three&#x27;];a.shift(); unshift():想数组首位添加一个元素 123let a = [&#x27;one&#x27;,&#x27;two&#x27;,&#x27;three&#x27;];a.unshift(&#x27;four&#x27;);a.unshift(&#x27;five&#x27;,&#x27;six&#x27;); splice(index,num): 从下标index位置开始，删除num个元素 12let color = [&#x27;red&#x27;,&#x27;yellow&#x27;,&#x27;green&#x27;,&#x27;pink&#x27;];let b = color.splice(1,2);//从下标1的位置，删除两项，并将调用splice放的返回值存放在变量b中 arr.splice(index,0,val1,val2..):在下标index位置，添加多个元素 12let color = [&#x27;red&#x27;,&#x27;yellow&#x27;,&#x27;green&#x27;,&#x27;pink&#x27;];console.log(color.splice(1,0,&#x27;#fff&#x27;,&#x27;#000&#x27;)) arr.splice(index,num,val1,val2…):先删除后添加; 从index 位置开始，先删除num个元素，再添加多个新元素； 12let color = [&#x27;red&#x27;,&#x27;yellow&#x27;,&#x27;green&#x27;,&#x27;pink&#x27;];let result = color.splice(2,2,&#x27;black&#x27;,&#x27;white&#x27;) 6）数组迭代使用 for 循环是遍历数组元素最常见的方法。例如： 123456var keys = Object.keys(o); // 获得 o 对象属性名组成的数组var values = [] // 在数组中存储匹配属性的值for(var i = 0; i &lt; keys.length; i++) &#123; // 对于数组中每个索引 var key = keys[i]; // 获得索引处的键值 values[i] = o[key]; // 在 values 数组中保存属性值&#125; 在嵌套循环或其他性能非常重要的上下文中，可以看到这种基本的数组遍历需要优化，数组的长度应该只查询一次而非每次循环都要查询。例如： 123for(var i = 0, len = keys.length; i &lt; len; i++) &#123; // 循环体仍然不变&#125; 这些例子假设数组是稠密的，并且所有的元素都是合法数据。否则，使用数组元素之前应该先检测它们。例如： 123456for(var i = 0; i &lt; a.length; i++) &#123; if (!a[i]) continue; // 跳过 null、undefined 和不存在的元素 if (!(i in a)) continue ; // 跳过不存在的元素 if (a[i] === undefined) continue; // 跳过 undefined 和不存在的元素 // 循环体&#125; 还可以使用 for-in 循环处理稀疏数组。循环每次将一个可枚举的属性名（包括数组索引）赋值给循环变量，不存在的索引将不会遍历到。例如： 1234for(var index in sparseArray) &#123; var value = sparseArray[index]; // 此处可以使用索引和值做一些事情&#125; 但由于 for-in 循环能够枚举继承的属性名，如添加到 Array.prototype 中的方法。基于这个原因，在数组上不应该使用 for-in 循环，除非使用额外的检测方法来过滤不想要的属性。例如： 1234567for(var i in a) &#123; // 跳过继承的属性 if (!a.hasOwnProperty(i)) continue; // 跳过不是非负整数的 i if (String(Math.floor(Math.abs(Number(i)))) !== i) continue;&#125; JavaScript 规范允许 for-in 循环以不同的顺序遍历对象的属性。通常数组元素的遍历实现是升序的，但不能保证一定是这样的。如果数组同时拥有对象属性和数组元素，返回的属性名很可能是按照创建的顺序而非数值的大小顺序。如何处理这个问题的实现，各个浏览器都不相同，如果算法依赖于遍历的顺序，那么最好不要使用 for-in 而用常规的 for 循环。 forEach():迭代数组的每个元素，并对每个元素都调用一次指定的函数。 12345678let data = [1,2,3,4,5,6,7],sum = 0;data.forEach(function(item)&#123; sum +=item;&#125;)或data.forEach(item=&gt;&#123; sum +=item;&#125;) map():把调用它的数组的每个元素分别传给指定的函数，返回这个函数的返回值构成的数组。 123let a = [1,2,3];let result = a.map(x =&gt; x*x)console.log(result) filter():返回一个数组，该数组包含调用它的数组的子数组。 123let a = [1,2,3,4,5,6,7,8];let result = a.filter(x=&gt;x&lt;3)let res = a.filter((x,i) =&gt; i%2===0); **some()**：类似于数学上的“存在”量词，只要数组元素中有一个让断言函数返回true它就返回true,但必须数组的所有元素对断言函数都返回false才返回false. 123let a = [1,2,3,4,5]a.some(x=&gt;x%2===0);a.some(isNaN) every():与数学上的全称量词类似，它在且只有断言函数对数组的所有元素都返回true时才返回true 123let a = [1,2,3,4,5];a.every(x=&gt;x&lt;10)a.every(x=&gt; x%2 ===0); 7）数组检测给定一个未知的对象，判定它是否为数组通常非常有用。在 ECMAScript 5 中，可以使用 Array.isArray() 函数来做这件事情。例如： 12Array.isArray([]) // trueArray.isArray(&#123;&#125;) // false 但是，在 ECMAScript 5 以前，要区分数组和非数组对象很困难。typeof 运算符对数组返回 &quot;object&quot;（并且对于除了函数以外的所有对象都是如此）。instanceof 操作符也只能用于简单的情形。例如： 12[] instanceof Array // true(&#123;&#125;) instanceof Array // false 使用 instanceof 的问题是在 Web 浏览器中有可能有多个窗体存在。每个窗体都有自己的 JavaScript 环境，有自己的全局对象。并且，每个全局对象有自己的一组构造函数。因此一个窗体中的对象将不可能是另外窗体中的构造函数的实例。窗体之间的混淆不常发生，但这个问题足已证明 instanceof 操作符不能视为一个可靠的数组检测方法。 解决方案是检查对象的类属性，对数组而言该属性的值总是 &quot;Array&quot;，因此在 ECMAScript 3 中 isArray() 函数的代码可以这样书写。例如： 123var isArray = Array.isArray || function(o) &#123; return typeof o === &quot;object&quot; &amp;&amp; Object.prototype.toString.call(o) === &quot;[object Array]&quot;;&#125;; 8）反转数组reverse():数组反转 12let a = [1,2,3,4,5]a.reverse(); 9）数组排序sort():数组的排序语法：arr.sort(function(a,b){return a-b}); 1234567891011121314升序var arr = [34,7,23,9,5];arr.sort(function(a,b)&#123; return a-b;&#125;)降序var arr = [34,7,23,9,5];arr.sort(function(a,b)&#123; return b-a;&#125;)不传参：按照ASCII码排序var arr = [34,7,23,9,5];arr.sort();console.log(arr); 10）数组合并**concat()**：将多个数组内容拿出来，合并成一个新数组； 语法：arr.concat(arr,arr1,arr2,….) 123var arr = [&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;,&#x27;d&#x27;];var arr2 = [1,2,3];console.log(arr.concat(arr2)); 11）数组的截取slice():返回截取的内容 slice的截取时，包含开始位置，不包含截取位置； arr.slice(start,end);&#x2F;&#x2F;从开始start位置截取到end位置，不包含结束位置 arr.slice(start);&#x2F;&#x2F;从开始位置一直截取最后 arr.slice();&#x2F;&#x2F;不传参：表示，截取整个数组； slice();支持负值； slice()不会改变原数组 123456789101112传两个参数：var color = [&#x27;pink&#x27;,&#x27;red&#x27;,&#x27;yellow&#x27;,&#x27;blue&#x27;,&#x27;green&#x27;];console.log(color.slice(1,3))//从下标1开始截取到下标3，不包含下标3传一个参数var color = [&#x27;pink&#x27;,&#x27;red&#x27;,&#x27;yellow&#x27;,&#x27;blue&#x27;,&#x27;green&#x27;];var a = color.slice(1);//参数1表示从下标1开始一直截取到最后不传参var color = [&#x27;pink&#x27;,&#x27;red&#x27;,&#x27;yellow&#x27;,&#x27;blue&#x27;,&#x27;green&#x27;];var b = color.slice();//不传参，表示全部截取，将截取结果赋值给b参数为负值var color = [&#x27;pink&#x27;,&#x27;red&#x27;,&#x27;yellow&#x27;,&#x27;blue&#x27;,&#x27;green&#x27;];var c = color.slice(-3,4);//坐标= 负值+数组长度 -3+5 = 2(2,4) 12）数组索引indexOf():从数组前向后中搜索指定的值并返回第一个找到的元素的索引，如果没找到则返回-1. 123var color = [&#x27;pink&#x27;,&#x27;red&#x27;,&#x27;yellow&#x27;,&#x27;blue&#x27;,&#x27;green&#x27;];console.log(color.indexOf(&#x27;red&#x27;)) lastIndexOf():从数组后向前中搜索指定的值并返回第一个找到的元素的索引，如果没找到则返回-1. 12var color = [&#x27;pink&#x27;,&#x27;red&#x27;,&#x27;yellow&#x27;,&#x27;blue&#x27;,&#x27;green&#x27;];console.log(color.lastIndexOf(&#x27;red&#x27;)) 13）数组转字符串join():将数组的每一项通过连接符，拼接为一个新字符串； 12var color = [&#x27;pink&#x27;,&#x27;red&#x27;,&#x27;yellow&#x27;,&#x27;blue&#x27;,&#x27;green&#x27;];console.log(color.join(&#x27;,&#x27;))","categories":[{"name":"javascript","slug":"javascript","permalink":"http://example.com/categories/javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://example.com/tags/javascript/"}]},{"title":"javascript字符串","slug":"javascript字符串","date":"2017-05-05T03:19:08.000Z","updated":"2022-05-26T11:37:06.331Z","comments":true,"path":"2017/05/05/javascript字符串/","link":"","permalink":"http://example.com/2017/05/05/javascript%E5%AD%97%E7%AC%A6%E4%B8%B2/","excerpt":"","text":"String对象字符串的拼接可以使用“+”操作符 1let msg = &quot;Hello&quot; + &quot;World&quot;; 可以使用标准的全等&#x3D;&#x3D;&#x3D;和不全等!&#x3D;&#x3D;操作符进行字符串比较。 字符串也可以使用&lt;、&lt;&#x3D;、&gt;和&gt;&#x3D;操作符来比较，字符串比较是通过比较16位值完成的。 1）length:字符串长度12var s = &quot;hello world&quot;;console.log(s.length) 2）截取字符串1234var s = &quot;Hello World&quot;;s.substring(1,4);//取第2-4个字符s.slice(1,4);//同上s.slice(-3);最后3个字符 3）拆分字符串12var s = &quot;Hello,World&quot;;s.split(&quot;,&quot;);//[&quot;Hello&quot;,&quot;World&quot;]从定界符处拆开 4）搜索字符串1234var s = &quot;Hello World&quot;;s.indexOf(&quot;l&quot;); //第一个字母l的位置s.indexOf(&quot;l&quot;,3);//位置3后面第一个&quot;l&quot;的位置s.indexOf(&quot;zz&quot;);// -1,s并不包含子串&quot;zz&quot; 5）从后向前搜索字符串。12var s = &quot;Hello World&quot;;s.lastIndexOf(&#x27;l&#x27;)// 9 6）字符串已那些字符开头或结尾1234var s = &quot;Hello World&quot;;s.startWith(&quot;Hell&quot;);=&gt;trues.endWith(&quot;!&quot;)=&gt;falses.includes(&quot;or&quot;) ;=&gt;true 7）替换与正则表达式匹配的子串12var s = &quot;Hello World&quot;;s.replace(&quot;llo&quot;,&#x27;ya&#x27;) 8）把字符串转换为小写123var s = &quot;HELLO WORLD&quot;;s.toLowerCase();s.toLocaleLowerCase() 9）把字符串转换为大写123var s = &quot;hello world&quot;;s.toUpperCase();s.toLocaleUpperCase() 10）返回在指定位置的字符12var s = &quot;Hello World&quot;;s.charAt(0) 11）从起始索引号提取字符串中指定数目的字符12var str=&quot;Hello world!&quot;document.write(str.substr(3)) =&gt;lo world! 12）去除空格1234var s =&quot; Hello World &quot;;s.trim();//删除两侧空格s.trimStart();//删除左侧空格s.trimEnd();//删除右侧空格 13) 字符串填充123var s =&quot;Hello World&quot;;s.padStart(3,&#x27;*&#x27;);//左侧填充三个*s.padEnd(3,&#x27;*&#x27;);//右侧填充三个*","categories":[{"name":"javascript","slug":"javascript","permalink":"http://example.com/categories/javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://example.com/tags/javascript/"}]},{"title":"javascript语句","slug":"javascript语句","date":"2017-05-03T01:34:16.000Z","updated":"2022-05-26T11:37:15.367Z","comments":true,"path":"2017/05/03/javascript语句/","link":"","permalink":"http://example.com/2017/05/03/javascript%E8%AF%AD%E5%8F%A5/","excerpt":"","text":"语句表达式在 JavaScript 中是短语，那么语句就是整句命令。表达式用来计算出一个值，语句用来执行以使某件事发生。从本质上看，语句定义了 JavaScript 中的主要语法，语句通常使用一或多个关键字来完成给定任务。语句可以很简单，例如通知函数退出；也可以比较复杂，例如指定重复执行某个命令的次数。下表列出了 JavaScript 大部分语句的语法和用途： 语句 语法 用途 break break [label]; 退出最内层循环或者退出 switch 语句，又或者退出 label 指定的语句 case case expression: 在 switch 语句中标记一条语句 continue continue [label]; 重新开始最内层的循环或重新开始 label 指定的循环 debugger debugger; 断点器调试 default default; 在 switch 中标记默认的语句 do-while do statement while(expression); while 循环的一种替代形式 empty ; 什么都不做 for for(init;expr;incr) statement 简写的循环结构 for-in for(var in object) statement 遍历一个对象的属性 function function name([param[],...])&#123;statement&#125; 声明一个函数 if-else if (expression) statement1[else statement2] 执行 statement1 或者 statement2 label label:statement 给 statement 指定一个名字 label return return [expression]; 从函数返回一个值 switch switch(expression)&#123;statement&#125; 用 case 或者 default 语句标记的多分支语句 throw throw expression; 抛出异常 try try &#123;statement&#125;[catch &#123;handler statement&#125;][finally &#123;cleaup statement&#125;] 捕获异常 use strict &quot;use strict&quot; 对脚本和函数应用严格模式 var var name=[=expr][,...]; 声明并初始化一个或多个变量 while while(expression) statement 基本的循环结构 with with(object) statement 扩展作用域链 1)条件语句if-else 语句大多数编程语言中最为常用的一个语句就是 if-else 语句。以下是 if-else 语句的语法： 1if (condition) statement1 [else statement2] 其中的 condition 可以是任意表达式；而且对这个表达式求值的结果不一定是布尔值。JavaScript 会自动调用 Boolean() 转换函数将这个表达式的结果转换为一个布尔值。如果对 condition 求值的结果是 true，则执行 statement1，如果对 condition 求值的结果是 false，则执行 statement2。而且这两个语句既可以是一行代码，也可以是一个代码块（以一对花括号括起来的多行代码）。请看下面的例子： 12345if (i &gt; 25) console.log(&quot;Greater than 25.&quot;); // 单行语句else &#123; console.log(&quot;Less than or equal to 25.&quot;); // 代码块中的语句&#125; 业界普遍推崇的最佳实践是始终使用代码块，即使要执行的只有一行代码。因为这样可以消除人们的误解，否则可能让人分不清在不同条件下要执行哪些语句。 switch 语句switch 语句与 if 语句的关系最为密切，而且也是在其他语言中普遍使用的一种流控制语句。JavaScript 中 switch 语句的语法与其他基于 C 的语言非常接近，如下所示： 1234567891011switch (expression) &#123; case value: statement break; case value: statement break; case value: statement break; case value: statement break; default: statement&#125; switch 语句中的每一种情形的含义是：“如果表达式等于这个值（value），则执行后面的语句（statement）”。而 break 关键字会导致代码执行流跳出 switch 语句。如果省略 break 关键字，就会导致执行完当前 case 后，继续执行下一个 case。最后的 default 关键字则用于在表达式不匹配前面任何一种情形的时候，也相当于一个 else 语句。从根本上讲，switch 语句就是为了让开发人员免于编写像下面这样的代码： 123456789if (i === 25)&#123; console.log(&quot;25&quot;);&#125; else if (i === 35) &#123; console.log(&quot;35&quot;);&#125; else if (i === 45) &#123; console.log(&quot;45&quot;);&#125; else &#123; console.log(&quot;Other&quot;);&#125; 而与此等价的switch语句如下所示： 12345678910111213switch (i) &#123; case 25: console.log(&quot;25&quot;); break; case 35: console.log(&quot;35&quot;); break; case 45: console.log(&quot;45&quot;); break; default: console.log(&quot;Other&quot;);&#125; 通过为每个case后面都添加一个break语句，就可以避免同时执行多个case代码的情况。假如确实需要混合几种情形，不要忘了在代码中添加注释，说明你是有意省略了break关键字。 虽然 JavaScript 中的 switch 语句借鉴自其他语言，但这个语句也有自己的特色。首先，可以在 switch 语句中使用任何数据类型（在很多其他语言中只能使用数值），无论是字符串，还是对象都没有问题。其次，每个 case 的值不一定是常量，可以是变量，甚至是表达式。请看下面这两个例子： 12345678910111213141516171819202122232425switch (&quot;hello world&quot;) &#123; case &quot;hello&quot; + &quot; world&quot;: console.log(&quot;Greeting was found.&quot;); break; case &quot;goodbye&quot;: console.log(&quot;Closing was found.&quot;); break; default: console.log(&quot;Unexpected message was found.&quot;);&#125;var num = 25;switch (true) &#123; case num &lt; 0: console.log(&quot;Less than 0.&quot;); break; case num &gt;= 0 &amp;&amp; num &lt;= 10: console.log(&quot;Between 0 and 10.&quot;); break; case num &gt; 10 &amp;&amp; num &lt;= 20: console.log(&quot;Between 10 and 20.&quot;); break; default: console.log(&quot;More than 20.&quot;);&#125; switch 语句首先计算 switch 关键字后的表达式，然后按照从上到下的顺序计算每个 case 后的表达式，直到执行到 case 的表达式的值与 switch 的表达式的值相等时为止。由于对每个 case 的匹配操作实际上是 === 恒等运算符比较，而不是 == 相等运算符比较，因此，表达式和 case 的匹配并不会做任何类型转换。 2）循环while 语句while 语句属于前测试循环语句，也就是说，在循环体内的代码被执行之前，就会对出口条件求值。因引，循环体内的代码有可能永远不会被执行。以下是 while 语句的语法： 1while(expression) statement 下面是一个示例： 1234var i = 0;while (i &lt; 10) &#123; i += 2;&#125; do-while 语句do-while 语句是一种后测试循环语句，即只有在循环体中的代码执行之后，才会测试出口条件。换句话说，在对条件表达式求值之前，循环体内的代码至少会被执行一次。以下是 do-while 语句的语法： 123do &#123; statement&#125; while (expression); 下面是一个示例： 1234var i = 0;do &#123; i += 2;&#125; while (i &lt; 10); for 语句for 语句也是一种前测试循环语句，但它具有在执行循环之前初始化变量和定义循环后要执行的代码的能力。以下是 for 语句的语法： 1for (初始化变量; 条件表达式; 操作表达式) 循环体 下面是一个示例： 1234var count = 10;for (var i = 0; i &lt; count; i++)&#123; console.log(i);&#125; 这个 for 循环语句与下面的 while 语句的功能相同： 123456var count = 10;var i = 0;while (i &lt; count)&#123; console.log(i); i++;&#125; 由于 JavaScript 中不存在块级作用域，因此在循环内部定义的变量也可以在外部访问到。例如： 12345var count = 10;for (var i = 0; i &lt; count; i++)&#123; console.log(i);&#125;console.log(i); // 10 此外，for 语句中的初始化表达式、控制表达式和循环后表达式都是可选的。将这两个表达式全部省略，就会创建一个无限循环，例如： 12345// 无限循环for (;;) &#123; doSomething();&#125; for-in 语句for-in 语句是一种精准的迭代语句，可以用来枚举对象的属性。以下是 for-in 语句的语法： 1for (property in object) statement 下面是一个示例： 123for (var propName in window) &#123; console.log(propName);&#125; 在这个例子中，我们使用 for-in 循环来显示了 BOM 中 window 对象的所有属性。每次执行循环时，都会将 window 对象中存在的一个属性名赋值给变量 propName。这个过程会一直持续到对象中的所有属性都被枚举一遍为止。与 for 语句类似，这里控制语句中的 var 操作符也不是必需的。但是，为了保证使用局部变量，我们推荐上面例子中的这种做法。 JavaScript 对象的属性没有顺序。因此，通过 for-in 循环输出的属性名的顺序是不可预测的。具体来讲，所有属性都会被返回一次，但返回的先后次序可能会因浏览器而异。 如果表示要迭代的对象的变量值为 null 或 undefined，for-in 语句会抛出错误。虽然 ECMAScript 5 更正了这一行为；对这种情况不再抛出错误，而只是不执行循环体。为了保证最大限度的兼容性，建议在使用 for-in 循环之前，先检测确认该对象的值不是 null 或 undefined。 3）跳转break 和 continue 语句break 和 continue 语句用于在循环中精确地控制代码的执行。其中，break 语句会立即退出循环，强制继续执行循环后面的语句。而 continue 语句虽然也是立即退出循环，但退出循环后会从循环的顶部继续执行。请看下面的例子： 12345678910var num = 0;for (var i=1; i &lt; 10; i++) &#123; if (i % 5 == 0) &#123; break; &#125; num++;&#125;console.log(num); // 4 这个例子中的 for 循环会将变量 i 由1递增至 10。在循环体内，有一个 if 语句检查 i 的值是否可以被 5 整除（使用求模运算符）。如果是，则执行 break 语句退出循环。另一方面，变量 num 从 0 开始，用于记录循环执行的次数。在执行 break 语句之后，结果显示 4。也就是说，在变量 i 等于 5 时，循环总共执行了 4 次；而 break 语句的执行，导致了循环在 num 再次递增之前就退出了。如果在这里把 break 替换为 continue 的话，则可以看到另一种结果： 12345678910var num = 0;for (var i=1; i &lt; 10; i++) &#123;if (i % 5 == 0) &#123; continue; &#125; num++;&#125;console.log(num); // 8 例子的结果显示 8，也就是循环总共执行了 8 次。当变量 i 等于 5 时，循环会在 num 再次递增之前退出，但接下来执行的是下一次循环，即i的值等于 6 的循环。于是，循环又继续执行，直到 i 等于 10 时自然结束。而 num 的最终值之所以是 8，是因为 continue 语句导致它少递增了一次。 break 和 continue 语句都可以与 label 语句联合使用，从而返回代码中特定的位置。这种联合使用的情况多发生在循环嵌套的情况下，如下面的例子所示： 12345678910111213var num = 0;outermost:for (var i = 0; i &lt; 10; i++) &#123; for (var j = 0; j &lt; 10; j++) &#123; if (i == 5 &amp;&amp; j == 5) &#123; break outermost; &#125; num++; &#125;&#125;console.log(num); // 55 在这个例子中，outermost 标签表示外部的 for 语句。如果每个循环正常执行 10 次，则 num++ 语句就会正常执行 100 次。换句话说，如果两个循环都自然结束，num 的值应该是 100。但内部循环中的 break 语句带了一个参数：要返回到的标签。添加这个标签的结果将导致 break 语句不仅会退出内部的 for 语句（即使用变量 j 的循环），而且也会退出外部的 for 语句（即使用变量 i 的循环）。为此，当变量 i 和 j 都等于 5 时， num的值正好是 55。同样，continue 语句也可以像这样与 label 语句联用，如下面的例子所示： 12345678910111213var num = 0;outermost:for (var i = 0; i &lt; 10; i++) &#123; for (var j = 0; j &lt; 10; j++) &#123; if (i == 5 &amp;&amp; j == 5) &#123; continue outermost; &#125; num++; &#125;&#125;console.log(num); // 95 在这种情况下，continue 语句会强制继续执行循环，退出内部循环，执行外部循环。当 j 是 5 时，continue 语句执行，而这也就意味着内部循环少执行了 5 次，因此 num 的结果是 95。 虽然联用 break、continue 和 label 语句能够执行复杂的操作，但如果使用过度，也会给调试带来麻烦。在此，我们建议如果使用 label 语句，一定要使用描述性的标签，同时不要嵌套过多的循环。 return 语句return 语句的作用是指定函数调用后的返回值。return 语句的语法如下： 1return [expression]; 下面是一个示例： 12function square(x) &#123; return x*x; &#125; // 一个包含 return 语句的函数square(2); // 调用结果为 4 return 语句只能在函数体内出现，如果不是的话会报语法错误。当执行到 return 语句的时候，函数终止执行，并返回 expression 的值给调用程序。如果没有 return 语句，则函数调用仅依次执行函数体内的每一条语句直到函数结束，最后返回调用程序。这种情况下，调用表达式的结果是 undefined。return 语句经常作为函数内的最后一条语句出现，但并不是说要一定放在函数最后。return 语句可以单独使用而不必带有 expression，这样的话函数也会向调用程序返回 undefined。 由于 JavaScript 可以自动插入分号，因此在 return 关键字和它后面的表达式之间不能有换行。 4）其他with 语句with 语句的作用是将代码的作用域设置到一个特定的对象中。with 语句的语法如下： 1with (expression) statement; 定义 with 语句的目的主要是为了简化多次编写同一个对象的工作，如下面的例子所示： 123var qs = location.search.substring(1);var hostName = location.hostname;var url = location.href; 上面几行代码都包含 location 对象。如果使用 with 语句，可以把上面的代码改写成如下所示： 12345with(location)&#123; var qs = search.substring(1); var hostName = hostname; var url = href;&#125; 在这个重写后的例子中，使用 with 语句关联了 location 对象。这意味着在 with 语句的代码块内部，每个变量首先被认为是一个局部变量，而如果在局部环境中找不到该变量的定义，就会查询 location 对象中是否有同名的属性。如果发现了同名属性，则以 location 对象属性的值作为变量的值。 由于大量使用 with 语句会导致性能下降，同时也会给调试代码造成困难，因此在开发大型应用程序时，不建议使用 with 语句。严格模式下不允许使用 with 语句，否则将视为语法错误。 代码块代码块将多个语句组合为一个复合语句。代码块其实就是一系列语句，可以放在任何期待一个语句的地方： 12345&#123; x = Math.PI cx = Math.cos(x) console.log(&quot;cos(n)= &quot; + cx)&#125; 注意：1)它没有以分号结尾。块中的单条语句都以分号结尾，但块本身没有。2）块中的代码相对于包含它们的花括号缩进","categories":[{"name":"javascript","slug":"javascript","permalink":"http://example.com/categories/javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://example.com/tags/javascript/"}]},{"title":"javascript表达式和操作符","slug":"javascript表达式和操作符","date":"2017-04-23T08:18:22.000Z","updated":"2022-05-26T11:40:01.357Z","comments":true,"path":"2017/04/23/javascript表达式和操作符/","link":"","permalink":"http://example.com/2017/04/23/javascript%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%92%8C%E6%93%8D%E4%BD%9C%E7%AC%A6/","excerpt":"","text":"表达式与操作符1）表达式表达式是由数字、运算符、数字分组符号（如括号）、自由变量和约束变量等以能求得数值的有意义排列方法所得的组合。JavaScript 表达式主要有以下几种形式： 原始表达式：常量、变量、保留字。 对象、数组初始化表达式：var obj=&#123;a:1,b:2&#125;;，var arr=[1,2,3];。 函数定义表达式：var fn=function()&#123;&#125;。 属性访问表达式：Math.abs。 调用表达式：alert(&#39;hello&#39;);。 对象创建表达式：new object();。 1）函数定义表达式函数定义表达式通常用关键字function,位于括号中的逗号分隔的0或多个标识符，以及一个位于花括号中的js代码块构成。 12345let square = function(x)&#123; return x*x;&#125;或function square(x)&#123; return x*x;&#125; 2）属性访问表达式属性访问表达式求值为对象属性或数组元素的值，其语法结构为 12expression.identifierexpression[identifier] 第一种属性访问语法是表达式后跟着一个句点和一个标识符。其中，表达式指定对象，标识符指定属性名。第二种属性访问语法是表达式后跟另一个位于方括号中的表达式。这第二个表达式指定属性名或数组元素的索引。 123456let o = &#123;x:1,y:&#123;z:3&#125;&#125;;let a = [o,4,[5,6]]o.x;o.y.za[1]a[0] 2）运算符JavaScript 中的运算符用于算术表达式、比较表达式、逻辑表达式、赋值表达式等。需要注意的是，大多数运算符都是由标点符号表示的，比如 + 和 =。而另外一些运算符则是由关键字表示的，比如 typeof 和 instanceof，关键字运算符和标点符号都是正规的运算符。 下表列出了 JavaScript 中所有的运算符，并按照运算符的优先级排序的，前面的运算符优先级要高于后面的运算符优先级，被空行分隔开来的运算符具有不同的优先级。标题为 A 的列表示运算符的结合性（Associativity），L 表示从左至右、R 表示从右至左，标题为 N 的列表示操作数的个数（Number）。 运算符 操作 A N ++ 前&#x2F;后增量 R 1 -- 前&#x2F;后增量 R 1 - 求反 R 1 + 转换为数字 R 1 ~ 按位求反 R 1 ! 逻辑非 R 1 delete 删除属性 R 1 typeof 检测类型 R 1 void 返回undefined R 1 * / % 乘，除，求模 L 2 + - 加，减 L 2 + 字符串连接 L 2 &lt;&lt; 左移位 L 2 &gt;&gt; 有符号右移 L 2 &gt;&gt;&gt; 无符号右移 L 2 &lt; &lt;= &gt; &gt;= 比较数字顺序 L 2 &lt; &lt;= &gt; &gt;= 比较字母顺序 L 2 instanceof 测试对象类 L 2 in 测试属性是否存在 L 2 == 判断相等 L 2 != 判断不等 L 2 === 判断恒等 L 2 !== 判断恒不等 L 2 &amp; 按位与 L 2 ^ 按位异或 L 2 ┃ 按位或 L 2 &amp;&amp; 逻辑与 L 2 ┃┃ 逻辑或 L 2 ?: 条件运算符 R 3 = 赋值 R 2 *= /= %= += -= &amp;= &lt;&lt;= &gt;&gt;= ^= ┃= &gt;&gt;&gt;= 运算且赋值 R 2 , 忽略第一个操作数， 返回第二个操作数 L 2 因为 | 是制表符，会导致格式混乱，所以表格中的 | 均以 ┃ 代替。 1）一元运算符（1）delete 运算符delete 运算符用来删除对象属性或者数组元素，如果删除成功或所删除的目标不存在，delete 将返回 true。然而，并不是所有的属性都可删除，一些内置核心和客户端属性是不能删除的，通过 var 语句声明的变量不能删除，通过 function 语句定义的函数也是不能删除的。例如： 1234567891011121314151617var o = &#123; x: 1, y: 2&#125;; // 定义一个对象console.log(delete o.x); // true，删除一个属性console.log(delete o.x); // true，什么都没做，x 在已上一步被删除console.log(&quot;x&quot; in o); // false，这个属性在对象中不再存在console.log(delete o.toString); // true，什么也没做，toString是继承来的console.log(delete 1); // true，无意义var a = [&quot;x&quot;,&quot;y&quot;,&quot;z&quot;]; // 定义一个数组console.log(2 in a); // true，下标为2的元素，在数组中存在console.log(delete a[2]); // true，删除下标为2的元素（最后一个数组元素）console.log(2 in a); // false，下标为2的元素，在数组中不再存在console.log(a.length); // 3，数组长度并不会因 delete 而改变console.log(a[2]); // undefined，下标为2的元素，位置被空了出来console.log(delete a); // false，通过 var 语句声明的变量不能删除function f(args)&#123;&#125; // 定义一个函数console.log(delete f); // false，通过 function 语句声明的函数不能删除 （2）void 运算符void 运算符可以应用于任何表类型的表达式，表达式会被执行，但计算结果会被忽略并返回 undefined。例如： 1234567void 0;void &quot;you are useless?&quot;;void false;void [];void /(useless)/ig;void function()&#123; console.log(&quot;you are so useless?&quot;); &#125;// always return undefined （3）typeof 运算符鉴于 JavaScript 是松散类型的，因此需要有一种手段来检测给定变量的数据类型，typeof 就是负责提供这方面信息的运算符。对一个值使用 typeof 运算符可能返回下列某个字符串： &quot;undefined&quot;，如果这个值未声明或已声明但未初始化。 &quot;boolean&quot;，如果这个值是布尔值。 &quot;string&quot;，如果这个值是字符串。 &quot;number&quot;，如果这个值是数值。 &quot;object&quot;，如果这个值是对象或 null。 &quot;function&quot;，如果这个值是函数。 下面是几个使用 typeof 运算符的例子： 1234var message = &quot;some string&quot;;console.log(typeof message); // &quot;string&quot;console.log(typeof(message)); // &quot;string&quot;console.log(typeof 95); // &quot;number&quot; 从以上例子可以看出，typeof 运算符既可以对变量使用，又可以对字面量使用。由于 typeof 是一个运算符而不是函数，因此例子中的圆括号尽管可以使用，但并不提倡。 typeof null 结果是 &quot;object&quot; 是历史遗留 Bug，在 ECMAScript 6 中，曾经有提案为历史平反, 将 typeof null 的值纠正为 &quot;null&quot;，但最后该提案被拒。理由是历史遗留代码太多，不如继续将错就错。 （4）++ -- 运算符++ -- 递增递减运算符借鉴自 C 语言，它们分前置型和后置型，作用是改变一个变量的值。例如： 12345var a = 5;console.log(a++); // 5console.log(++a); // 7console.log(a--); // 7console.log(--a); // 5 （5）+ - 运算符当 + - 作为一元运算符时，应用于数值，表示数值的正负。应用于非数值，先按 Number() 转型函数对这个值执行转换，再表示该值的正负。 （6）~ ! 运算符 ~ 按位非运算符，请参见下面「位运算符」。! 逻辑非运算符，请参见下面「逻辑运算符」。 2）乘性运算符JavaScript 定义了3个乘性运算符：乘法、除法和求模。这些运算符与 C 语言的相应运算符用途类似，只不过在操作数为非数值的情况下会执行自动的类型转换。如果参与乘法计算的某个操作数不是数值，后台会先使用 Number() 转型函数将其转换为数值。也就是说，空字符串将被当作 0，布尔值 true 将被当作 1。 （1）* 乘法运算符用于计算两个数值的乘积，在处理特殊值的情况下，乘法运算符遵循下列特殊的规则： 如果操作数都是数值，执行常规的乘法计算，即两个正数或两个负数相乘的结果还是正数，而如果只有一个操作数有符号，那么结果就是负数。如果乘积超过了 JavaScript 数值的表示范围，则返回 Infinity 或 -Infinity； 如果有一个操作数是 NaN，则结果是 NaN； 如果是 Infinity 与 0 相乘，则结果是 NaN； 如果是 Infinity 与非 0 数值相乘，则结果是 Infinity 或 -Infinity，取决于有符号操作数的符号； 如果是 Infinity 与 Infinity 相乘，则结果是 Infinity；如果有一个操作数不是数值，则在后台调用 Number()将其转换为数值，然后再应用上面的规则。 （2）/ 除法运算符用于计算两个数值的商，与乘法运算符类似，除法运算符对特殊的值也有特殊的处理规则。这些规则如下： 如果操作数都是数值，执行常规的除法计算，即两个正数或两个负数相除的结果还是正数，而如果只有一个操作数有符号，那么结果就是负数。如果商超过了 JavaScript 数值的表示范围，则返回 Infinity 或 -Infinity； 如果有一个操作数是 NaN，则结果是 NaN； 如果是 Infinity 被 Infinity 除，则结果是 NaN； 如果是零被零除，则结果是 NaN； 如果是非零的有限数被零除，则结果是 Infinity 或 -Infinity，取决于有符号操作数的符号； 如果是 Infinity 被任何非零数值除，则结果是 Infinity 或 -Infinity，取决于有符号操作数的符号； 如果有一个操作数不是数值，则在后台调用 Number() 将其转换为数值，然后再应用上面的规则。 （3）% 求模运算符用于计算两个数值的余数，与另外两个乘性运算符类似，求模运算符会遵循下列特殊规则来处理特殊的值： 如果操作数都是数值，执行常规的除法计算，返回除得的余数； 如果被除数是无穷大值而除数是有限大的数值，则结果是 NaN； 如果被除数是有限大的数值而除数是零，则结果是 NaN； 如果是 Infinity 被 Infinity 除，则结果是 NaN； 如果被除数是有限大的数值而除数是无穷大的数值，则结果是被除数； 如果被除数是零，则结果是零； 如果有一个操作数不是数值，则在后台调用 Number() 将其转换为数值，然后再应用上面的规则。 3）加性运算符加法和减法这两个加性运算符应该说是编程语言中最简单的算术运算符了。但是在 JavaScript 中，这两个运算符却都有一系列的特殊行为。与乘性运算符类似，加性运算符也会在后台转换不同的数据类型。然而，对于加性运算符而言，相应的转换规则还稍微有点复杂。 + 加法运算符如果两个运算符都是数值，执行常规的加法计算，然后根据下列规则返回结果： 如果有一个操作数是 NaN，则结果是 NaN； 如果是 Infinity 加 Infinity，则结果是 Infinity； 如果是 -Infinity 加 -Infinity，则结果是 -Infinity； 如果是 Infinity 加- Infinity，则结果是 NaN； 如果是 +0 加 +0，则结果是 +0； 如果是 -0 加 -0，则结果是 -0； 如果是 +0 加 -0，则结果是 +0; 如果有一个操作数不是数值，那么就要应用如下规则： 如果两个操作数都是字符串，则将第二个操作数与第一个操作数拼接起来； 如果只有一个操作数是字符串，则将另一个操作数转换为字符串，然后再将两个字符串拼接起来。 如果有一个操作数是对象、数值或布尔值，则调用它们的 toString() 方法取得相应的字符串值，然后再应用前面关于字符串的规则。对于 undefined 和 null，则分别调用 String() 函数并取得字符串 &quot;undefined&quot; 和 &quot;null&quot;。 如果是 null 加 null，则结果是 0; 如果是 undefined 加 undefined，则结果是 NaN; 下面来举几个例子： 12345678910var result1 = 5 + 5; // 两个数值相加console.log(result1); // 10var result2 = 5 + &quot;5&quot;; // 一个数值和一个字符串相加console.log(result2); // &quot;55&quot;var num1 = 5;var num2 = 10;var message = &quot;The sum of 5 and 10 is &quot; + num1 + num2;console.log(message); // &quot;The sum of 5 and 10 is 510&quot;，如何修改？ - 减法运算符如果两个运算符都是数值，执行常规的减法计算，然后根据下列规则返回结果： 如果有一个操作数是 NaN，则结果是 NaN； 如果是 Infinity 减 Infinity，则结果是 NaN； 如果是 -Infinity 减 -Infinity，则结果是 NaN； 如果是 Infinity 减 -Infinity，则结果是 Infinity； 如果是 -Infinity 减 Infinity，则结果是 -Infinity； 如果是 +0 减 +0，则结果是 +0； 如果是 +0 减 -0，则结果是 -0； 如果是 -0 减 -0，则结果是 +0； 如果有一个操作数不是数值，那么就要应用如下规则： 如果有一个操作数是字符串、布尔值、null 或 undefined，则先在后台调用 Number() 函数将其转换为数值，然后再根据前面的规则执行减法计算。如果转换的结果是 NaN，则减法的结果就是 NaN； 如果有一个操作数是对象，则调用对象的 valueOf() 方法以取得表示该对象的数值。如果得到的值是 NaN，则减法的结果就是 NaN。如果对象没有 valueOf() 方法，则调用其 toString()方法并将得到的字符串转换为数值。 如果是 null 减 null，则结果是 0; 如果是 undefined 减 undefined，则结果是 NaN; 下面来举几个例子： 123456var result1 = 5 - true; // 4，因为true被转换成了1var result2 = NaN - 1; // NaNvar result3 = 5 - 3; // 2var result4 = 5 - &quot;&quot;; // 5，因为&quot;&quot; 被转换成了0var result5 = 5 - &quot;2&quot;; // 3，因为&quot;2&quot;被转换成了2var result6 = 5 - null; // 5，因为null被转换成了0 4）等值运算符确定两个变量是否相等是编程中的一个非常重要的操作。在比较简单数据类型之间的相等性时，问题还比较简单。但在涉及到对象之间的比较时，问题就变得复杂了。最早的 JavaScript 中的相等和不等运算符会在执行比较之前，先将对象转换成相似的类型。后来，有人提出了这种转换到底是否合理的质疑。最后，JavaScript 的解决方案就是提供两组运算符：相等和不相等（先转换再比较），恒等和不恒等（仅比较而不转换）。 == != 运算符== != 这两个运算符都会先转换操作数（通常称为强制转型），然后再比较它们的相等性。在转换不同的数据类型时，相等和不相等运算符遵循下列基本规则： 如果有一个操作数是布尔值，则在比较相等性之前先将其转换为数值（false 转换为 0，而 true 转换为 1）； 如果一个操作数是字符串，另一个操作数是数值，在比较相等性之前先将字符串转换为数值； 如果一个操作数是对象，另一个操作数不是，则调用对象的 valueOf() 方法，用得到的基本类型值按照前面的规则进行比较； null 和 undefined 是相等的。要比较相等性之前，不能将 null 和 undefined 转换成其他任何值。 如果有一个操作数是 NaN，则相等运算符返回 false，而不相等运算符返回 true。重要提示：即使两个操作数都是 NaN，相等运算符也返回 false；因为按照规则，NaN 不等于 NaN。 如果两个操作数都是对象，则比较它们是不是同一个对象。如果两个操作数都指向同一个对象，则相等运算符返回 true；否则，返回 false。 列出了一些特殊情况及比较结果： 1234567891011null == undefined // true&quot;NaN&quot; == NaN // false5 == NaN // falseNaN == NaN // falseNaN != NaN // truefalse == 0 // truetrue == 1 // truetrue == 2 // falseundefined == 0 // falsenull == 0 // false&quot;5&quot; == 5 // true === !== 运算符除了在比较之前不转换操作数之外，恒等和不恒等运算符与相等和不相等运算符没有什么区别。它只在两个操作数未经转换就相等的情况下返回 true，如下面的例子所示： 1234var result1 = (&quot;55&quot; == 55); // true，因为转换后相等var result2 = (&quot;55&quot; === 55); // false，因为不同的数据类型不相等var result3 = (null == undefined) // true，因为它们是类似的值var result4 = (null === undefined) // false，因为它们是不同类型的值 5）关系运算符&lt; &gt; &lt;= &gt;= 运算符&lt; 小于、&gt; 大于、&lt;= 小于等于、 &gt;= 大于等于 这几个关系运算符用于对两个值进行比较返回一个布尔值。与 JavaScript 中的其他运算符一样，当关系运算符的操作数使用了非数值时，也要进行数据转换或完成某些奇怪的操作。以下就是相应的规则。 如果两个操作数都是数值，则执行数值比较。 如果两个操作数都是字符串，则比较两个字符串对应的字符编码值（可以通过字符串的 charCodeAt() 函数获取字符编码值）。 如果一个操作数是数值，则将另一个操作数转换为一个数值，然后执行数值比较。 如果一个操作数是对象，则调用这个对象的 valueOf() 方法，用得到的结果按照前面的规则执行比较。如果对象没有 valueOf()方法，则调用 toString()方法，并用得到的结果根据前面的规则执行比较。 如果一个操作数是布尔值，则先将其转换为数值，然后再执行比较。 请思考下面几个例子的结果是如何得出的： 1234567var result1 = &quot;Brick&quot; &lt; &quot;alphabet&quot;; // truevar result2 = &quot;brick&quot; &lt; &quot;alphabet&quot;; // falsevar result3 = &quot;23&quot; &lt; &quot;3&quot;; // truevar result4 = &quot;23&quot; &lt; 3; // falsevar result5 = &quot;a&quot; &lt; 3; // falsevar result6 = NaN &lt; 3; // falsevar result7 = NaN &gt;= 3; // false in 运算符in 运算符希望它的左操作数是一个字符串或可以转换为字符串，希望它的右操作数是一个对象。如果右侧的对象拥有一个名为左操作数值的属性名，那么表达式返回 true，例如： 123456789var point = &#123; x:1, y:1 &#125;; // 定义一个对象&quot;x&quot; in point // true，对象有一个名为&quot;x&quot;的属性&quot;z&quot; in point // false，对象中不存在名为&quot;z&quot;的属性&quot;toString&quot; in point // true，对象继承了toString()方法var data = [7,8,9]; // 拥有三个元素的数组&quot;0&quot; in data // true，数组包含元素&quot;0&quot;1 in data // true，数字转换为字符串3 in data // false，没有索引为3的元素 instanceof 运算符instanceof 运算符希望左操作数是一个对象，右操作数标识对象的类。如果左侧的对象是右侧类的实例，则表达式返回 true；否则返回 false。后面会讲 JavaScript 中对象的类是通过初始化它们的构造函数来定义的。这样的话，instanceof 的右操作数应当是一个函数。比如： 123456789var d = new Date(); // 通过 Date() 构造函数来创建一个新对象d instanceof Date; // true，d 是由 Date() 创建的d instanceof Object; // true，所有的对象都是 Object 的实例d instanceof Number; // false，d 不是一个 Number 对象var a = [1, 2, 3]; // 通过数组字面量的写法创建一个数组a instanceof Array; // true，a 是一个数组a instanceof Object; // true，所有的数组都是对象a instanceof RegExp; // false，数组不是正则表达式 需要注意的是，所有的对象都是 Object 的实例。当通过 instanceof 判断一个对象是否是一个类的实例的时候，这个判断也会包含对「父类」的检测。如果 instanceof 的左操作数不是对象的话，instanceof 返回 false。如果右操作数不是函数，则抛出一个类型错误异常。 6）逻辑运算符逻辑运算符是对操作数进行布尔算术运算，经常和关系运算符一起配合使用，逻辑运算符将多个关系表达式组合起来组成一个更复杂的表达式。 &amp;&amp; 逻辑与逻辑与操作可以应用于任何类型的操作数，而不仅仅是布尔值。在有一个操作数不是布尔值的情况下，逻辑与操作不一定返回布尔值；此时，它遵循下列规则： 如果第一个操作数是对象，则返回第二个操作数； 如果第二个操作数是对象，则只有在第一个操作数的求值结果为 true 的情况下才会返回该对象； 如果两个操作数都是对象，则返回第二个操作数； 如果有一个操作数是 null，则返回 null； 如果有一个操作数是 NaN，则返回 NaN； 如果有一个操作数是 undefined，则返回 undefined。 逻辑与操作属于短路操作，即如果第一个操作数能够决定结果，那么就不会再对第二个操作数求值。对于逻辑与操作而言，如果第一个操作数是 false，无论第二个操作数是什么值，结果都不再可能是 true 了。 12console.log(3 &gt; 5 &amp;&amp; 3 &gt; 2); // falseconsole.log(3 &lt; 5 &amp;&amp; 3 &gt; 2); // true || 逻辑或与逻辑与操作相似，如果有一个操作数不是布尔值，逻辑或也不一定返回布尔值；此时，它遵循下列规则： 如果第一个操作数是对象，则返回第一个操作数； 如果第一个操作数的求值结果为 false，则返回第二个操作数； 如果两个操作数都是对象，则返回第一个操作数； 如果两个操作数都是 null，则返回 null； 如果两个操作数都是 NaN，则返回 NaN； 如果两个操作数都是 undefined，则返回 undefined。 与逻辑与运算符相似，逻辑或运算符也是短路运算符。也就是说，如果第一个操作数的求值结果为 true，就不会对第二个操作数求值了。 12console.log(3 &gt; 5 || 3 &gt; 2); // true console.log(3 &gt; 5 || 3 &lt; 2); // false ! 逻辑非逻辑非操作可以应用于任何类型的操作数，无论这个值是什么数据类型，这个运算符都会返回一个布尔值。逻辑非运算符首先会将它的操作数转换为一个布尔值，然后再对其求反。逻辑非运算符遵循下列规则： 如果操作数是一个对象，返回 false； 如果操作数是一个空字符串，返回 true； 如果操作数是一个非空字符串，返回 false； 如果操作数是数值 0，返回 true； 如果操作数是任意非 0 数值（包括 Infinity），返回 false； 如果操作数是 null，返回 true； 如果操作数是 NaN，返回 true； 如果操作数是 undefined，返回 true。 下面几个例子展示了应用上述规则的结果： 123456console.log(!false); // trueconsole.log(!&quot;blue&quot;); // falseconsole.log(!0); // trueconsole.log(!NaN); // trueconsole.log(!&quot;&quot;); // trueconsole.log(!12345); // false 逻辑非运算符也可以用于将一个值转换为与其对应的布尔值。而同时使用两个逻辑非运算符，实际上就会模拟 Boolean() 转型函数的行为。其中，第一个逻辑非操作会基于无论什么操作数返回一个布尔值，而第二个逻辑非操作则对该布尔值求反，于是就得到了这个值真正对应的布尔值。当然，最终结果与对这个值使用 Boolean() 函数相同，例如： 12345console.log(!!&quot;blue&quot;); //trueconsole.log(!!0); //falseconsole.log(!!NaN); //falseconsole.log(!!&quot;&quot;); //falseconsole.log(!!12345); //true 7）位运算符在 JavaScript 中，当对数值应用位运算符时，后台会发生如下转换过程：64位的数值被转换成32位数值，然后执行位操作，最后再将32位的结果转换回64位数值。这个转换过程导致了一个严重的副效应，即在对特殊的 NaN 和 Infinity 值应用位操作时，这两个值都会被当成 0 来处理。如果对非数值应用位运算符，会先使用 Number() 函数将该值转换为一个数值，然后再应用位操作，得到的结果将是一个数值。 ~ 按位非简单的理解，对任一数值 x 进行按位非操作的结果为 -(x+1)。例如： 1234567891011console.log(~null); // -1console.log(~undefined); // -1console.log(~0); // -1console.log(~&#123;&#125;); // -1console.log(~[]); // -1console.log(~(1/0)); // -1console.log(~false); // -1console.log(~true); // -2console.log(~1.2543); // -2console.log(~4.9); // -5console.log(~(-2.999)); // 1 &amp; 按位与按位与操作就是将两个数值的每一位对齐，两个数值的对应位都是 1 时才返回 1，任何一位是 0，结果都是 0。如下表所示： 第一个数值的位 第二个数值的位 结果 1 1 1 1 0 0 0 1 0 0 0 0 | 按位或按位或操作就是将两个数值的每一位对齐，两个数值只要有一个位是 1 就返回 1，只在两个位都是 0 的情况下才返回 0。如下表所示： 第一个数值的位 第二个数值的位 结果 1 1 1 1 0 1 0 1 1 0 0 0 ^ 按位异或按位异或与按位或的不同之处在于，两个数值只有一个 1 时才返回 1，如果对应的两位都是 1 或都是 0，则返回 0。 第一个数值的位 第二个数值的位 结果 1 1 0 1 0 1 0 1 1 0 0 0 &lt;&lt; 左移这个运算符会将数值的所有位向左移动指定的位数。例如： 12var oldValue = 2; // 等于二进制的 10var newValue = oldValue &lt;&lt; 5; // 等于二进制的 1000000，十进制的 64 注意，左移不会影响操作数的符号位。换句话说，如果将 -2 向左移动 5 位，结果将是 -64，而非 64。 &gt;&gt; 有符号的右移这个运算符会将数值向右移动，但保留符号位（即正负号标记）。 12var oldValue = 64; // 等于二进制的 1000000var newValue = oldValue &gt;&gt; 5; // 等于二进制的 10 ，即十进制的 2 &gt;&gt;&gt; 无符号的右移这个运算符会将数值的所有32位都向右移动。对正数来说，无符号右移的结果与有符号右移相同。 12var oldValue = 64; // 等于二进制的 1000000var newValue = oldValue &gt;&gt;&gt; 5; // 等于二进制的 10 ，即十进制的 2 无符号右移运算符会把负数的二进制码当成正数的二进制码。而且，由于负数以其绝对值的二进制补码形式表示，因此就会导致无符号右移后的结果非常之大。 12var oldValue = -64; // 等于二进制的 11111111111111111111111111000000var newValue = oldValue &gt;&gt;&gt; 5; // 等于十进制的 134217726 8）赋值运算符简单的赋值运算符由等于号 = 表示，其作用就是把右侧的值赋给左侧的变量，如下面的例子所示： 1var num = 10; 如果在等于号 = 前面再添加乘性运算符、加性运算符或位运算符，就可以完成复合赋值操作。这种复合赋值操作相当于是对下面常规表达式的简写形式： 12var num = 10;num += 10; // 等同于 num = num + 10; 每个主要算术运算符（以及个别的其他运算符）都有对应的复合赋值运算符。这些运算符如下所示： 乘&#x2F;赋值 *=； 除&#x2F;赋值 /=； 模&#x2F;赋值 %=； 加&#x2F;赋值 +=； 减&#x2F;赋值 -=； 左移&#x2F;赋值 &lt;&lt;=； 有符号右移&#x2F;赋值 &gt;&gt;=； 无符号右移&#x2F;赋值 &gt;&gt;&gt;=。 设计这些运算符的主要目的就是简化赋值操作，使用它们不会带来任何性能的提升。 9）条件运算符? : 条件运算符应该算是 JavaScript 中最灵活的一种运算符了，而且它遵循与 Java 中的条件运算符相同的语法形式，如下面的例子所示： 1variable = boolean_expression ? true_value : false_value; 10）逗号运算符逗号运算符多用于声明多个变量；但除此之外，逗号运算符还可以用于赋值。在用于赋值时，逗号运算符总会返回表达式中的最后一项，如下面的例子所示： 1var num = (5, 1, 4, 8, 0); // num 的值为 0 由于 0 是表达式中的最后一项，因此 num 的值就是 0。虽然逗号的这种使用方式并不常见，但这个例子可以帮我们理解逗号的这种行为。","categories":[{"name":"javascript","slug":"javascript","permalink":"http://example.com/categories/javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://example.com/tags/javascript/"}]},{"title":"javascript类型、值和变量","slug":"javascript类型、值和变量","date":"2017-04-23T00:08:27.000Z","updated":"2022-05-26T11:38:09.427Z","comments":true,"path":"2017/04/23/javascript类型、值和变量/","link":"","permalink":"http://example.com/2017/04/23/javascript%E7%B1%BB%E5%9E%8B%E3%80%81%E5%80%BC%E5%92%8C%E5%8F%98%E9%87%8F/","excerpt":"","text":"类型、值和变量JavaScript类型可以分为两类：原始类型和对象类型。 原始类型包括数值、字符串、布尔值、特殊值null、undefined。其中null和undefined不是数值、字符串或布尔值，通常被认为 是各自特殊类型的唯一成员。 对象是属性的集合，其中每个属性都有一个名字和一个值。 注意：任何不是数值、字符串、布尔值、符号、null和undefined的值都是对象。 在内存管理方面，js解析器会执行自动垃圾收集。当程序无法以任何方式引用这个值时，解释器会自动释放它占用的内存。 1）数值 整数 Number用于表示整数和近似实数。 Number 类型是 JavaScript 中最令人关注的数据类型，这种类型使用 IEEE 754 格式来表示整数和浮点数值（浮点数值在某些语言中也被称为双精度数值）。和其他编程语言不同，JavaScript 中的所有数字均用浮点数值表示。 在 JavaScript 中进行算术计算时，所有以八进制和十六进制表示的数值最终都将被转换成十进制数值。例如： 1234567var a = 10; // 十进制var b = 023; // 八进制var c = 0x12ac; // 十六进制0xff = 255；（15*16+15） // 十六进制0xbadcafe // =&gt;195939070 // 十六进制console.log(b); // 19console.log(c); // 4780 八进制第一位必须是0，后面跟八进制序列0到7，如果超出了范围，则忽略前导0，后面的数值当做十进制解析，例如：089会被解析为89。（八进制字面量在严格模式下是无效的，会抛出错误。） 十六进制前两位必须是 0x 或 0X，后跟十六进制序列09、af（10~15）（不区分大小写），如果超出了范围，则会报语法错误。 浮点数 所谓浮点数值，就是该数值中必须包含一个小数点，并且小数点后面必须至少有一位数字。虽然小数点前面可以没有整数，但我们不推荐这种写法。例如： 123var a = 1.1;var b = 0.1;var c = .1; // 有效，但不推荐 JavaScript 会不失时机的将浮点数转换成整数。例如： 12var a = 5.; // 解析成整数5var b = 5.0; // 解析成整数5 对于极大或者极小的数值，可采用科学技术法（也称e表示法）。JavaScript 会将那些小数点后面带有6个零以上的小于1的浮点数值转换为以e表示法表示的数值。例如： 123var a = 3.14e7; // 等于31400000var b = 3.14E-7; // 等于0.000000314console.log(0.0000003); // 3e-7 浮点数值的最高精度是17位小数，但在进行算术计算时其精确度远远不如整数，例如： 1console.log(0.1 + 0.2); // 0.30000000000000004 这个舍入误差会导致无法测试特定的浮点数值，因此，永远不要测试某个特定的浮点数值。 Js使用的IEEE~754浮点法是一种二进制表示法，这种表示法可以精确地表示如1&#x2F;2,1&#x2F;8,1&#x2F;1024等分数。然而我们常用的十进制 分数：1&#x2F;10,1&#x2F;100等等，二进制浮点表示法无法精确表示。 123456例如：let x = .3 - .2 ;//这个数值只能非常近似地表示0.1，但无法精确的表示。let y = .2 - .1;x ===y; ==&gt;falsex ===.1; ==&gt;falsey ===.1; ==&gt;true 正无穷、负无穷 由于内存限制，JavaScript 能表示的数值范围从 Number.MIN_VALUE 到 Number.MAX_VALUE，并将超出范围的数转换成 Number.POSITIVE_INFINITY 或 Number.NEGATIVE_INFINITY。0作为除数是不会报错的，正数除以0返回正无穷，负数除以0返回负无穷，0除以0返回NaN。例如： 123456789console.log(Number.MAX_VALUE); // 最大数 1.7976931348623157e+308console.log(Number.MIN_VALUE); // 最小数 5e-324console.log(Number.POSITIVE_INFINITY); // 正无穷 Infinityconsole.log(Number.NEGATIVE_INFINITY); // 负无穷 -Infinityconsole.log( 1 / 0); // Infinityconsole.log(-1 / 0); // -Infinity JavaScript 提供了 isFinite() 函数，来确定一个数是不是有穷的。例如： 12console.log(isFinite(100)); // trueconsole.log(isFinite(Infinity)); // false NaN NaN（not a number），是一个特殊的数值。之所以称它为「非数值」，是因为它不能参与算数运算，任何涉及 NaN 的操作都返回 NaN。并且 NaN 与任何值都不相等（包括自身）。例如： 12345678console.log(typeof NaN); // &quot;number&quot;console.log(0 / 0); // NaNconsole.log(NaN - NaN); // NaNconsole.log(Infinity - Infinity); // NaNvar a = NaN;console.log(a === a); // false JavaScript 提供了 isNaN() 函数，来确定一个数是不是 NaN。例如： 12345console.log(isNaN(100)); // falseconsole.log(isNaN(&quot;100&quot;)); // falseconsole.log(isNaN(true)); // falseconsole.log(isNaN(&quot;sss&quot;)); // trueconsole.log(isNaN(NaN)); // true Number()、parseInt()、parseFloat()转型函数 isNaN() 函数在接收到一个值之后，会尝试使用转型函数 Number() 将这个值转换为数值，转换规则如下： undefined 转换为 NaN； null 转换为 0； true 转换为 1、false 转换为 0； number 整数转换为十进制，小数不变； string 如果只包含十进制数和小数，则返回对应的数值，如果只包含八进制数，则忽略前导0返回剩余部分，如果只包含十六进制，则返回十进制数，空字符串转换为0，其它字符串转换为 NaN； 如果 object 具有 valueOf() 方法，且返回一个原始值（5种简单数据类型），则将这个原始值转换为数字，并返回这个数字；否则，如果 object 具有 toString() 方法，且返回一个原始值，则将这个原始值转换为数字，并返回这个数字；否则，抛出一个类型错误异常。 由于 Number() 转型函数在转换字符串时不够理想，因此还有两个专门用来转换字符串的函数 parseInt() 和 parseFloat() 函数。 parseInt() 函数会忽略字符串前面的空格，直至找到第一个非空格字符，只要第一个非空格字符不是数字或者正负号，一律返回 NaN， 如果第一个非空格字符是数字字符，parseInt() 会继续解析第二个字符，直到解析完所有后续字符或者遇到了一个非数字字符。例如： 123console.log(parseInt(&quot;&quot;)); // NaN（Number(&quot;&quot;)返回 0）console.log(parseInt(&quot;123S&quot;)); // 123console.log(parseInt(&quot;12.4&quot;)); // 12 parseFloat() 函数也会忽略字符串前面的空格，直至找到第一个非空格字符，只要第一个非空格字符不是数字或者正负号或者小数点，一律返回 NaN， 如果第一个非空格字符是上述字符之一，parseFloat() 会继续解析第二个字符，直到解析完所有后续字符或者遇到了一个非浮点数值。例如： 12console.log(parseFloat(&quot;098.2&quot;)); // 98.2console.log(parseFloat(&quot;123.23.23&quot;)); // 123.23 2）字符串字符串是16位值的不可修改的有序序列，其中每个值都表示一个Unicode字符。 在Js中可以使用单引号、双引号或者反引号(‘ ‘ ,” “,&#96;&#96;)包含起来来表示字符串，双引号和反引号可以出现在由单引号定界的字符 串中，同理由双引号和反引号定界的字符串里也可以包含另外两种引号。 12345&quot; &quot; //空字符串&#x27;testing&#x27;&quot;3.14&quot;&quot;Wouldn&#x27;t you prefer o&#x27;Reilly&#x27;s Books&quot;`&quot;she said &#x27;hi&#x27;&quot;,he said` 转义序列 12345678910\\0 Null字符\\b 退格符\\t 水平制表符\\n 换行符\\f 进制符\\r 回车符\\&quot; 双引号\\&#x27; 单引号\\\\ 反斜杠\\xnn 由2位16进制数字nn指定的Unicode字符 转义字符可出现在字符串中的任意位置，且长度为1。如要在字符串中显示 \\ ，则必须使用 \\ 进行转义。例如： 12console.log(&quot;\\n\\\\&quot;.length); // 2console.log(&quot;\\\\hello&quot;); // &quot;\\hello&quot;（长度为6） 大部分值都可以使用继承而来的 toString()方法转换为字符串，但 undefined 和 null 值没有这个方法。对数值使用 toString() 方法时，可以传入一个数字基数，以此输出对应进制的字符串值。例如： 1234567console.log(true.toString()); // &quot;true&quot;var num = 10;console.log(num.toString()); // &quot;10&quot;console.log(num.toString(2)); // &quot;1010&quot;console.log(num.toString(8)); // &quot;12&quot;console.log(num.toString(16)); // &quot;a&quot; 在不知道要转换的值是不是 undefined 或 null 的情况下，还可以使用转型函数 String()，这个函数能够将任何类型的值转换为字符串。String() 函数遵循下列转换规则： 如果值有 toString() 方法，则调用该方法（没有参数）并返回相应的结果； 如果值是 undefined，则返回 &quot;undefined&quot;； 如果值是 null，则返回 &quot;null&quot;。 12345var value;console.log(String(10)); // &quot;10&quot;console.log(String(true)); // &quot;true&quot;console.log(String(null)); // &quot;null&quot;console.log(String(value)); // &quot;undefined&quot; 3）布尔值Boolean 类型是 JavaScript 中使用得最多的一种类型，该类型只有两个字面值：true 和 false。需要注意的是，他们是区分大小写的，也就是说 True 和 False（以及其他的混合大小写形式）都不是 Boolean 值，只是标识符。 虽然 Boolean 类型的字面值只有两个，但 JavaScript 中所有类型的值都能使用 if 语句或 Boolean() 函数转换为对应的 Boolean 值，例如： 123456var message = &quot;Hello world!&quot;;if (message)&#123; console.log(&quot;Value is true.&quot;); // 被执行&#125;var messageAsBoolean = Boolean(message);console.log(messageAsBoolean); // true 下表给出了各种数据类型及其对应的转换规则。 数据类型 转换为true的值 转换为false的值 Undefined - undefined Null - null Boolean true false String 任何非空字符串 “”（空字符串） Number 任何非零数字值（包括无穷大） 0和NaN Object 任何对象 - 4）null和undefinedUndefined 类型只有1个值，即 undefined。使用 var 声明变量但未对其加以初始化时，这个变量的值就是 undefined，直接使用未声明的变量会产生错误。对未声明或已声明但未初始化的变量执行 typeof 运算符会返回 &quot;undefined&quot; 值，例如： 1234567var message; // 这个变量声明之后默认取得了 undefined 值// var age // 这个变量并没有声明console.log(message); // &quot;undefined&quot;console.log(age); // 产生错误console.log(typeof message); // &quot;undefined&quot;console.log(typeof age); // &quot;undefined&quot; Null 类型也只有1个值，即 null。它用来表示值的空缺。你可以认为 undefined 是表示系统级的、出乎意料的或类似错误的值的空缺，而 null 是表示程序级的、正常的或在意料之中的值的空缺。在下列场景中应当使用 null。 用来初始化一个变量，这个变量可能赋值为一个对象。 用来和一个已经初始化的变量比较，这个变量可以是也可以不是一个对象。 当函数的参数期望是对象时，作用参数传入。 当函数的返回值期望是对象时，作用返回值传出。 在下列场景中不应当使用 null。 不要使用 null 来检测是否传入了某个参数。 不要使用 null 来检测一个未初始化的变量。 5）全局对象全局对象的属性是全局性定义的标识符，可以在js程序的任何地方使用。js解释器启动后都会创建一个新的全局对象并为其添加一组初始的属性。 6）对象和数组JavaScript 中所有对象都继承自 Object 类型，每个对象都具有下列基本的属性和方法： constructor：保存着用于创建当前对象的函数（构造函数）。 hasOwnProperty()：用于检查给定的属性在当前对象实例中是否存在。 propertyIsEnumerable()：用于检查给定的属性是否能够使用for-in语句来枚举。 isPrototypeOf()：用于检查对象是否是传入对象的原型。 toString() 方法：返回对象的字符串表示。 toLocaleString()：返回对象的本地字符串表示。 valueOf()：返回对象的字符串、数值或布尔值表示（通常与toString()方法的返回值相同）。 Object 本质上是由一组无序的名值对组成，「名称」部分是一个 JavaScript 字符串，「值」部分可以是任何 JavaScript 的数据类型（包括对象和方法）。这使用户可以根据具体需求，创建出相当复杂的数据结构。 以下两种方法都可以创建一个空对象，这两种方法在语义上是相同的。第二种更方便的方法叫作「对象字面量」法。这也是 JSON 格式的核心语法，一般我们优先选择第二种方法。例如： 12var obj = new Object();var obj = &#123;&#125;; // 好的写法 「对象字面量」也可以用来在对象实例中定义一个对象： 12345678var obj = &#123; name: &quot;Carrot&quot;, &quot;for&quot;: &quot;Max&quot;, details: &#123; color: &quot;orange&quot;, size: 12 &#125;&#125; 对象的属性可以通过链式（chain）表示方法进行访问： 12obj.details.color; // orangeobj[&quot;details&quot;][&quot;size&quot;]; // 12 完成创建后，对象属性可以通过如下两种方式进行赋值和访问： 12345obj.name = &quot;Simon&quot; // 赋值var name = obj.name; // 访问obj[&quot;name&quot;] = &quot;Simon&quot;; // 赋值var name = obj[&quot;name&quot;]; // 访问 对象不同于原始值，对象是可修改的，即他们的值可以改变； 123456let object = &#123; x:1&#125;对象的属性访问：object.xlet arr = [1,2,3]数组的访问：arr[0] 对象不是按值比较的，两个不同的对象即使拥有完全相同的属性和值，它们也不相等。同样，两个不同的数组，即使每个元 素都相同，顺序也相同，它们也不相等。 1234let o = &#123;x:1&#125;,p = &#123;x:1&#125;o===p =&gt;falselet a = [],b = [];a===b =&gt;false 对象被称作引用类型，以区别于js的原始类型。对象值就是引用，对象是按引用比较的。两个对象值当且仅当它们引用同一个 底层对象时，才是相等的。 7）变量声明与赋值变量是通过var或let关键字声明的 1234let i;let sum;var i ;var sum; 也可以使用一条var&#x2F;let语句声明多个变量； 12let i,sum;var i,sum; 声明变量的同时也为其赋值是一个好的编程习惯； 12let msg = &quot;Hello World&quot;;let i = 0;j = 0;k = 0; 如果在var&#x2F;let语句中不为变量指定初始值，变量也会被声明，但在赋值之前它的值是undefined。 const是用来声明常量的，常量在声明是必须初始化且值不能改变，尝试给常量重新赋值会抛出TypeError 12const H0 = 74;const C = 299792.458 变量的作用域是程序源代码中的一个区域，在这个区域内变量有定义。通过let和const声明的变量和常量具有块作用域。这意味着它们只在let和const语句所在的代码块中有定义。 1234console.log(i);//抛出错误if(true)&#123; let i = 0;&#125; 在同一个作用域中使用多个let或const声明同一个名字是语法错误。在嵌套作用域中声明同名变量是合法的（最好不要这么做） 1234567const x = 1;if(x === 1)&#123; let x = 2; console.log(2)//打印2&#125;console.log(x);//打印1，回到全局作用域let x = 3;//报错 使用var和let声明的区别： 使用var声明的变量不具有块作用域，这种变量的作用域仅限于包含函数的函数体，无论它们在函数中嵌套的层次有多深。 如果在函数体外使用var声明，会声明一个全局变量。通过var声明的全局变量可以通过globalThis引用，因此，如果在函数外部写了var x &#x3D;2,则相当于globalThis.x &#x3D; 2; 使用var多次声明同名变量是合法的。 var声明变量的特性是作用域提升。在使用var声明变量时，该声明会被提高到包含函数的顶部。但变量的初始化仍然在代码所在位置完成，只有变量的定义转移到了函数顶部。","categories":[{"name":"javascript","slug":"javascript","permalink":"http://example.com/categories/javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://example.com/tags/javascript/"}]},{"title":"javascript词法结构","slug":"javascript词法结构","date":"2017-04-22T13:22:48.000Z","updated":"2022-05-26T11:18:17.453Z","comments":true,"path":"2017/04/22/javascript词法结构/","link":"","permalink":"http://example.com/2017/04/22/javascript%E8%AF%8D%E6%B3%95%E7%BB%93%E6%9E%84/","excerpt":"","text":"词法结构1）区分大小写JavaScript 是区分大小写的。也就是说，关键字、变量、函数名和所有的标识符（identifier）都必须采取一致的大小写形式。 比如，关键字 while 必须写成 while，而不能写成 While 或者 WHILE。同样，online、Online、OnLine、ONLINE 是4个不同的 变量名。 但需要注意的是，HTML 并不区分大小写。由于它和客户端 JavaScript 联系紧密，因此这点区别很容易混淆。许多客户端 JavaScript 对象和属性与他们所表示的 HTML 标签和属性名相同。在 HTML 中，这些标签和属性名可以使用大写也可以是小 写，而在 JavaScript 中则必须是小写。例如，在 HTML 中设置事件处理程序时，onclick 属性可以写成 onClick，但在 JavaScript 代码中，必须使用小写的 onclick。 1234var userName = &#x27;张三&#x27;;var username = &#x27;李四&#x27;;console.log(userName);console.log(username) 2）注释JavaScript 使用 C 风格的注释，包括单行注释和块级注释。单行注释以两个斜杠 // 开头，块级注释以一个斜杠和一个星号 /* 开头，以一个星号和一个斜杠 */ 结尾。下面都是合法的 JavaScript 注释： 12345// 这是单行注释/*** * 这是多行注释 * 这是多行注释***/ 虽然上面注释中的第二和第三行都以一个星号开头，但这不是必须的，纯粹是为了提高注释的可读性 3）字面量所谓字面量（也可称直接量，Literal values），就是程序中直接使用的数据值。字面量只代表自身，不存储在特定位置。 JavaScript 中的字面量有：字符串、数字、布尔值、对象、数组、函数、正则表达式，以及特殊的 null 值。 12345678910&quot;hello world&quot; // 字符串123 // 数字1.2 // 小数true // 布尔值false // 布尔值/javascript/gi // 正则表达式null // 空&#123; name: &#x27;stone&#x27;, age: 20&#125; // 对象[ 1, 2, 3, 4, 5, 6, 7, 8 ] // 数组function()&#123; console.log(&#x27;good&#x27;); &#125; // 函数 4）标识符标识符用于在js代码中命名常量，变量，属性，函数和类，以及某些循环提供标记。 标识符命名规则 由数字、字母、下划线或$（美元符）组成； 不能以数字开头；并且区分大小写； 不能用关键字，保留字命名； 1234567//正确的命名方式my_name;_username;$str//错误的命名方式.myname1user 5）关键字和保留字ECMAScript 3 描述了一组具有特定用途的关键字，这些关键字可用于表示控制语句的开始或结束，或者用于执行特定操作 等。按照规则，关键字是语言保留的，不能用作标识符。以下是 ECMAScript 3 的全部关键字： 123456break delete function return typeofcase do if switch varcatch else in this voidcontinue false instanceof throw whiledebugger finally new true withdefault for null try ECMAScript 3 还将 Java 的所有关键字都作为自己的保留字，保留字也是不能当初标识符。尽管保留字还没有任何特定的用途，但他们有可能在将来被用作关键字： 123456abstract double goto native staticboolean enum implements package superbyte export import private synchronizedchar extends int protected throwsclass final interface public transientconst float long short volatile ECMAScript 5 把非严格模式下的保留字缩减为： 12class enum extends superconst export import ECMAScript 5 在严格模式下的保留字为： 123implements package publicinterface private staticlet protected yield 注意，let 和 yield 是 ECMAScript 5 新增的保留字，其他保留字都是 ECMAScript 3 定义的。为了保证兼容性，任何时候都不建议使用 ECMAScript 5 新增的保留字 let 和 yield 。 ECMAScript 还预定义了很多全局变量和函数，也应当避免把它们用作标识符： 12345678arguments Error Math RegExpArray eval NaN StringBoolean EvalError Number SyntaxErrorDate Function Object TypeErrordecodeURI Infinity parseFloat undefineddecodeURIComponent isFinite parseInt URIErrorencodeURI isNaN RangeErrorencodeURIComponent JSON ReferenceError JavaScript 的具体实现可能定义独有的全局变量和函数，每一种特定的 JavaScript 运行环境都有自己的一个全局属性列表，这一点是需要牢记的。 6）可选的分号js使用分号(;)分割语句，这对于保持代码的清晰很重要：如果没有分隔符，一条语句的结尾可能是另一条语句的开头。 js中如果两条语句分别写在两行，通常可以省略它们之间的分号。 123例如：var a = 4;var b = 3; 像这种方式可以省略分号。 如果是下面这种情况，必须加分号 1var a = 4;b = 3; 7）严格模式在 ECMAScript 5 引入了严格模式（strict mode）的概念。严格模式是为 JavaScript 定义了一种不同的解析与执行模式。在严格模式下，ECMAScript 3 中的一些不确定的行为将得到处理，而且对某些不安全的操作也会抛出错误。要在整个脚本中启用严格模式，可以在顶部添加如下代码： 1&quot;use strict&quot;; 这行代码看起来像是字符串，而且也没有赋值给任何变量，但其实它是一个编译指示（pragma），用于告诉支持的 JavaScript 引擎切换到严格模式。这是为了不破坏 ECMAScript 3 语法而特意选定的语法。 在函数内部的第一行包含这条编译指示，也可以指定函数在严格模式下执行： 1234function doSomething()&#123; &quot;use strict&quot;; // 函数体&#125;","categories":[{"name":"javascript","slug":"javascript","permalink":"http://example.com/categories/javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://example.com/tags/javascript/"}]},{"title":"面向对象编程","slug":"面向对象编程","date":"2017-01-20T03:48:17.000Z","updated":"2022-05-28T03:51:20.994Z","comments":true,"path":"2017/01/20/面向对象编程/","link":"","permalink":"http://example.com/2017/01/20/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/","excerpt":"","text":"一、面向对象与面向过程 面向过程：根据业务逻辑从上到下写代码。 面向对象：将变量与函数绑定到一起，分类进行封装，每个程序只要负责分配给自己的分类，这样能够更快速的开发程序，减少了重复代码。 面向过程编程最易被初学者接受，其往往用一长段代码来实现指定功能，开发过程的思路是将数据与函数按照执行的逻辑顺序组织在一起，数据与函数分开考虑，面向过程基本是由函数组成的。 面向过程编程面向过程编程的关注点在于怎么做 把完成某一个需求的 所有步骤 从头到尾 逐步实现 根据开发需求，将某些 功能独立 的代码 封装 成一个又一个 函数 最后完成的代码，就是顺序地调用 不同的函数 特点: 注重步骤与过程，不注重职责分工 如果需求复杂，代码会变得很复杂 开发复杂项目，没有固定的套路，开发难度很大！ 02. 面向对象基本概念面向对象编程（Object Oriented Programming，OOP，面向对象程序设计）和面相过程编程，是两种不同的编程方式。 面向对象编程的关注点在于谁来做 相比较函数，面向对象是更大的封装，根据职责在 一个对象中封装多个方法 在完成某一个需求前，首先确定职责 —— 要做的事情（方法） 根据 职责 确定不同的 对象，在对象内部封装不同的方法（多个） 最后完成的代码，就是顺序地调用不同对象的相应方法。 特点: 注重 对象和职责，不同的对象承担不同的职责。 更加适合应对复杂的需求变化，是专门应对复杂项目开发，提供的固定套路。 需要在面向过程基础上，再学习一些面向对象的语法。 类和对象类和对象是面向对象编程的两个核心概念。 类类是对一群具有相同特征或者行为 的事物的一个统称，是抽象的，不能直接使用 特征其实就是一个变量，在类里我们称之为属性。 行为其实就是一个函数，在类里我们称之为方法。 类其实就是由 属性 和 方法 组成的一个抽象概念。 类就相当于制造飞机时的图纸，是一个模板。这个模板只规定了飞机的某些特征(例如大小，颜色，型号等等)和行为(例如起飞，降落，飞行等等)，它并不是一个具体的飞机，而是对飞机的一个抽象概念。它出现的目的，是为了让我们的创建飞机对象。 对象对象是由类创建出来的一个具体存在，可以直接使用。由哪一个类创建出来的 对象，就拥有在哪一个类中定义的属性和方法。 对象 就相当于用图纸制造的飞机。在开发中，应该先有类，在类里定义好属性和行为，再根据类来创建对象。 类和对象的关系 类是模板，对象是根据类这个模板创建出来的，应该先有类，再有对象。 使用同一个类，能够创建出很多对象。 类中定义了什么属性和方法，对象中就有什么属性和方法。 不同对象对应的属性值也会不同。 例如：定义了一个狗类，这个狗类有以下属性： 品种 颜色 性别 名字 现在根据这个类创建出了两条狗，这两条狗分别是 哈士奇、灰色、母、二哈 和 中华田园犬、黄色、公、旺财。我们发现，这两条狗都具有 品种、颜色、性别和名字这些属性，但是每条狗对应的属性值却不一样。 类的设计在程序开发中，要设计一个类，通常需要满足一下三个要素： 类名 这类事物的名字，安照大驼峰命名法(每个单词的首字母大写)起名。 属性 这类事物具有什么样的特征。 方法 这类事物具有什么样的行为。 定义类名名词提炼法:分析整个业务流程，出现的名词，通常就是找到的类。 属性和方法的确定 对对象的特征描述，可以定义成属性 对象具有的行为（动词）可以定义成方法 面向对象基本语法在Python中，对象几乎是无处不在的，我们可以使用dir内置函数来查看这个对象里的方法。 定义简单的类（只包含方法） 面向对象是更大的封装，在一个类中封装多个方法，这样通过这个类创建出来的对象，就可以直接调用这些方法了！ 定义类在Python中要定义一个只包含方法的类，语法格式如下： 12345class 类名: def 方法1(self,参数列表): pass def 方法2(self,参数列表): pass 方法的定义格式和函数一样。 方法里的第一个参数必须是self。. 类名要遵守大驼峰命名法。 创建实例对象当一个类定义完成之后，要使用这个类来创建对象，语法格式如下： 1对象变量名 = 类名() 案例需求 小猫 爱 吃 鱼，小猫 要 喝 水 分析 定义一个猫类 Cat 定义两个方法 eat 和 drink 按照需求 —— 不需要定义属性 12345678910111213141516class Cat: &quot;&quot;&quot;这是个猫类&quot;&quot;&quot; def eat(self): print(&quot;小猫在吃东西&quot;) def drink(self): print(&quot;小猫在喝水&quot;)tom = Cat() # 创建了一个Cat对象tom.eat()tom.drink()hello_kitty = Cat() # 又创建了一个新的Cat对象hello_kitty.eat()hello_kitty.drink( self的使用给对象添加属性python支持动态属性，当一个对象创建好了以后，直接使用 对象.属性名 = 属性值 就可以很方便的给对象添加一个属性。 12tom = Cat()tom.name = &#x27;Tom&#x27; # 可以直接给 tom 对象添加一个 name 属性 这种方法很方便，但是，不建议使用这种方式给对象添加属性。 self的概念哪个对象调用了方法，方法里的self指的就是谁。 通过 self.属性名 可以访问到这个对象的属性；通过 self.方法名() 可以调用这个对象的方法。 1234567891011class Cat: def eat(self): print(&quot;%s爱吃鱼&quot; %self.name)tom = Cat()tom.name = &#x27;Tom&#x27; # 给 tom 对象添加了一个name属性tom.eat() # Tom爱吃鱼lazy_cat = Cat()lazy_cat.name = &quot;大懒猫&quot;lazy_cat.eat() # 大懒猫爱吃鱼 直接给对象添加属性的缺点上述代码中，我们是先创建对象，然后再给对象添加 name 属性，但是这样做会有问题。 123tom = Cat()tom.eat()tom.name = &quot;Tom&quot; 程序运行时会报错： 12AttributeError: &#x27;Cat&#x27; object has no attribute &#x27;name&#x27;错误提示：&#x27;Cat&#x27;对象没有 &#x27;name&#x27; 属性 在日常开发中，不推荐在类的外部直接给对象添加属性这种方式。对象应该具有哪些属性，我们应该封装在类的内部。","categories":[{"name":"python","slug":"python","permalink":"http://example.com/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"http://example.com/tags/python/"}]}],"categories":[{"name":"vue","slug":"vue","permalink":"http://example.com/categories/vue/"},{"name":"javascript","slug":"javascript","permalink":"http://example.com/categories/javascript/"},{"name":"AJAX","slug":"AJAX","permalink":"http://example.com/categories/AJAX/"},{"name":"BOM","slug":"BOM","permalink":"http://example.com/categories/BOM/"},{"name":"DOM","slug":"DOM","permalink":"http://example.com/categories/DOM/"},{"name":"python","slug":"python","permalink":"http://example.com/categories/python/"}],"tags":[{"name":"vue","slug":"vue","permalink":"http://example.com/tags/vue/"},{"name":"javascript","slug":"javascript","permalink":"http://example.com/tags/javascript/"},{"name":"AJAX","slug":"AJAX","permalink":"http://example.com/tags/AJAX/"},{"name":"BOM","slug":"BOM","permalink":"http://example.com/tags/BOM/"},{"name":"DOM","slug":"DOM","permalink":"http://example.com/tags/DOM/"},{"name":"python","slug":"python","permalink":"http://example.com/tags/python/"}]}