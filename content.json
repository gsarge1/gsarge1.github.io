{"meta":{"title":"Valar Dohaeris","subtitle":"","description":"世上只有一种真正的英雄主义,那就是认清生活的真相后依然热爱生活","author":"烨钬","url":"http://example.com","root":"/"},"pages":[{"title":"分类","date":"2022-05-26T09:18:55.000Z","updated":"2022-05-26T09:20:04.365Z","comments":true,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""},{"title":"标签页","date":"2022-05-26T09:17:40.000Z","updated":"2022-05-26T11:07:48.162Z","comments":true,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""},{"title":"link","date":"2022-05-26T09:20:37.000Z","updated":"2022-05-26T09:20:52.753Z","comments":true,"path":"link/index.html","permalink":"http://example.com/link/index.html","excerpt":"","text":""}],"posts":[{"title":"数据分析（1-3）","slug":"数据分析（1-3）","date":"2021-05-30T02:53:51.000Z","updated":"2022-05-30T03:23:49.567Z","comments":true,"path":"2021/05/30/数据分析（1-3）/","link":"","permalink":"http://example.com/2021/05/30/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%EF%BC%881-3%EF%BC%89/","excerpt":"","text":"Python数据分析从入门到精通课程简介自然智能自然智能（Natural Intelligence，NI），指人通过大脑的运算和决策产生有价值的行为。这些行为包括了人的大脑思考及决策、耳朵听力及判断、眼睛视觉及判断、鼻子嗅觉及判断、皮肤触觉及判断等，体现在人行为的方方面面。 人工智能定义 百度百科：它是研究、开发用于模拟、延伸和扩展人的智能的理论、方法、技术及应用系统的一门新的技术科学。 人工智能（Artificial intelligence）简称AI。人工智能是计算机科学的一个分支，它企图了解智能的本质，并生产出一种新的能以人类智能相似的方式做出反应的智能机器，是研究、开发用于模拟、延伸和扩展人的智能的理论、方法、技术及应用系统的一门新的技术科学。 借用《计算机科学导论》作者贝赫鲁兹·佛罗赞（Behrouz Forouzan）的说法，人工智能是对程序系统的研究，该程序系统在一定程度上能模仿人类的活动，如感知，思考，学习和反应。 分类人工智能目前分为弱人工智能和强人工智能和超人工智能。 弱人工智能：弱人工智能（Artificial Narrow Intelligence &#x2F;ANI),只专注于完成某个特定的任务，例如语音识别、图象识别和翻译等，是擅长于单个方面的人工智能。它们只是用于解决特定的具体类的任务问题而存在，大都是统计数据，以此从中归纳出模型。由于弱人工智能智能处理较为单一的问题，且发展程度并没有达到模拟人脑思维的程度，所以弱人工智能仍然属于“工具”的范畴，与传统的“产品”在本质上并无区别。 强人工智能：强人工智能（Artificial General Intelligence &#x2F;AGI),属于人类级别的人工智能，在各方面都能和人类比肩，它能够进行思考、计划、解决问题、抽象思维、理解复杂理念、快速学习和从经验中学习等操作，并且和人类一样得心应手。 超人工智能：超人工智能（Artificial Super intelligence&#x2F;ASI），在几乎所有领域都比最聪明的人类大脑都聪明许多，包括科学创新、通识和社交技能。在超人工智能阶段，人工智能已经跨过“奇点”，其计算和思维能力已经远超人脑。此时的人工智能已经不是人类可以理解和想象。人工智能将打破人脑受到的维度限制，其所观察和思考的内容，人脑已经无法理解，人工智能将形成一个新的社会。 我们现阶段还处于若人工智能阶段。 机器学习机器学习（Machine Learning）简称ML。机器学习属于人工智能的一个分支，也是人工智能的和核心。机器学习理论主要是设计和分析一些让计算机可以自动”学习“的算法。 深度学习深度学习（Deep Learning）简称DL。最初的深度学习是利用深度神经网络来解决特征表达的一种学习过程。深度神经网络本身并不是一个全新的概念，可大致理解为包含多个隐含层的神经网络结构。为了提高深层神经网络的训练效果，人们对神经元的连接方法和激活函数等方面做出相应的调整。深度学习是机器学习研究中的一个新的领域，其动机在于建立、模拟人脑进行分析学习的神经网络，它模仿人脑的机制来解释数据，如图象、声音、文本。 区别与联系 数据分析机器学习是强大的数据分析工具 数据分析行业前景 就业岗位成为数据分析师 机器学习开发工程师 科学计算的科学家 学习重点Numpy、Pandas、Matplotlib, Scipy、Scikit-learn、pyecharts Numpy库和 工具anaconda 的下载和安装 官网：https://www.anaconda.com/products/individual 百度网盘：链接：https://pan.baidu.com/s/1VVwv3-AIr7c3S7juGpp8mQ提取码：v2bh 安装成功验证： 查看已经安装的安装包： pip list anaconda 安装工具包方法： pip install pip install 安装包名称 -i https://pypi.tuna.tsinghua.edu.cn/simple jupyter notebookJupyter Notebook将代码、说明文本、数学方程式、数据可视化图表等内容全部组合到一起显示在一个共享的文档中，可以实现一边写代码一边记录，而这些功能是Python自带的IDLE和集成开发环境PyCharm无法比拟的。 快捷键 Enter : 转入编辑模式 Shift-Enter : 运行本单元，选中下个单元 Ctrl-Enter : 运行本单元 Alt-Enter : 运行本单元，在其下插入新单元 Y : 单元转入代码状态 M :单元转入markdown状态 R : 单元转入raw状态 1 : 设定 1 级标题 2 : 设定 2 级标题 3 : 设定 3 级标题 4 : 设定 4 级标题 5 : 设定 5 级标题 6 : 设定 6 级标题 Up : 选中上方单元 K : 选中上方单元 Down : 选中下方单元 J : 选中下方单元 Shift-K : 扩大选中上方单元 Shift-J : 扩大选中下方单元 A : 在上方插入新单元 B : 在下方插入新单元 X : 剪切选中的单元 C : 复制选中的单元 Shift-V : 粘贴到上方单元 V : 粘贴到下方单元 Z : 恢复删除的最后一个单元 D,D : 删除选中的单元 Shift-M : 合并选中的单元 Ctrl-S : 文件存盘 S : 文件存盘 L : 转换行号 O : 转换输出 Shift-O : 转换输出滚动 Esc : 关闭页面 Q : 关闭页面 H : 显示快捷键帮助 I,I : 中断Notebook内核 0,0 : 重启Notebook内核 Shift : 忽略 Shift-Space : 向上滚动 Space : 向下滚动 spyder 变量浏览器窗口 创建项目 pycharm开发工具比较PyCharm、Jupyter Notebook和Spyder这3种开发工具，各有特点。 a.数据分析，建议使用Spyder和Jupyter Notebook b.复杂、大型项目，建议使用PyCharm c. 数据分析、复杂和大型项目，建议三者可以结合使用 第一章 了解数据分析一. 数据分析流程熟悉工具-明确目的-获取数据-数据处理-数据分析-验证结果-结果呈现-数据应用 1.熟悉工具2.明确目的在数据分析方面，首先要花一些时间搞清楚为什么要做数据分析、分析什么、想要达到什么效果。例如，为了评估产品改版后的效果比之前是否有所提升，或通过数据分析找到产品迭代的方向等。只有明确了分析目的，才能够找到适合的分析方法，也才能够有效地进行数据处理、数据分析和预测等后续工作。 3.获取数据数据的来源有很多，像我们熟悉的Excel数据、数据库中的数据、网站数据以及公开的数据集等。那么，获取数据之前首先要知道需要什么时间段的数据，哪张表中的数据，以及如何获得，是下载、复制还是爬取等。 4.数据处理 数据规约：在接近或保持原始数据完整性的同时将数据集规模减小，以提高数据处理的速度。例如，一张Excel表中包含近3年的几十万条数据，由于我们只分析近一年的数据，因此要一年的数据即可，这样做的目的就是减小数据规模，提高数据处理速度。 数据清洗：在获取到原始数据后，可能其中的很多数据都不符合数据分析的要求，那么就需要按照如下步骤进行处理。 ​ a.数据探索分析：分析数据的规律，通过一定的方法统计数据，通过统计结果判断数据是否存在缺失、异常等情况。例如，通过最小值判断数量、金额是否包含缺失数据，如果最小值为0，那么这部分数据就是缺失数据，以及通过判断数据是否存在空值来判断数据是否缺失。 ​ b.重复数据处理：对于重复的数据删除即可。 ​ c.缺失数据处理：对于缺失的数据，如果比例高于30%可以选择放弃这个指标，删除即可；如果低于30%可以将这部分缺失数据进行填充，以0或均值填充。 ​ d.异常数据处理：异常数据需要对具体业务进行具体分析和处理，对于不符合常理的数据可进行删除。例如，性别男或女，但是数据中存在其他值，以及年龄超出正常年龄范围，这些都属于异常数据。 数据加工：包括数据抽取、数据计算、数据分组和数据转换。 ​ a.数据抽取：是指选取数据中的部分内容。 ​ b.数据计算：是进行各种算术和逻辑运算，以便得到进一步的信息。 ​ c.数据分组：是按照有关信息进行有效的分组。 ​ d.数据转换：是指数据标准化处理，以适应数据分析算法的需要，常用的有z-score标准化，“最小、最大标准化”和“按小数定标标准化”等。经过上述标准化处理后，数据中各指标值将会处在同一个数量级别上，以便更好地对数据进行综合测评和分析。 5.数据分析数据分析过程中，选择适合的分析方法和工具很重要，所选择的分析方法应兼具准确性、可操作性、可理解性和可应用性。但对于业务人员（如产品经理或运营）来说，数据分析最重要的是数据分析思维。 6.验证结果通过数据分析我们会得到一些结果，但是这些结果只是数据的主观结果的体现，有些时候不一定完全准确，所以必须要进行验证。 例如，数据分析结果显示某产品点击率非常高，但实际下载量平平，那么这种情况，不要轻易定论，这种产品受欢迎，而要进一步验证，找到真正影响点击率的原因，这样才能做出更好的决策。 7.结果呈现现如今，企业越来越重视数据分析给业务决策带来的有效应用，而可视化是数据分析结果呈现的重要步骤。可视化是以图表方式呈现数据分析结果，这样的结果更清晰、更直观、更容易理解。 8.数据应用数据分析的结果并不仅仅是把数据呈现出来，而更应该关注的是通过分析这些数据，后面可以做什么？如何将数据分析结果应用到实际业务中才是学习数据分析的重点。数据分析结果的应用是数据产生实际价值的直接体现，而这个过程需要具有数据沟通能力、业务推动能力和项目工作能力。如果看了数据分析结果后并不知道做什么，那么这个数据分析就是失败的。 二.数据分析常用的工具excel 或者 python excel Excel具备多种强大功能，例如创建表格、数据透视表、VBA等，Excel的系统如此庞大，确保了大家可以根据自己的需求分析数据。但是在今天，大数据、人工智能时代，数据量很大的情况下Excel已经无法胜任，不仅处理起来很麻烦而且处理速度也会变慢。从数据分析的层面，Excel也只是停留在描述性分析，如对比分析、趋势分析、结构分析等。 python 虽然Excel已尽最大努力考虑到数据分析的大多数应用场景，但由于它是定制软件，很多东西都固化了，不能自由地修改。而Python非常的强大和灵活，可以编写代码来执行所需的任何操作，从专业和方便的角度来看，它比Excel更加强大。另外，Python可以实现Excel难以实现的应用场景。 a．专业的统计分析例如，正态分布、使用算法对聚类进行分类和回归分析等。这种分析就像用数据做实验一样。它可以帮助我们回答下面的问题。数据的分布是正态分布、三角分布还是其他类型的分布？离散情况如何？它是否在我们想要达到的统计可控范围内？不同参数对结果的影响是多少？b．预测分析例如，我们打算预测消费者的行为。他会在我们的商店停留多长时间？他会花多少钱？我们可以找出他的个人信用情况，并根据他的在线消费记录确定贷款金额。或者，我们可以根据他在网页上的浏览历史推送不同的产品。这也涉及当前流行的机器学习和人工智能概念。 综上所述，Python作为数据分析工具的首选，具有以下优势。 Python语言简单易学、数据处理简单高效，对于初学者来说更加容易上手。 Python第三方扩展库不断更新，可用范围越来越广。 在科学计算、数据分析、数学建模和数据挖掘方面占据越来越重要的地位。 可以和其他语言进行对接，兼容性稳定。当然，如果您既会Excel又会Python，那么绝对是职场的加分项！ 第二章 Pandas统计分析Pandas是Python的核心数据分析支持库，它提供了大量能使我们快速便捷地处理数据的函数和方法。由于Pandas相关知识非常多，本书将Pandas分为上、下两章进行讲解。本章开始Pandas入门内容，从安装开始，逐步介绍Pandas相关的入门知识，包括两个主要的数据结构，即Series对象和DataFrame对象，也包括如何导入外部数据、数据抽取，以及数据的增加、修改和删除，还包括数据清洗、索引设置、数据排序与排名等相关基础知识，这些都是在为后期数据处理和数据分析打下良好的基础。 一. Pandas概述Pandas是数据分析三大剑客之一，是Python的核心数据分析库，它提供了快速、灵活、明确的数据结构，能够简单、直观、快速地处理各种类型的数据，具体介绍如下所示。 Pandas能够处理以下类型的数据。 1.与SQL或Excel表类似的数据。 2.有序和无序（非固定频率）的时间序列数据。 3.带行、列标签的矩阵数据。 4.任意其他形式的观测、统计数据集。 Pandas提供的两个主要数据结构Series（一维数组结构）与DataFrame（二维数组结构），可以处理金融、统计、社会科学、工程等领域里的大多数典型案例，并且Pandas是基于NumPy开发的，可以与其他第三方科学计算库完美集成。Pandas的功能很多，它的优势如下。 list1&#x3D;[0,1,2,3,4,5] list2&#x3D;[[0,1,2,3,4,5],[0,1,2,3,4,5]] 1.处理浮点与非浮点数据里的缺失数据，表示为NaN。 2.大小可变，例如插入或删除DataFrame等多维对象的列。 3.自动、显式数据对齐，显式地将对象与一组标签对齐，也可以忽略标签，在Series、DataFrame计算时自动与数据对齐。 4.强大、灵活的分组统计（groupby）功能，即数据聚合、数据转换。 5.把Python和NumPy数据结构里不规则、不同索引的数据轻松地转换为DataFrame对象。 6.智能标签，对大型数据集进行切片、花式索引、子集分解等操作。 7.直观地合并（merge）、连接（join）数据集。 灵活地重塑（reshape）、透视（pivot）数据集。 8.成熟的导入、导出工具，导入文本文件（CSV等支持分隔符的文件）、Excel文件、数据库等来源的数据，导出Excel文件、文本文件等，利用超快的HDF5格式保存或加载数据。 9.时间序列：支持日期范围生成、频率转换、移动窗口统计、移动窗口线性回归、日期位移等时间序列功能。 例1.读取excel数据 123import pandas as pd #导入pandas 模块df=pd.read_excel(&#x27;data.xlsx&#x27;) #读取Excel 文件df1=df.head() #显示前5 条数据 二. seires 对象Pandas是Python数据分析重要的库，而Series和DataFrame是Pandas库中两个重要的对象，也是Pandas中两个重要的数据结构，如图所示。 本节将主要介绍Series对象。 2.1 图解Series对象Series是Python的Pandas库中的一种数据结构，它类似一维数组，由一组数据以及与这组数据相关的标签（即索引)组成，或者仅有一组数据没有索引也可以创建一个简单的Series。Series可以存储整数、浮点数、字符串、Python对象等多种类型的数据。例如，在成绩表（见图3)中包含了Series对象和DataFrame对象，其中“语文”“数学”“英语”3列中的每一列均是一个Series对象，而“语文”“数学”“英语”3列组成了一个DataFrame对象，如图4所示。 ​ 图3 ​ 图4 2.2 创建一个series对象创建Series对象主要使用Pandas的Series()方法，语法如下： 1s=pd.Series(data,index=index) 参数说明： data：表示数据，支持Python字典、多维数组、标量值（即只有大小，没有方向的量。也就是说，只是一个数值，如s&#x3D;pd.Series(5)）。 index：表示行标签（索引）。 返回值：Series对象。 说明当data参数是多维数组时，index长度必须与data长度一致。如果没有指定index参数，则自动创建数值型索引（从0～data数据长度-1）。 【示例02】 在成绩表添加一列“物理”成绩。（示例位置：资源包\\MR\\Code\\03\\02）创建一个Series对象，在成绩表中添加一列“物理”成绩。程序代码如下： 123import pandas as pds1=pd.Series([88,60,75])03 print(s1) 上述举例，如果通过Pandas模块引入Series对象，那么就可以直接在程序中使用Series对象了。主要代码如下： 12from pandas import Seriess1=Series([88,60,75]) 2.3 手动设置series索引创建Series对象时会自动生成整数索引，默认值从0开始至数据长度减1。例如，3.2.1节举例中使用的就是默认索引，如0、1、2。除了使用默认索引，还可以通过index参数手动设置索引。 【示例03】 手动设置索引。（示例位置：资源包\\MR\\Code\\03\\03）下面手动设置索引，将3.2.1节添加的“物理”成绩的索引设置为1、2、3，也可以是“明日同学”“高同学”“七月流火”。 程序代码如下： 运行程序，控制台输出结果如下： 说明上述结果中输出的dtype是DataFrame数据的数据类型，int为整型，后面的数字表示位数。 2.4 series 位置索引2.4.1 series位置索引位置索引是从0开始数，[0]是Series第一个数，[1]是Series第二个数，以此类推。 【示例04】 通过位置索引获取学生物理成绩。（示例位置：资源包\\MR\\Code\\03\\04）获取第一个学生的物理成绩。程序代码如下： 123import pandas as pds1=pd.Series([88,60,75])print(s1[0]) 运行程序，控制台输出结果如下： 88 注意Series不能使用[-1]定位索引。 2.4.2 series 标签索引Series标签索引与位置索引方法类似，用[ ]表示，里面是索引名称，注意index的数据类型是字符串，如果需要获取多个标签索引值，用[[ ]]表示（相当于[ ]中包含一个列表）。 【示例05】 通过标签索引获取学生物理成绩。（示例位置：资源包\\MR\\Code\\03\\05）通过标签索引“明日同学”和“七月流火”获取物理成绩，程序代码如下： 2.4.3 series 切片索引用标签索引做切片，包头包尾（即包含索引开始位置的数据，也包含索引结束位置的数据）。 【示例06】 通过切片获取数据。（示例位置：资源包\\MR\\Code\\03\\06）通过标签切片索引“明日同学”至“七月流火”获取数据。程序代码如下： 1print(s1[&#x27;明日同学&#x27;:&#x27;七月流火&#x27;]) #通过切片获取索引值 用位置索引做切片，和list列表用法一样，包头不包尾（即包含索引开始位置的数据，不包含索引结束位置的数据）。 【示例07】 通过位置切片获取数据。（示例位置：资源包\\MR\\Code\\03\\07）通过位置切片1～4获取数据，程序代码如下： 12s2=pd.Series([88,60,75,34,68])print(s2[1:4]) 运行程序，控制台输出结果如下： 1 602 753 34 2.4.5 获取series索引和值获取Series索引和值主要使用Series的index和values方法。 【示例08】 获取物理成绩的索引和值。（示例位置：资源包\\MR\\Code\\03\\08）下面使用Series的index和values方法获取物理成绩的索引和值，程序代码如下： 1234import pandas as pds1=pd.Series([88,60,75])print(s1.index)print(s1.values) 运行程序，控制台输出结果如下： RangeIndex(start&#x3D;0, stop&#x3D;3, step&#x3D;1)[88 60 75] 三. DataFrame对象DataFrame是Pandas库中的一种数据结构，它是由多种类型的列组成的二维表数据结构，类似于Excel、SQL或Series对象构成的字典。DataFrame是最常用的Pandas对象，它与Series对象一样支持多种类型的数据。 3.1 图解DataFrame对象DataFrame是一个二维表数据结构，由行、列数据组成的表格。DataFrame既有行索引也有列索引，它可以看作是由Series对象组成的字典，不过这些Series对象共用一个索引，如图3.11所示。 图3.11 DataFrame结构处理DataFrame表格数据时，用index表示行或用columns表示列更直观。用这种方式迭代DataFrame的列，代码更易读懂。 【示例09】 遍历DataFrame数据。（示例位置：资源包\\MR\\Code\\03\\09）遍历DataFrame数据，输出成绩表的每一列数据，程序代码如下： 运行程序，控制台输出结果如下： 从运行结果得知，上述代码返回的其实是Series，如图3.12所示。Pandas之所以提供多种数据结构，其目的就是为了代码易读、操作更加方便。 3.2 创建一个DataFrame对象创建DataFrame主要使用Pandas的DataFrame()方法，语法如下： 1pandas.DataFrame(data,index,columns,dtype,copy) 参数说明： data：表示数据，可以是ndarray数组、Series对象、列表、字典等。 index：表示行标签（索引）。 columns：列标签（索引）。 dtype：每一列数据的数据类型，其与Python数据类型有所不同，如object数据类型对应的是Python的字符型。 表3.1为Pandas数据类型与Python数据类型的对应表。 category作业，查询datetime64,timedela[ns],category Timedelta在pandas中是一个表示两个datetime值之间的差(如日,秒和微妙)的类型,2个Datetime数据运算相减得出的结果就是一个Timedelta数据类型 ​ 表3.1 数据类型对应表 copy：用于复制数据。 返回值：DataFrame。下面通过两种方法来创建DataFrame，即通过二维数组创建和通过字典创建。 1．通过二维数组创建DataFrame【示例10】 通过二维数组创建成绩表。（示例位置：资源包\\MR\\Code\\03\\10）通过二维数组创建成绩表，包括语文、数学和英语，程序代码如下： 运行程序，控制台输出结果如下： 2．通过字典创建DataFrame通过字典创建DataFrame，需要注意：字典中的value值只能是一维数组或单个的简单数据类型，如果是数组，要求所有数组长度一致；如果是单个数据，则每行都添加相同数据。 【示例11】 通过字典创建成绩表。（示例位置：资源包\\MR\\Code\\03\\11）通过字典创建成绩表，包括语文、数学、英语和班级，程序代码如下： 运行程序，控制台输出结果如下： 上述代码中，“班级”的value值是一个单个数据，所以每一行都添加了相同的数据“高一7班”。 3.3 DataFrame重要属性和函数DataFrame是Pandas一个重要的对象，它的属性和函数很多，下面先简单了解DataFrame的几个重要属性和函数。重要属性介绍如表3.2所示，重要函数介绍如表3.3所示。 ​ 表3.2 重要属性 ​ 表3.3 重要函数 3.4 导入外部数据数据分析首先就要有数据。那么，数据类型有多种，本节介绍如何导入不同类型的外部数据。 3.4.1 导入.xls或.xlsx文件导入.xls或.xlsx文件主要使用Pandas的read_excel()方法，语法如下： 1pandas.read_excel(io,sheet_name=0,header=0,names=None,index_col=None,usecols=None,squeeze=False,dtype=None,engine=None,converters=None,true_values=None,false_values=None,skiprows=None,nrow=None,na_values=None,keep_default_na=True,verbose=False,parse_dates=False,date_parser=None,thousands=None,comment=None,skipfooter=0,conver_float=True,mangle_dupe_cols=True,**kwds) 常用参数说明： io：字符串，.xls或.xlsx文件路径或类文件对象。 sheet_name：None、字符串、整数、字符串列表或整数列表，默认值为0。字符串用于工作表名称，整数为索引表示工作表位置，字符串列表或整数列表用于请求多个工作表，为None时获取所有工作表。参数值如表3.4所示。 ​ 表3.4 sheet_name参数值 header：指定作为列名的行，默认值为0，即取第一行的值为列名。数据为除列名以外的数据；若数据不包含列名，则设置header&#x3D;None。 names：默认值为None，要使用的列名列表。 index_col：指定列为索引列，默认值为None，索引0是DataFrame的行标签。 usecols：int、list列表或字符串，默认值为None。 如果为None，则解析所有列。 如果为int，则解析最后一列。 如果为list列表，则解析列号列表的列。 如果为字符串，则表示以逗号分隔的Excel列字母和列范围列表（例如“A:E”或“A,C,E:F”）。范围包括双方。 squeeze：布尔值，默认值为False，如果解析的数据只包含一列，则返回一个Series。 dtype：列的数据类型名称或字典，默认值为None。例如{‘a’:np.float64,’b’:np.int32}。 skiprows：省略指定行数的数据，从第一行开始。 skipfooter：省略指定行数的数据，从尾部数的行开始。 下面通过示例，详细介绍如何导入.xlsx文件。 1．常规导入导入Excel文件。【示例12】 （示例位置：资源包\\MR\\Code\\03\\12）导入“1月.xlsx”Excel文件，程序代码如下： 123import pandas as pddf=pd.read_excel(&#x27;1 月.xlsx&#x27;)df1=df.head() #输出前5 条数据 运行程序，输出前5条数据，结果如图3.13所示。图3.13 1月淘宝销售数据（前5条数据） 知识胶囊导入外部数据，必然要涉及路径问题，下面来了解一下相对路径和绝对路径。 相对路径：相对路径就是以当前文件为基准进行一级级目录指向被引用的资源文件。以下是常用的表示当前目录和当前目录的父级目录的标识符。 ..&#x2F;：表示当前文件所在目录的上一级目录。 .&#x2F;：表示当前文件所在的目录（可以省略）。 &#x2F;：表示当前文件的根目录（域名映射或硬盘目录）。 如果使用系统默认文件路径\\，那么，在Python中则需要在路径最前面加一个r，以避免路径里面的\\被转义。 绝对路径：绝对路径是文件真正存在的路径，是指从硬盘的根目录（盘符）开始，进行一级级目录指向文件。 2．导入指定的Sheet页一个Excel文件包含多个Sheet页，通过设置sheet_name参数就可以导入指定Sheet页的数据。 【示例13】 导入指定Sheet页的数据。（示例位置：资源包\\MR\\Code\\03\\13）一个Excel文件包含多家店铺的销售数据，导入其中一家店铺（莫寒）的销售数据，如图3.14所示。图3.14 原始数据 程序代码如下： 123import pandas as pddf=pd.read_excel(&#x27;1 月.xlsx&#x27;,sheet_name=&#x27;莫寒&#x27;)df1=df.head() #输出前5条数据 运行程序，输出前5条数据，结果如图3.15所示。除了指定Sheet页的名字，还可以指定Sheet页的顺序，从0开始。例如，sheet_name&#x3D;0表示导入第一个Sheet页的数据，sheet_name&#x3D;1表示导入第二个Sheet页的数据，以此类推。如果不指定sheet_name参数，则默认导入第一个Sheet页的数据。 3．通过行、列索引导入指定行、列数据DataFrame是二维数据结构，因此它既有行索引又有列索引。当导入Excel数据时，行索引会自动生成，如0、1、2；而列索引则默认将第0行作为列索引（如A,B,…,J）。DataFrame行、列索引的示意图如图3.16所示。 ​ ​ 图3.15 导入指定的Sheet页（前5条数据） ​ 图3.16 DataFrame行、列索引示意图 【示例14】 指定行索引导入Excel数据。（示例位置：资源包\\MR\\Code\\03\\14）如果通过指定行索引导入Excel数据，则需要设置index_col参数。下面将“买家会员名”作为行索引（位于第0列），导入Excel数据，程序代码如下： 123import pandas as pddf1=pd.read_excel(&#x27;1 月.xlsx&#x27;,index_col=0) #“买家会员名”为行索引df1=df1.head() #输出前5条数据 运行程序，输出结果如图3.17所示。 图3.17 通过指定行索引导入Excel数据如果通过指定列索引导入Excel数据，则需要设置header参数，主要代码如下： 1df2=pd.read_excel(&#x27;1月.xlsx&#x27;,header=1) #设置第1行为列索引 运行程序，输出结果如图3.18所示。如果将数字作为列索引，可以设置header参数为None，主要代码如下： 1df3=pd.read_excel(&#x27;1月.xlsx&#x27;,header=None) #列索引为数字 运行程序，输出结果如图3.19所示。 图3.18 通过指定列索引导入Excel数据 图3.19 指定列索引那么，为什么要指定索引呢？因为通过索引可以快速地检索数据，例如df3[0]，就可以快速检索到“买家会员名”这一列数据。 4.导入指定列数据一个Excel往往包含多列数据，如果只需要其中的几列，可以通过usecols参数指定需要的列，从0开始（表示第1列，以此类推）。 【示例15】 导入第1列数据。（示例位置：资源包\\MR\\Code\\03\\15）下面导入第1列数据（索引为0），程序代码如下： 123import pandas as pddf1=pd.read_excel(&#x27;1 月.xlsx&#x27;,usecols=[0]) #导入第1列df1.head() 运行程序，输出结果如图3.20所示。如果导入多列，可以在列表中指定多个值。例如，导入第1列和第4列，主要代码如下： 1df2=pd.read_excel(&#x27;1月.xlsx&#x27;,usecols=[0,3]) 也可以指定列名称，主要代码如下： 1df3=pd.read_excel(&#x27;1月.xlsx&#x27;,usecols=[&#x27;买家会员名&#x27;,&#x27;宝贝标题&#x27;]) 运行程序，输出结果如图3.21所示。 ​ 图3.20 导入第1列 ​ 图3.21 导入第1列和第4列数据 3.4.2 导入.csv文件导入.csv文件主要使用Pandas的read_csv()方法，语法如下： 常用参数说明： filepath_or_buffer：字符串，文件路径，也可以是URL链接。 sep、delimiter：字符串，分隔符。 header：指定作为列名的行，默认值为0，即取第1行的值为列名。数据为除列名以外的数据；若数据不包含列名，则设置header&#x3D;None。 names：默认值为None，要使用的列名列表。 index_col：指定列为索引列，默认值为None，索引0是DataFrame的行标签。 usecols：int、list列表或字符串，默认值为None。 如果为None，则解析所有列。 如果为int，则解析最后一列。 如果为list列表，则解析列号列表的列。 如果为字符串，则表示以逗号分隔的Excel列字母和列范围列表（例如“A:E”或“A,C,E:F”）。范围包括双方。 dtype：列的数据类型名称或字典，默认值为None。例如{‘a’:np.float64,’b’:np.int32}。 parse_dates：布尔类型值、int类型值的列表、列表或字典，默认值为False。可以通过parse_dates参数直接将某列转换成datetime64日期类型。例如，df1&#x3D;pd.read_csv(‘1月.csv’, parse_dates&#x3D;[‘订单付款时间’])。 ​ parse_dates为True时，尝试解析索引。 ​ parse_dates为int类型值组成的列表时，如[1,2,3]，则解析1、2、3列的值作为独立的日期列。 ​ parse_date为列表组成的列表，如[[1,3]]，则将1、3列合并，作为一个日期列使用。 ​ parse_date为字典时，如{‘总计’：[1, 3]}，则将1、3列合并，合并后的列名为“总计”。 encoding：字符串，默认值为None，文件的编码格式。Python常用的编码格式是UTF-8。 返回值：返回一个DataFrame。 【示例16】 导入.csv文件。（示例位置：资源包\\MR\\Code\\03\\16）导入.csv文件，程序代码如下： 123import pandas as pddf1=pd.read_csv(&#x27;1月.csv&#x27;**,encoding=**&#x27;gbk&#x27;) #导入.csv文件，并指定编码格式df1=df1.head() #输出前5条数据 运行程序，输出结果如图3.22所示。 ​ 图3.22 导入.csv文件 注意上述代码中指定了编码格式，即encoding&#x3D;’gbk’。Python常用的编码格式是UTF-8和gbk，默认编码格式为UTF-8。导入.csv文件时，需要通过encoding参数指定编码格式。当将Excel文件另存为.csv文件时，默认编码格式为gbk，此时当编写代码导入.csv文件时，就需要设置编码格式为gbk，与源文件编码格式保持一致；否则会提示错误。 3.4.3 导入.txt文本文件导入.txt文件同样使用Pandas的read_csv()方法，不同的是需要指定sep参数（如制表符\\t）。read_csv()方法读取.txt文件返回一个DataFrame，像表格一样的二维数据结构，如图3.23所示。 【示例17】 导入.txt文件。（示例位置：资源包\\MR\\Code\\03\\17）下面使用read_csv()方法导入1月.txt文件，主要代码如下： 123import pandas as pddf1=pd.read_csv(&#x27;1月.txt&#x27;,sep=&#x27;\\t&#x27;,encoding=&#x27;gbk&#x27;)print(df1.head()) 运行程序，输出结果如图3.24所示。 ​ 图3.23 .txt文件形式 ​ 图3.24 导入.txt文本 3.4.4 导入HTML网页导入HTML网页数据主要使用Pandas的read_html()方法，该方法用于导入带有table标签的网页表格数据，语法如下： 1pandas.read_html(io,match=&#x27;.+&#x27;,flavor=None,header=None,index_col=None,skiprows=None,attrs=None,parse_dates=False,thousands=&#x27;,&#x27;,encoding=None,decimal=&#x27;.&#x27;,converters=None,na_values=None,keep_default_na=True,displayed_only=True) 常用参数说明： io：字符串，文件路径，也可以是URL链接。网址不接受https，可以尝试去掉https中的s后爬取，如http://www.mingribook.com。 match：正则表达式，返回与正则表达式匹配的表格。 flavor：解析器默认为lxml。 header：指定列标题所在的行，列表list为多重索引。 index_col：指定行标题对应的列，列表list为多重索引。 encoding：字符串，默认为None，文件的编码格式。 返回值：返回一个DataFrame。使用read_html()方法前，首先要确定网页表格是否为table类型。例如，NBA球员薪资网页（http://www.espn.com/nba/salaries），右击该网页中的表格，在弹出的快捷菜单中选择“检查元素”命令，查看代码中是否含有表格标签…的字样，如图3.25所示。确定后才可以使用read_html()方法。 ​ 图3.25 …表格标签 【示例18】 导入NBA球员薪资数据。（示例位置：资源包\\MR\\Code\\03\\18）下面使用read_html()方法导入NBA球员薪资数据，程序代码如下： 运行程序，输出结果如图3.26所示。 ​ 图3.26 导入网页数据注意运行程序，如果出现ImportError: lxml not found, please install it错误提示信息，则需要安装lxml模块。 3.5 数据抽取数据分析过程中，并不是所有的数据都是我们想要的，此时可以抽取部分数据，主要使用DataFrame对象的loc属性和iloc属性，示意图如图3.27所示。 图3.27 loc属性和iloc属性示意图 对象的loc属性和iloc属性都可以抽取数据，区别如下。 loc属性：以列名（columns）和行名（index）作为参数，当只有一个参数时，默认是行名，即抽取整行数据，包括所有列，如df.loc[‘A’]。 iloc属性：以行和列位置索引（即0，1，2，…)作为参数，0表示第1行，1表示第2行，以此类推。当只有一个参数时，默认是行索引，即抽取整行数据，包括所有列。如抽取第1行数据，df.iloc[0]。 3.5.1 抽取一行数据抽取一行数据主要使用loc属性。【 示例19】 抽取一行考试成绩数据。（示例位置：资源包\\MR\\Code\\03\\19）抽取一行名为“明日”的考试成绩数据（包括所有列），程序代码如下： 运行程序，输出结果如图3.28所示。使用iloc属性抽取第1行数据，指定行索引即可，如df.iloc[0]，输出结果同图3.28一样。 [1,2,2,3] [[1,2,3,4]] ​ 图3.28 抽取一行数据 3.5.2 抽取多行数据1．抽取任意多行数据通过loc属性和iloc属性指定行名和行索引即可实现抽取任意多行数据。 【示例20】 抽取多行考试成绩数据。（示例位置：资源包\\MR\\Code\\03\\20）抽取行名为“明日”和“高袁圆”（即第1行和第3行数据）的考试成绩数据，可以使用loc属性，也可以使用iloc属性，其输出结果都是一样的，主要代码如下： 12df1=df.loc[[&#x27;明日&#x27;,&#x27;高袁圆&#x27;]]df1=df.iloc[[0,2]] 运行程序，输出结果如图3.29所示。 ​ 图3.29 抽取多行数据2．抽取连续任意多行数据在loc属性和iloc属性中合理地使用冒号（:），即可抽取连续任意多行数据。 【示例21】 抽取连续几个学生的考试成绩。（示例位置：资源包\\MR\\Code\\03\\21）抽取连续几个学生的考试成绩，主要代码如下： 运行程序，控制台输出结果如图3.30所示。 ​ 图3.30 抽取连续任意多行数据 3.5.3 抽取指定列数据抽取指定列数据，可以直接使用列名，也可以使用loc属性和iloc属性。1．直接使用列名【示例22】 抽取“语文”和“数学”的考试成绩。（示例位置：资源包\\MR\\Code\\03\\22）抽取列名为“语文”和“数学”的考试成绩数据，程序代码如下： 运行程序，输出结果如图3.31所示。 2．使用loc属性和iloc属性前面介绍loc属性和iloc属性均有两个参数：第一个参数代表行；第二个参数代表列。那么这里抽取指定列数据时，行参数不能省略。 【示例23】 抽取指定学科的考试成绩。（示例位置：资源包\\MR\\Code\\03\\23）下面使用loc属性和iloc属性抽取指定列数据，主要代码如下： 运行程序，控制台输出结果如图3.32所示。 ​ 图3.31 直接使用列名 ​ 图3.32 loc属性和iloc属性 3.5.4 抽取指定行、列数据抽取指定行、列数据主要使用loc属性和iloc属性，这两个方法的两个参数都指定就可以实现指定行、列数据的抽取。 【示例24】 抽取指定学科和指定学生的考试成绩。（示例位置：资源包\\MR\\Code\\03\\24）使用loc属性和iloc属性抽取指定行、列数据，程序代码如下： 运行程序，控制台输出结果如图3.33所示。 图3.33 抽取指定行、列数据 在上述结果中，第一个输出结果是一个数，不是数据，是由于“df.loc[‘七月流火’,’英语’]”没有使用方括号[]，导致输出的数据不是DataFrame类型。 3.5.5 按指定条件抽取数据DataFrame对象实现数据查询有以下3种方式。 取其中的一个元素.iat[x,x]。 基于位置的查询，如.iloc[]、iloc[2,1]。 基于行、列名称的查询，如.loc[x]。 【示例25】 抽取指定学科和指定分数的数据。（示例位置：资源包\\MR\\Code\\03\\25）抽取语文成绩大于105，数学成绩大于88的数据，程序代码如下： 运行程序，输出结果如图3.34所示。 ​ 图3.34 按指定条件抽取数据 3.6 数据的增加、修改和删除本节主要介绍如何操纵DataFrame对象中的各种数据。例如，数据的增加、修改和删除。 3.6.1 增加数据DataFrame对象增加数据主要包括列数据增加和行数据增加。首先看一下原始数据，如图3.35所示。 图3.35 原始数据 1．按列增加数据按列增加数据，可以通过以下3种方式实现。（1）直接为DataFrame对象赋值 【示例26】 增加一列“物理”成绩。（示例位置：资源包\\MR\\Code\\03\\26）增加一列“物理”成绩，程序代码如下： 运行程序，输出结果如图3.36所示。 ​ 图3.36 按列增加数据（2）使用loc属性在DataFrame对象的最后增加一列 【示例27】 使用loc属性增加一列“物理”成绩。（示例位置：资源包\\MR\\Code\\03\\27）使用loc属性在DataFrame对象的最后增加一列。例如，增加“物理”一列，主要代码如下： 1df.loc[:,&#x27;物理&#x27;] = [88,79,60,50] 在DataFrame对象最后增加一列“物理”，其值为等号右边数据。 （3）在指定位置插入一列在指定位置插入一列，主要使用insert()方法。 【示例28】 在第1列后面插入“物理”成绩。（示例位置：资源包\\MR\\Code\\03\\28）例如，在第1列后面插入“物理”，其值为wl的数值，主要代码如下： 12wl =[88,79,60,50]df.insert(1,&#x27;物理&#x27;,wl) 运行程序，输出结果如图3.37所示。 ​ 图3.37 使用insert()方法增加一列 2．按行增加数据按行增加数据，可以通过以下两种方式实现。（1）增加一行数据增加一行数据主要使用loc属性实现。 【示例29】 在成绩表中增加一行数据。（示例位置：资源包\\MR\\Code\\03\\29）在成绩表中增加一行数据，即“钱多多”同学的成绩，主要代码如下： 1df.loc[&#x27;钱多多&#x27;] = [100,120,99] （2）增加多行数据 增加多行数据主要使用字典结合**append()**方法实现。 【示例30】 在原有数据中增加几名同学的考试成绩。（示例位置：资源包\\MR\\Code\\03\\30）在原有数据中增加“钱多多”“童年”“无名”同学的考试成绩，主要代码如下： 12df_insert=pd.DataFrame(&#123;&#x27;语文&#x27;:[100,123,138],&#x27;数学&#x27;:[99,142,60],&#x27;英语&#x27;:[98,139,99]&#125;,index = [&#x27;钱多多&#x27;,&#x27;童年&#x27;,&#x27;无名&#x27;])df1 = df.append(df_insert) 运行程序，输出结果分别如图3.38和图3.39所示。 ​ 图3.38 增加一行数据 ​ 图3.39 增加多行数据 3.6.2 修改数据修改数据包括行、列标题和数据的修改，首先看一下原始数据，如图3.40所示。 ​ 图3.40 原始数据 1．修改列标题修改列标题主要使用DataFrame对象的cloumns属性，直接赋值即可。 【示例31】 修改“数学”的列名。（示例位置：资源包\\MR\\Code\\03\\31）将“数学”修改为“数学（上）”，主要代码如下： 1df.columns=[&#x27;语文&#x27;,&#x27;数学（上）&#x27;,&#x27;英语&#x27;] 上述代码中，即使只修改“数学”为“数学（上）”，但是也要将所有列的标题全部写上；否则将报错。下面再介绍一种方法，使用DataFrame对象的rename()方法修改列标题。 【示例32】 修改多个学科的列名。（示例位置：资源包\\MR\\Code\\03\\32）将“语文”修改为“语文（上）”、“数学”修改为“数学（上）”、“英语”修改为“英语（上）”，主要代码如下： 1df.rename(columns = &#123;&#x27;语文&#x27;:&#x27;语文（上）&#x27;,&#x27;数学&#x27;:&#x27;数学（上）&#x27;,&#x27;英语&#x27;:&#x27;英语（上）&#x27;&#125;,inplace = True) 上述代码中，参数inplace为True，表示直接修改df；否则，不修改df，只返回修改后的数据。运行程序，输出结果分别如图3.41和图3.42所示。 2．修改行标题修改行标题主要使用DataFrame对象的index属性，直接赋值即可。 【示例33】 将行标题统一修改为数字编号。（示例位置：资源包\\MR\\Code\\03\\33）将行标题统一修改为数字编号，主要代码如下： 1df.index=list(&#x27;1234&#x27;) ​ 图3.41 修改列标题1 ​ 图3.42 修改列标题2 使用DataFrame对象的rename()方法也可以修改行标题。例如，将行标题统一修改为数字编号，主要代码如下： 1df.rename(&#123;&#x27;明日&#x27;:1,&#x27;七月流火&#x27;:2,&#x27;高袁圆&#x27;:3,&#x27;二月二&#x27;:4&#125;,axis=0,inplace = True) 3．修改数据修改数据主要使用DataFrame对象的loc属性和iloc属性。 【示例34】 修改学生成绩数据。（示例位置：资源包\\MR\\Code\\03\\34）（1）修改整行数据例如，修改“明日”同学的各科成绩，主要代码如下： 1df.loc[&#x27;明日&#x27;]=[120,115,109] 如果各科成绩均加10分，可以直接在原有值上加10，主要代码如下： 1df.loc[&#x27;明日&#x27;]=df.loc[&#x27;明日&#x27;]+10 （2）修改整列数据例如，修改所有同学的“语文”成绩，主要代码如下： 1df.loc[:,&#x27;语文&#x27;]=[115,108,112,118] （3）修改某一数据 例如，修改“明日”同学的“语文”成绩，主要代码如下： 1df.loc[&#x27;明日&#x27;,&#x27;语文&#x27;]=115 （4）使用iloc属性修改数据通过iloc属性指定行、列位置实现修改数据，主要代码如下： 123df.iloc[0,0]=115 #修改某一数据df.iloc[:,0]=[115,108,112,118] #修改整列数据df.iloc[0,:]=[120,115,109] #修改整行数据 3.6.3 删除数据删除数据主要使用DataFrame对象的drop()方法。语法如下： 1DataFrame.drop(labels=None, axis=0, index=None, columns=None, level=None, inplace=False, errors=&#x27;raise&#x27;) 参数说明： labels：表示行标签或列标签。 axis：axis &#x3D; 0，表示按行删除； ​ axis &#x3D; 1，表示按列删除。默认值为0，即按行删除。 index：删除行，默认值为None。 columns：删除列，默认值为None。 level：针对有两级索引的数据。level &#x3D; 0，表示按第1级索引删除整行；level &#x3D; 1表示按第2级索引删除整行，默认值为None。 inplace：可选参数，对原数组做出修改并返回一个新数组。默认值为False，如果值为True，那么原数组直接就被替换。 errors：参数值为ignore或raise，默认值为raise，如果值为ignore（忽略），则取消错误。 1．删除行、列数据【示例35】 删除学生成绩数据。（示例位置：资源包\\MR\\Code\\03\\35）删除指定的学生成绩数据，主要代码如下： 2．删除特定条件的行删除满足特定条件的行，首先找到满足该条件的行索引，然后再使用drop()方法将其删除。 【示例36】 删除符合条件的学生成绩数据。（示例位置：资源包\\MR\\Code\\03\\36）删除“数学”成绩中包含88的行、“语文”成绩中小于110的行，主要代码如下： 12df.drop(index=df[df[&#x27;数学&#x27;].**isin**([88])].index[0],inplace=True) #删除“数学”成绩中包含88的行df.drop(index=df[df[&#x27;语文&#x27;]&lt;110].index[0],inplace=True) #删除“语文”成绩中小于110的行说明 以上代码中的方法都可以实现删除指定的行、列数据，读者选择一种即可。 3.7 数据清洗3.7.1 缺失值查看与处理缺失值是指由于某种原因导致数据为空，这种情况一般有不处理、删除、填充／替换、插值（以均值／中位数／众数等填补）这4种处理方式。 1．缺失值查看首先需要找到缺失值，主要使用DataFrame对象的info()方法。 【示例37】 查看数据概况。（示例位置：资源包\\MR\\Code\\03\\37）以淘宝销售数据为例，首先输出数据，然后使用info()方法查看数据，程序代码如下： 1234import pandas as pddf=pd.read_excel(&#x27;TB2018.xls&#x27;)print(df)print(df.info()) 运行程序，控制台输出结果如图3.43所示。 图3.43 缺失值查看在Python中，缺失值一般用NaN表示，如图3.43所示。通过info()方法可看到“买家会员名”“买家实际支付金额”“宝贝标题”“订单付款时间”的非空数量是10，而“宝贝总数量”和“类别”的非空数量是8，那么说明这两项存在空值。 【示例38】 判断数据是否存在缺失值。（示例位置：资源包\\MR\\Code\\03\\38）接下来，判断数据是否存在缺失值还可以使用isnull()方法和notnull()方法，主要代码如下： 12print(df.isnull())print(df.notnull()) 运行程序，控制台输出结果如图3.44所示。 ​ 图3.44 判断缺失值使用isnull()方法缺失值返回True，非缺失值返回False；而notnull()方法与isnull()方法正好相反，缺失值返回False，非缺失值返回True。如果使用df[df.isnull() &#x3D;&#x3D; False]， 则会将所有非缺失值的数据找出来，只针对Series对象。 2．缺失值删除处理通过前面的判断得知数据缺失情况，下面将缺失值删除，主要使用dropna()方法，该方法用于删除含有缺失值的行，主要代码如下： df1&#x3D;df.dropna()运行程序，输出结果如图3.45所示。说明有些时候数据可能存在整行为空的情况，此时可以在dropna()方法中指定参数how&#x3D;’all’，删除所有空行。 ​ 图3.45 缺失值删除处理1从运行结果得知：dropna()方法将所有包含缺失值的数据全部删除了。那么，此时如果我们认为有些数据虽然存在缺失值，但是不影响数据分析，那么可以使用以下方法处理。例如，上述数据中只保留“宝贝总数量”不存在缺失值的数据，而类别是否缺失不关注，则可以使用notnull()方法判断，主要代码如下： df2&#x3D;df[df[‘宝贝总数量’].notnull()]运行程序，输出结果如图3.46所示。 图3.46 缺失值删除处理2 3．缺失值填充处理对于缺失数据，如果比例高于30%可以选择放弃这个指标，做删除处理；低于30%尽量不要删除，而是选择将这部分数据填充，一般以0、均值、众数（大多数）填充。DataFrame对象中的fillna()函数可以实现填充缺失数据，pad&#x2F;ffill表示用前一个非缺失值去填充该缺失值；backfill&#x2F;bfill表示用下一个非缺失值填充该缺失值；None用于指定一个值去替换缺失值。 【示例39】 将NaN填充为0。（示例位置：资源包\\MR\\Code\\03\\39）对于用于计算的数值型数据如果为空，可以选择用0填充。例如，将“宝贝总数量”为空的数据填充为0，主要代码如下： df[‘宝贝总数量’] &#x3D; df[‘宝贝总数量’].fillna(0)运行程序，输出结果如图3.47所示。 ​ 图3.47 缺失值填充处理 3.7.2 重复值处理对于数据中存在的重复数据，包括重复的行或者几行中某几列的值重复一般做删除处理，主要使用DataFrame对象的drop_duplicates()方法。 【示例40】 处理淘宝电商销售数据中的重复数据。（示例位置：资源包\\MR\\Code\\03\\40）下面以“1月.xlsx”淘宝销售数据为例，对其中的重复数据进行处理。（1）判断每一行数据是否重复（完全相同），主要代码如下： 1df1.duplicated() 如果返回值为False表示不重复，返回值为True表示重复。（2）去除全部的重复数据，主要代码如下： 1df1.drop_duplicates() （3）去除指定列的重复数据，主要代码如下： 1df1.drop_duplicates([&#x27;买家会员名&#x27;]) （4）保留重复行中的最后一行，主要代码如下： 1df1.drop_duplicates([&#x27;买家会员名&#x27;],keep=&#x27;last&#x27;) 说明:以上代码中参数keep的值有3个。当keep&#x3D;’first’表示保留第一次出现的重复行，是默认值；当keep为另外两个取值，即last和False时，分别表示保留最后一次出现的重复行和去除所有重复行。（5）直接删除，保留一个副本，主要代码如下： 1df1.drop_duplicates([&#x27;买家会员名&#x27;,&#x27;买家支付宝账号&#x27;],inplace=Fasle) inplace&#x3D;True表示直接在原来的DataFrame上删除重复项，而默认值False表示删除重复项后生成一个副本。 3.7.3 异常值的检测与处理首先了解一下什么是异常值。在数据分析中异常值是指超出或低于正常范围的值，如年龄大于200、身高大于3米、宝贝总数量为负数等类似数据。那么这些数据如何检测呢？主要有以下几种方法。（1）根据给定的数据范围进行判断，不在范围内的数据视为异常值。（2）均方差。在统计学中，如果一个数据分布近似正态分布（数据分布的一种形式，正态分布的概率密度函数曲线呈钟形，两头低、中间高、左右对称，因此人们又经常称之为钟形曲线），那么大约68%的数据值会在均值的一个标准差范围内，大约95%会在两个标准差范围内，大约99.7%会在3个标准差范围内。（3）箱形图。箱形图是显示一组数据分散情况资料的统计图。它可以将数据通过四分位数的形式进行图形化描述。箱形图通过上限和下限作为数据分布的边界。任何高于上限或低于下限的数据都可以认为是异常值，如图3.48所示。 ​ 图3.48 箱形图说明有关箱形图的介绍以及如何通过箱形图识别异常值可参见第6章。了解了异常值的检测，接下来介绍如何处理异常值，主要包括以下几种处理方式。（1）最常用的方式是删除。（2）将异常值当缺失值处理，以某个值填充。（3）将异常值当特殊情况进行分析，研究异常值出现的原因。 3.8 索引设置索引能够快速查询数据，本节主要介绍索引的作用以及索引的应用。 3.8.1 索引的作用索引的作用相当于图书的目录，可以根据目录中的页码快速找到所需的内容。Pandas索引的作用如下。 更方便查询数据。 使用索引可以提升查询性能。 如果索引是唯一的，Pandas会使用哈希表优化，查找数据的时间复杂度为O(1)。 如果索引不是唯一的，但是有序，Pandas会使用二分查找算法，查找数据的时间复杂度为O(logN)。 如果索引是完全随机的，那么每次查询都要扫描数据表，查找数据的时间复杂度为O(N)。 自动的数据对齐功能，示意图如图3.49所示。 ​ 图3.49 自动数据对齐示意图实现上述效果，程序代码如下： 1234import pandas as pds1 = pd.Series([10,20,30],index= list(&quot;abc&quot;))s2 = pd.Series([2,3,4],index=list(&quot;bcd&quot;))print(s1 + s2) 基于分类数的索引，提升性能。 多维索引，用于groupby多维聚合结果等。 时间类型索引，强大的日期和时间的方法支持。 3.8.2 重新设置索引Pandas有一个很重要的方法是reindex()，它的作用是创建一个适应新索引的新对象。语法如下： 1DataFrame.reindex(labels = None,index = None,columns = None,axis = None,method = None,copy = True,level = None,fill_value = nan,limit = None,tolerance = None) 常用参数说明： labels：标签，可以是数组，默认值为None（无）。 index：行索引，默认值为None。 columns：列索引，默认值为None。 axis：轴，axis&#x3D;0表示行，axis&#x3D;1表示列。默认值为None。 method：默认值为None，重新设置索引时，选择插值（一种填充缺失数据的方法）方法，其值可以是None、bfill&#x2F;backfill（向后填充）、ffill&#x2F;pad（向前填充）等。 fill_value：缺失值要填充的数据。如缺失值不用NaN填充，而用0填充，则设置fill_value&#x3D;0即可。 1．对Series对象重新设置索引【示例41】 重新设置物理成绩的索引。（示例位置：资源包\\MR\\Code\\03\\41）在3.2.3节已经建立了一组学生的物理成绩，下面重新设置索引，程序代码如下： 1234import pandas as pds1=pd.Series([88,60,75],index=[1,2,3])print(s1)print(s1.reindex([1,2,3,4,5])) 运行程序，控制台输出结果对比如图3.50和图3.51所示。 ​ 图3.50 原数据 ​ 图3.51 重新设置索引从运行结果得知：reindex()方法根据新索引进行了重新排序，并且对缺失值自动填充NaN。如果不想用NaN填充，则可以为fill_value参数指定值，如0，主要代码如下： s1.reindex([1,2,3,4,5],fill_value&#x3D;0)而对于一些有一定顺序的数据，我们可能需要插值（插值是一种填充缺失数据的方法）来填充缺失的数据，可以使用method参数。 【示例42】 向前和向后填充数据。（示例位置：资源包\\MR\\Code\\03\\42）向前填充（和前面数据一样）、向后填充（和后面数据一样），主要代码如下： 12print(s1.reindex([1,2,3,4,5],method=&#x27;ffill&#x27;)) #向前填充print(s1.reindex([1,2,3,4,5],method=&#x27;bfill&#x27;)) #向后填充 2．对DataFrame对象重新设置索引对于DataFrame对象，reindex()方法用于修改行索引和列索引。 【示例43】 创建成绩表并重新设置索引。（示例位置：资源包\\MR\\Code\\03\\43）通过二维数组创建成绩表，程序代码如下： 通过reindex()方法重新设置行索引，主要代码如下： 1df.reindex([&#x27;mr001&#x27;,&#x27;mr002&#x27;,&#x27;mr003&#x27;,&#x27;mr004&#x27;,&#x27;mr005&#x27;]) 通过reindex()方法重新设置列索引，主要代码如下： 1df.reindex(columns=[&#x27;语文&#x27;,&#x27;物理&#x27;,&#x27;数学&#x27;,&#x27;英语&#x27;]) 通过reindex()方法重新设置行索引和列索引，主要代码如下： 1df.reindex(index=[&#x27;mr001&#x27;,&#x27;mr002&#x27;,&#x27;mr003&#x27;,&#x27;mr004&#x27;,&#x27;mr005&#x27;],columns=[&#x27;语文&#x27;,&#x27;物理&#x27;,&#x27;数学&#x27;,&#x27;英语&#x27;]) 运行程序，控制台输出结果分别为原始数据（见图3.52）、重新设置行索引（见图3.53）、重新设置列索引（见图3.54）、重新设置行、列索引（见图3.55）。 ​ 图3.52 原始数据 ​ 图3.53 重新设置行索引 ​ 图3.54 重新设置列索引 3.8.3 设置某列为行索引设置某列为行索引主要使用set_index()方法。 【示例44】 设置“买家会员名”为行索引。（示例位置：资源包\\MR\\Code\\03\\44）首先，导入“1月.xlsx”Excel文件，程序代码如下： 运行程序，输出结果如图3.56所示。此时默认行索引为0、1、2、3、4，下面将“买家会员名”作为行索引，主要代码如下： 1df2=df.set_index([&#x27;买家会员名&#x27;]) 运行程序，输出结果如图3.57所示。 ​ 图3.56 1月淘宝销售数据（部分数据） ​ 图3.57 设置“买家会员名”为索引如果在set_index()方法中传入参数drop&#x3D;True，则会删除“买家会员名”；如果传入drop&#x3D;False，则会保留“买家会员名”。默认为False。 3.8.4 数据清洗后重新设置连续的行索引在对Dataframe对象进行数据清洗后，例如去掉含NaN的行之后，发现行索引还是原来的行索引，对比效果如图3.58和图3.59所示。 ​ 图3.58 原数据 ​ 图3.59 数据清洗后还是原来的索引 【示例45】 删除数据后重新设置索引。（示例位置：资源包\\MR\\Code\\03\\45） 如果要重新设置索引可以使用reset_index()方法，在删除缺失数据后重新设置索引，主要代码如下： 1df2=df.dropna().reset_index(drop=True) 运行程序，输出结果如图3.60所示。 ​ 图3.60 数据清洗后重新设置连续的行索引另外，对于分组统计后的数据，有时也需要重新设置连续的行索引，方法同上。 3.9 数据排序与排名本节主要介绍数据的各种排序和排名方法。 3.9.1 数据排序DataFrame数据排序主要使用sort_values()方法，该方法类似于SQL中的ORDER BY。sort_values()方法可以根据指定行／列进行排序，语法如下： 1DataFrame.sort_values(by,axis=0,ascending=True,inplace=False,kind=&#x27;quicksort&#x27;,na_position=&#x27;last&#x27;,ignore_index=False) 参数说明： by：要排序的名称列表。 axis：轴，axis&#x3D;0表示行，axis&#x3D;1表示列。默认值为0，即按行排序。 ascending：升序或降序排序，布尔值，指定多个排序可以使用布尔值列表。默认值为True。 inplace：布尔值，默认值为False，如果值为True，则就地排序。 kind：指定排序算法，值为quicksort（快速排序）、mergesort（混合排序）或heapsort（堆排），默认值为quicksort。 na_position：空值（NaN）的位置，值为first空值在数据开头，值为last空值在数据最后，默认值为last。 ignore_index：布尔值，是否忽略索引，值为True标记索引（从0开始按顺序的整数值），值为False则忽略索引。 1．按一列数据排序【示例46】 按“销量”降序排序。（示例位置：资源包\\MR\\Code\\03\\46）按“销量”降序排序，排序对比效果如图3.61和图3.62所示。 ​ 图3.61 原始数据 ​ 图3.62 按“销量”降序排序实用技巧Spyder变量浏览窗口本身也支持数据排序，单击需要排序的列即可实现升序或降序排序。程序代码如下： 2．按多列数据排序多列排序是按照给定列的先后顺序进行排序的。 【示例47】 按照“图书名称”和“销量”降序排序。（示例位置：资源包\\MR\\Code\\03\\47）按照“图书名称”和“销量”降序排序，首先按“图书名称”降序排序，然后再按“销量”降序排序，排序后的效果如图3.63所示。 ​ 图3.63 按照“图书名称”和“销量”降序排序主要代码如下： 1df1=df.sort_values(by=[&#x27;图书名称&#x27;,&#x27;销量&#x27;]) 3．对统计结果排序【示例48】 对分组统计数据进行排序。（示例位置：资源包\\MR\\Code\\03\\48） 按“类别”分组统计销量并进行降序排序，统计排序后的效果如图3.64所示。 ​ 图3.64 按“类别”分组统计销量并降序排序主要代码如下： 123df1=df.groupby([&quot;类别&quot;])[&quot;销量&quot;].sum().reset_index()df2=df1.sort_values(by=&#x27;销量&#x27;,ascending=False) 4．按行数据排序【示例49】 按行数据排序。（示例位置：资源包\\MR\\Code\\03\\49）按行排序，主要代码如下： df&#x3D;dfrow.sort_values(by&#x3D;0,ascending&#x3D;True,axis&#x3D;1)注意按行排序的数据类型要一致，否则会出现错误提示。 3.9.2 数据排名排名是根据Series对象或DataFrame的某几列的值进行排名的，主要使用rank()方法，语法如下： DataFrame.rank(axis&#x3D;0,method&#x3D;’average’,numeric_only&#x3D;None,na_option&#x3D;’keep’,ascending&#x3D;True,pct&#x3D;False)参数说明： axis：轴，axis&#x3D;0表示行，axis&#x3D;1表示列。默认值为0，即按行排序。 method：表示在具有相同值的情况下所使用的排序方法。设置值如下。 average：默认值，平均排名。 min：最小值排名。 max：最大值排名。 first：按值在原始数据中的出现顺序分配排名。 dense：密集排名，类似最小值排名，但是排名每次只增加1，即排名相同的数据只占一个名次。 numeric_only：对于DataFrame对象，如果设置值为True，则只对数字列进行排序。 na_option：空值的排序方式，设置值如下。 keep：保留，将空值等级赋值给NaN值。 top：如果按升序排序，则将最小排名赋值给NaN值。 bottom：如果按升序排序，则将最大排名赋值给NaN值。 ascending：升序或降序排序，布尔值，指定多个排序可以使用布尔值列表。默认值为True。 pct：布尔值，是否以百分比形式返回排名。默认值为False。 1．顺序排名 【示例50】 对产品销量按顺序进行排名。（示例位置：资源包\\MRCode\\03\\50）下面对销量相同的产品，按照出现的顺序排名，程序代码如下： 程序运行结果如图3.65所示。2．平均排名 【示例51】 对产品销量进行平均排名。（示例位置：资源包\\MR\\Code\\03\\51）现在对销量相同的产品，按照顺序排名的平均值作为平均排名，主要代码如下： 01 df[‘平均排名’]&#x3D;df[‘销量’].rank(ascending&#x3D;False) 02 df1&#x3D;df[[‘图书名称’,’销量’,’平均排名’]]程序运行结果如图3.66所示。3．最小值排名排名相同的，按顺序排名取最小值作为排名，主要代码如下： df[‘最小值排名’]&#x3D;df[‘销量’].rank(method&#x3D;”min”,ascending&#x3D;False)4．最大值排名排名相同的，按顺序排名取最大值作为排名，主要代码如下： df[‘最大值排名’]&#x3D;df[‘销量’] rank(method&#x3D;”max”,ascending&#x3D;False) ​ 图3.65 销量相同按出现的先后顺序排名 ​ 图3.66 销量相同按顺序排名的平均值排名 3.10 小结本章介绍了Pandas数据处理的基本知识，从最初的数据来源开始（创建DataFrame数据或导入外部数据）到数据抽取、数据增删改操作、数据清洗、索引，再到数据排序，常用的数据处理操作基本都涉及了，通过本章的学习基本能够独立完成一些简单的数据处理工作。","categories":[{"name":"python","slug":"python","permalink":"http://example.com/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"http://example.com/tags/python/"}]},{"title":"vue响应式原理","slug":"vue响应式原理","date":"2021-05-25T09:28:36.000Z","updated":"2022-05-28T03:19:48.453Z","comments":true,"path":"2021/05/25/vue响应式原理/","link":"","permalink":"http://example.com/2021/05/25/vue%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8E%9F%E7%90%86/","excerpt":"","text":"数据驱动 数据响应式、双向绑定、数据驱动 数据响应式 数据模型仅仅是普通的 JavaScript 对象，而当我们修改数据时，视图会进行更新，避免了繁琐的 DOM 操作提高开发效率 双向绑定 数据改变，视图改变;视图改变，数据也随之改变 我们可以使用 v-model 在表单元素上创建双向数据绑定 数据驱动是Vue最独特的特性之一，MVVM表示的是Model-View-ViewModel 开发过程中仅需要关注数据本身，不需要关心数据是如何渲染到视图 Model：模型层，负责处理业务逻辑以及和服务器端进行交互 View：视图层：负责将数据模型转化为UI展示出来，可以简单的理解为HTML页面 ViewModel：视图模型层，用来连接Model和View，是Model和View之间的通信桥梁 数据响应式的核心原理Vue 2.x 核心是通过 ES5 的保护对象的 Object.defindeProperty 中的访问器属性中的 get 和 set 方法，data 中声明的属性都被添加了访问器属性，当读取 data 中的数据时自动调用 get 方法，当修改 data 中的数据时，自动调用 set 方法，检测到数据的变化，会通知观察者 Wacher，观察者 Wacher自动触发重新render 当前组件（子组件不会重新渲染）,生成新的虚拟 DOM 树，Vue 框架会遍历并对比新虚拟 DOM 树和旧虚拟 DOM 树中每个节点的差别，并记录下来，最后，加载操作，将所有记录的不同点，局部修改到真实 DOM树上 总结：Vue 采用数据劫持结合发布—订阅模式的方法，通过 Object.defineProperty() 来劫持各个属性的 setter，getter，在数据变动时发布消息给订阅者，触发相应的监听回调 Object.defineProperty()，那么它的用法是什么，以及优缺点是什么呢？ 可以检测对象中数据发生的修改 对于复杂的对象，层级很深的话，是不友好的，需要经行深度监听，这样子就需要递归到底，这也是它的缺点。 对于一个对象中，如果你新增加属性，删除属性，Object.defineProperty()是不能观测到的，那么应该如何解决呢？可以通过Vue.set()和Vue.delete()来实现。 1234567891011121314151617181920212223242526272829303132// 模拟 Vue 中的 data 选项 let data = &#123; msg: &#x27;hello&#x27;&#125;// 模拟 Vue 的实例 let vm = &#123;&#125;// 数据劫持:当访问或者设置 vm 中的成员的时候，做一些干预操作Object.defineProperty(vm, &#x27;msg&#x27;, &#123; // 可枚举(可遍历) enumerable: true, // 可配置(可以使用 delete 删除，可以通过 defineProperty 重新定义) configurable: true, // 当获取值的时候执行 get () &#123; console.log(&#x27;get: &#x27;, data.msg) return data.msg &#125;, // 当设置值的时候执行 set (newValue) &#123; console.log(&#x27;set: &#x27;, newValue) if (newValue === data.msg) &#123; return &#125; data.msg = newValue // 数据更改，更新 DOM 的值 document.querySelector(&#x27;#app&#x27;).textContent = data.msg &#125; &#125;)// 测试vm.msg = &#x27;Hello World&#x27; console.log(vm.msg) Vue 3.x Vue3.x改用Proxy替代Object.defineProperty。因为Proxy可以直接监听对象和数组的变化，并且有多达13种拦截方法。并且作为新标准将受到浏览器厂商重点持续的性能优化。 12345678910111213141516171819202122232425262728293031const data = [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;]const proxyData = new Proxy(data, &#123; get(target, key, receiver) &#123; // 只处理本身（非原型的）属性 const ownKeys = Reflect.ownKeys(target) if (ownKeys.includes(key)) &#123; console.log(&#x27;get&#x27;, key) // 监听 &#125; const result = Reflect.get(target, key, receiver) return result // 返回结果 &#125;, set(target, key, val, receiver) &#123; // 重复的数据，不处理 if (val === target[key]) &#123; return true &#125; const result = Reflect.set(target, key, val, receiver) console.log(&#x27;set&#x27;, key, val) // console.log(&#x27;result&#x27;, result) // true return result // 是否设置成功 &#125;, deleteProperty(target, key) &#123; const result = Reflect.deleteProperty(target, key) console.log(&#x27;delete property&#x27;, key) // console.log(&#x27;result&#x27;, result) // true return result // 是否删除成功 &#125;&#125;) Reflect作用： 和proxy能力一一对应 规范化，标准化，函数式 代替Object上的工具函数 12345678910const obj = &#123;a: 100, b: 200&#125;&#x27;a&#x27; in obj //trueReflect.has(obj,&#x27;a&#x27;) //truedelete obj.a //trueReflect.deleteProperty(obj,&#x27;a&#x27;) //trueObject.getOwnPropertyNames(obj) //[&quot;a&quot;,&quot;b&quot;]Reflect.owbKeys(obj) //[&quot;a&quot;,&quot;b&quot;] proxy创建响应式 Proxy只会代理对象的第一层，那么Vue3又是怎样处理这个问题的呢？ 判断当前Reflect.get的返回值是否为Object，如果是则再通过reactive方法做代理， 这样就实现了深度观测。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172// 创建响应式function reactive(target = &#123;&#125;) &#123; if (typeof target !== &#x27;object&#x27; || target == null) &#123; // 不是对象或数组，则返回 return target &#125; // 代理配置 const proxyConf = &#123; get(target, key, receiver) &#123; // 只处理本身（非原型的）属性 const ownKeys = Reflect.ownKeys(target) if (ownKeys.includes(key)) &#123; console.log(&#x27;get&#x27;, key) // 监听 &#125; const result = Reflect.get(target, key, receiver) // 深度监听 // 性能如何提升的？ return reactive(result) &#125;, set(target, key, val, receiver) &#123; // 重复的数据，不处理 if (val === target[key]) &#123; return true &#125; const ownKeys = Reflect.ownKeys(target) if (ownKeys.includes(key)) &#123; console.log(&#x27;已有的 key&#x27;, key) &#125; else &#123; console.log(&#x27;新增的 key&#x27;, key) &#125; const result = Reflect.set(target, key, val, receiver) console.log(&#x27;set&#x27;, key, val) // console.log(&#x27;result&#x27;, result) // true return result // 是否设置成功 &#125;, deleteProperty(target, key) &#123; const result = Reflect.deleteProperty(target, key) console.log(&#x27;delete property&#x27;, key) // console.log(&#x27;result&#x27;, result) // true return result // 是否删除成功 &#125; &#125; // 生成代理对象 const observed = new Proxy(target, proxyConf) return observed&#125;// 测试数据const data = &#123; name: &#x27;zhangsan&#x27;, age: 20, info: &#123; city: &#x27;beijing&#x27;, a: &#123; b: &#123; c: &#123; d: &#123; e: 100 &#125; &#125; &#125; &#125; &#125;&#125;const proxyData = reactive(data) Proxy 相比于 defineProperty 的优势 数组变化也能监听到 不需要深度遍历监听","categories":[{"name":"vue","slug":"vue","permalink":"http://example.com/categories/vue/"}],"tags":[{"name":"vue","slug":"vue","permalink":"http://example.com/tags/vue/"}]},{"title":"ES6新增功能","slug":"ES6新增功能","date":"2018-07-24T01:36:14.000Z","updated":"2022-05-31T03:02:03.136Z","comments":true,"path":"2018/07/24/ES6新增功能/","link":"","permalink":"http://example.com/2018/07/24/ES6%E6%96%B0%E5%A2%9E%E5%8A%9F%E8%83%BD/","excerpt":"","text":"数组新增 一、扩展运算符的应用ES6通过扩展元素符...，好比 rest 参数的逆运算，将一个数组转为用逗号分隔的参数序列 12345678console.log(...[1, 2, 3])// 1 2 3console.log(1, ...[2, 3, 4], 5)// 1 2 3 4 5[...document.querySelectorAll(&#x27;div&#x27;)]// [&lt;div&gt;, &lt;div&gt;, &lt;div&gt;] 主要用于函数调用的时候，将一个数组变为参数序列 12345678910function push(array, ...items) &#123; array.push(...items);&#125;function add(x, y) &#123; return x + y;&#125;const numbers = [4, 38];add(...numbers) // 42 可以将某些数据结构转为数组 1[...document.querySelectorAll(&#x27;div&#x27;)] 能够更简单实现数组复制 123const a1 = [1, 2];const [...a2] = a1;// [1,2] 数组的合并也更为简洁了 12345const arr1 = [&#x27;a&#x27;, &#x27;b&#x27;];const arr2 = [&#x27;c&#x27;];const arr3 = [&#x27;d&#x27;, &#x27;e&#x27;];[...arr1, ...arr2, ...arr3]// [ &#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;, &#x27;e&#x27; ] 注意：通过扩展运算符实现的是浅拷贝，修改了引用指向的值，会同步反映到新数组 下面看个例子就清楚多了 12345const arr1 = [&#x27;a&#x27;, &#x27;b&#x27;,[1,2]];const arr2 = [&#x27;c&#x27;];const arr3 = [...arr1,...arr2]arr[1][0] = 9999 // 修改arr1里面数组成员值console.log(arr[3]) // 影响到arr3,[&#x27;a&#x27;,&#x27;b&#x27;,[9999,2],&#x27;c&#x27;] 扩展运算符可以与解构赋值结合起来，用于生成数组 1234567891011const [first, ...rest] = [1, 2, 3, 4, 5];first // 1rest // [2, 3, 4, 5]const [first, ...rest] = [];first // undefinedrest // []const [first, ...rest] = [&quot;foo&quot;];first // &quot;foo&quot;rest // [] 如果将扩展运算符用于数组赋值，只能放在参数的最后一位，否则会报错 12345const [...butLast, last] = [1, 2, 3, 4, 5];// 报错const [first, ...middle, last] = [1, 2, 3, 4, 5];// 报错 可以将字符串转为真正的数组 12[...&#x27;hello&#x27;]// [ &quot;h&quot;, &quot;e&quot;, &quot;l&quot;, &quot;l&quot;, &quot;o&quot; ] 定义了遍历器（Iterator）接口的对象，都可以用扩展运算符转为真正的数组 12345678910let nodeList = document.querySelectorAll(&#x27;div&#x27;);let array = [...nodeList];let map = new Map([ [1, &#x27;one&#x27;], [2, &#x27;two&#x27;], [3, &#x27;three&#x27;],]);let arr = [...map.keys()]; // [1, 2, 3] 如果对没有 Iterator 接口的对象，使用扩展运算符，将会报错 12const obj = &#123;a: 1, b: 2&#125;;let arr = [...obj]; // TypeError: Cannot spread non-iterable object 二、构造函数新增的方法关于构造函数，数组新增的方法有如下： Array.from() Array.of() Array.from()将两类对象转为真正的数组：类似数组的对象和可遍历（iterable）的对象（包括 ES6 新增的数据结构 Set 和 Map） 1234567let arrayLike = &#123; &#x27;0&#x27;: &#x27;a&#x27;, &#x27;1&#x27;: &#x27;b&#x27;, &#x27;2&#x27;: &#x27;c&#x27;, length: 3&#125;;let arr2 = Array.from(arrayLike); // [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;] 还可以接受第二个参数，用来对每个元素进行处理，将处理后的值放入返回的数组 12Array.from([1, 2, 3], (x) =&gt; x * x)// [1, 4, 9] Array.of()用于将一组值，转换为数组 1Array.of(3, 11, 8) // [3,11,8] 没有参数的时候，返回一个空数组 当参数只有一个的时候，实际上是指定数组的长度 参数个数不少于 2 个时，Array()才会返回由参数组成的新数组 123Array() // []Array(3) // [, , ,]Array(3, 11, 8) // [3, 11, 8] 三、实例对象新增的方法关于数组实例对象新增的方法有如下： copyWithin() find()、findIndex() fill() entries()，keys()，values() includes() flat()，flatMap() copyWithin()将指定位置的成员复制到其他位置（会覆盖原有成员），然后返回当前数组 参数如下： target（必需）：从该位置开始替换数据。如果为负值，表示倒数。 start（可选）：从该位置开始读取数据，默认为 0。如果为负值，表示从末尾开始计算。 end（可选）：到该位置前停止读取数据，默认等于数组长度。如果为负值，表示从末尾开始计算。 12[1, 2, 3, 4, 5].copyWithin(0, 3) // 将从 3 号位直到数组结束的成员（4 和 5），复制到从 0 号位开始的位置，结果覆盖了原来的 1 和 2// [4, 5, 3, 4, 5] find()、findIndex()find()用于找出第一个符合条件的数组成员 参数是一个回调函数，接受三个参数依次为当前的值、当前的位置和原数组 123[1, 5, 10, 15].find(function(value, index, arr) &#123; return value &gt; 9;&#125;) // 10 1234findIndex`返回第一个符合条件的数组成员的位置，如果所有成员都不符合条件，则返回`-1[1, 5, 10, 15].findIndex(function(value, index, arr) &#123; return value &gt; 9;&#125;) // 2 这两个方法都可以接受第二个参数，用来绑定回调函数的this对象。 12345function f(v)&#123; return v &gt; this.age;&#125;let person = &#123;name: &#x27;John&#x27;, age: 20&#125;;[10, 12, 26, 15].find(f, person); // 26 fill()使用给定值，填充一个数组 12345[&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;].fill(7)// [7, 7, 7]new Array(3).fill(7)// [7, 7, 7] 还可以接受第二个和第三个参数，用于指定填充的起始位置和结束位置 12[&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;].fill(7, 1, 2)// [&#x27;a&#x27;, 7, &#x27;c&#x27;] 注意，如果填充的类型为对象，则是浅拷贝 entries()，keys()，values()keys()是对键名的遍历、values()是对键值的遍历，entries()是对键值对的遍历 12345678910111213141516or (let index of [&#x27;a&#x27;, &#x27;b&#x27;].keys()) &#123; console.log(index);&#125;// 0// 1for (let elem of [&#x27;a&#x27;, &#x27;b&#x27;].values()) &#123; console.log(elem);&#125;// &#x27;a&#x27;// &#x27;b&#x27;for (let [index, elem] of [&#x27;a&#x27;, &#x27;b&#x27;].entries()) &#123; console.log(index, elem);&#125;// 0 &quot;a&quot; includes()用于判断数组是否包含给定的值 123[1, 2, 3].includes(2) // true[1, 2, 3].includes(4) // false[1, 2, NaN].includes(NaN) // true 方法的第二个参数表示搜索的起始位置，默认为0 参数为负数则表示倒数的位置 12[1, 2, 3].includes(3, 3); // false[1, 2, 3].includes(3, -1); // true flat()，flatMap()将数组扁平化处理，返回一个新数组，对原数据没有影响 12[1, 2, [3, 4]].flat()// [1, 2, 3, 4] flat()默认只会“拉平”一层，如果想要“拉平”多层的嵌套数组，可以将flat()方法的参数写成一个整数，表示想要拉平的层数，默认为1 12345[1, 2, [3, [4, 5]]].flat()// [1, 2, 3, [4, 5]][1, 2, [3, [4, 5]]].flat(2)// [1, 2, 3, 4, 5] flatMap()方法对原数组的每个成员执行一个函数相当于执行Array.prototype.map()，然后对返回值组成的数组执行flat()方法。该方法返回一个新数组，不改变原数组 123// 相当于 [[2, 4], [3, 6], [4, 8]].flat()[2, 3, 4].flatMap((x) =&gt; [x, x * 2])// [2, 4, 3, 6, 4, 8] 1flatMap()方法还可以有第二个参数，用来绑定遍历函数里面的this 四、数组的空位数组的空位指，数组的某一个位置没有任何值 ES6 则是明确将空位转为undefined，包括Array.from、扩展运算符、copyWithin()、fill()、entries()、keys()、values()、find()和findIndex() 建议大家在日常书写中，避免出现空位 五、排序稳定性将sort()默认设置为稳定的排序算法 1234567891011121314const arr = [ &#x27;peach&#x27;, &#x27;straw&#x27;, &#x27;apple&#x27;, &#x27;spork&#x27;];const stableSorting = (s1, s2) =&gt; &#123; if (s1[0] &lt; s2[0]) return -1; return 1;&#125;;arr.sort(stableSorting)// [&quot;apple&quot;, &quot;peach&quot;, &quot;straw&quot;, &quot;spork&quot;] 排序结果中，straw在spork的前面，跟原始顺序一致 对象新增 一、属性的简写ES6中，当对象键名与对应值名相等的时候，可以进行简写 1234const baz = &#123;foo:foo&#125;// 等同于const baz = &#123;foo&#125; 方法也能够进行简写 12345678910111213const o = &#123; method() &#123; return &quot;Hello!&quot;; &#125;&#125;;// 等同于const o = &#123; method: function() &#123; return &quot;Hello!&quot;; &#125;&#125; 在函数内作为返回值，也会变得方便很多 12345678function getPoint() &#123; const x = 1; const y = 10; return &#123;x, y&#125;;&#125;getPoint()// &#123;x:1, y:10&#125; 注意：简写的对象方法不能用作构造函数，否则会报错 1234567const obj = &#123; f() &#123; this.foo = &#x27;bar&#x27;; &#125;&#125;;new obj.f() // 报错 二、属性名表达式ES6 允许字面量定义对象时，将表达式放在括号内 12345678910let lastWord = &#x27;last word&#x27;;const a = &#123; &#x27;first word&#x27;: &#x27;hello&#x27;, [lastWord]: &#x27;world&#x27;&#125;;a[&#x27;first word&#x27;] // &quot;hello&quot;a[lastWord] // &quot;world&quot;a[&#x27;last word&#x27;] // &quot;world&quot; 表达式还可以用于定义方法名 1234567let obj = &#123; [&#x27;h&#x27; + &#x27;ello&#x27;]() &#123; return &#x27;hi&#x27;; &#125;&#125;;obj.hello() // hi 注意，属性名表达式与简洁表示法，不能同时使用，会报错 12345678// 报错const foo = &#x27;bar&#x27;;const bar = &#x27;abc&#x27;;const baz = &#123; [foo] &#125;;// 正确const foo = &#x27;bar&#x27;;const baz = &#123; [foo]: &#x27;abc&#x27;&#125;; 注意，属性名表达式如果是一个对象，默认情况下会自动将对象转为字符串[object Object] 123456789const keyA = &#123;a: 1&#125;;const keyB = &#123;b: 2&#125;;const myObject = &#123; [keyA]: &#x27;valueA&#x27;, [keyB]: &#x27;valueB&#x27;&#125;;myObject // Object &#123;[object Object]: &quot;valueB&quot;&#125; 三、super关键字this关键字总是指向函数所在的当前对象，ES6 又新增了另一个类似的关键字super，指向当前对象的原型对象 12345678910111213const proto = &#123; foo: &#x27;hello&#x27;&#125;;const obj = &#123; foo: &#x27;world&#x27;, find() &#123; return super.foo; &#125;&#125;;Object.setPrototypeOf(obj, proto); // 为obj设置原型对象obj.find() // &quot;hello&quot; 四、扩展运算符的应用在解构赋值中，未被读取的可遍历的属性，分配到指定的对象上面 1234let &#123; x, y, ...z &#125; = &#123; x: 1, y: 2, a: 3, b: 4 &#125;;x // 1y // 2z // &#123; a: 3, b: 4 &#125; 注意：解构赋值必须是最后一个参数，否则会报错 解构赋值是浅拷贝 1234let obj = &#123; a: &#123; b: 1 &#125; &#125;;let &#123; ...x &#125; = obj;obj.a.b = 2; // 修改obj里面a属性中键值x.a.b // 2，影响到了结构出来x的值 对象的扩展运算符等同于使用Object.assign()方法 五、属性的遍历ES6 一共有 5 种方法可以遍历对象的属性。 for…in：循环遍历对象自身的和继承的可枚举属性（不含 Symbol 属性） Object.keys(obj)：返回一个数组，包括对象自身的（不含继承的）所有可枚举属性（不含 Symbol 属性）的键名 Object.getOwnPropertyNames(obj)：回一个数组，包含对象自身的所有属性（不含 Symbol 属性，但是包括不可枚举属性）的键名 Object.getOwnPropertySymbols(obj)：返回一个数组，包含对象自身的所有 Symbol 属性的键名 Reflect.ownKeys(obj)：返回一个数组，包含对象自身的（不含继承的）所有键名，不管键名是 Symbol 或字符串，也不管是否可枚举 上述遍历，都遵守同样的属性遍历的次序规则： 首先遍历所有数值键，按照数值升序排列 其次遍历所有字符串键，按照加入时间升序排列 最后遍历所有 Symbol 键，按照加入时间升序排 12Reflect.ownKeys(&#123; [Symbol()]:0, b:0, 10:0, 2:0, a:0 &#125;)// [&#x27;2&#x27;, &#x27;10&#x27;, &#x27;b&#x27;, &#x27;a&#x27;, Symbol()] 六、对象新增的方法关于对象新增的方法，分别有以下： Object.is() Object.assign() Object.getOwnPropertyDescriptors() Object.setPrototypeOf()，Object.getPrototypeOf() Object.keys()，Object.values()，Object.entries() Object.fromEntries() Object.is()严格判断两个值是否相等，与严格比较运算符（&#x3D;&#x3D;&#x3D;）的行为基本一致，不同之处只有两个：一是+0不等于-0，二是NaN等于自身 12345+0 === -0 //trueNaN === NaN // falseObject.is(+0, -0) // falseObject.is(NaN, NaN) // true Object.assign()1Object.assign()`方法用于对象的合并，将源对象`source`的所有可枚举属性，复制到目标对象`target Object.assign()方法的第一个参数是目标对象，后面的参数都是源对象 1234567const target = &#123; a: 1, b: 1 &#125;;const source1 = &#123; b: 2, c: 2 &#125;;const source2 = &#123; c: 3 &#125;;Object.assign(target, source1, source2);target // &#123;a:1, b:2, c:3&#125; 注意：Object.assign()方法是浅拷贝，遇到同名属性会进行替换 Object.getOwnPropertyDescriptors()返回指定对象所有自身属性（非继承属性）的描述对象 12345678910111213141516const obj = &#123; foo: 123, get bar() &#123; return &#x27;abc&#x27; &#125;&#125;;Object.getOwnPropertyDescriptors(obj)// &#123; foo:// &#123; value: 123,// writable: true,// enumerable: true,// configurable: true &#125;,// bar:// &#123; get: [Function: get bar],// set: undefined,// enumerable: true,// configurable: true &#125; &#125; Object.setPrototypeOf()Object.setPrototypeOf方法用来设置一个对象的原型对象 1234Object.setPrototypeOf(object, prototype)// 用法const o = Object.setPrototypeOf(&#123;&#125;, null); Object.getPrototypeOf()用于读取一个对象的原型对象 1Object.getPrototypeOf(obj); Object.keys()返回自身的（不含继承的）所有可遍历（enumerable）属性的键名的数组 123var obj = &#123; foo: &#x27;bar&#x27;, baz: 42 &#125;;Object.keys(obj)// [&quot;foo&quot;, &quot;baz&quot;] Object.values()返回自身的（不含继承的）所有可遍历（enumerable）属性的键对应值的数组 123const obj = &#123; foo: &#x27;bar&#x27;, baz: 42 &#125;;Object.values(obj)// [&quot;bar&quot;, 42] Object.entries()返回一个对象自身的（不含继承的）所有可遍历（enumerable）属性的键值对的数组 123const obj = &#123; foo: &#x27;bar&#x27;, baz: 42 &#125;;Object.entries(obj)// [ [&quot;foo&quot;, &quot;bar&quot;], [&quot;baz&quot;, 42] ] Object.fromEntries()用于将一个键值对数组转为对象 12345Object.fromEntries([ [&#x27;foo&#x27;, &#x27;bar&#x27;], [&#x27;baz&#x27;, 42]])// &#123; foo: &quot;bar&quot;, baz: 42 &#125; 函数新增 一、参数ES6允许为函数的参数设置默认值 1234567function log(x, y = &#x27;World&#x27;) &#123; console.log(x, y);&#125;console.log(&#x27;Hello&#x27;) // Hello Worldconsole.log(&#x27;Hello&#x27;, &#x27;China&#x27;) // Hello Chinaconsole.log(&#x27;Hello&#x27;, &#x27;&#x27;) // Hello 函数的形参是默认声明的，不能使用let或const再次声明 1234function foo(x = 5) &#123; let x = 1; // error const x = 2; // error&#125; 参数默认值可以与解构赋值的默认值结合起来使用 12345678function foo(&#123;x, y = 5&#125;) &#123; console.log(x, y);&#125;foo(&#123;&#125;) // undefined 5foo(&#123;x: 1&#125;) // 1 5foo(&#123;x: 1, y: 2&#125;) // 1 2foo() // TypeError: Cannot read property &#x27;x&#x27; of undefined 上面的foo函数，当参数为对象的时候才能进行解构，如果没有提供参数的时候，变量x和y就不会生成，从而报错，这里设置默认值避免 12345function foo(&#123;x, y = 5&#125; = &#123;&#125;) &#123; console.log(x, y);&#125;foo() // undefined 5 参数默认值应该是函数的尾参数，如果不是非尾部的参数设置默认值，实际上这个参数是没发省略的 12345678function f(x = 1, y) &#123; return [x, y];&#125;f() // [1, undefined]f(2) // [2, undefined]f(, 1) // 报错f(undefined, 1) // [1, 1] 二、属性函数的length属性length将返回没有指定默认值的参数个数 123(function (a) &#123;&#125;).length // 1(function (a = 5) &#123;&#125;).length // 0(function (a, b, c = 5) &#123;&#125;).length // 2 rest 参数也不会计入length属性 1(function(...args) &#123;&#125;).length // 0 如果设置了默认值的参数不是尾参数，那么length属性也不再计入后面的参数了 12(function (a = 0, b, c) &#123;&#125;).length // 0(function (a, b = 1, c) &#123;&#125;).length // 1 name属性返回该函数的函数名 1234567var f = function () &#123;&#125;;// ES5f.name // &quot;&quot;// ES6f.name // &quot;f&quot; 如果将一个具名函数赋值给一个变量，则 name属性都返回这个具名函数原本的名字 12const bar = function baz() &#123;&#125;;bar.name // &quot;baz&quot; 12Function`构造函数返回的函数实例，`name`属性的值为`anonymous(new Function).name // &quot;anonymous&quot; bind返回的函数，name属性值会加上bound前缀 1234function foo() &#123;&#125;;foo.bind(&#123;&#125;).name // &quot;bound foo&quot;(function()&#123;&#125;).bind(&#123;&#125;).name // &quot;bound &quot; 三、作用域一旦设置了参数的默认值，函数进行声明初始化时，参数会形成一个单独的作用域 等到初始化结束，这个作用域就会消失。这种语法行为，在不设置参数默认值时，是不会出现的 下面例子中，y=x会形成一个单独作用域，x没有被定义，所以指向全局变量x 123456789let x = 1;function f(y = x) &#123; // 等同于 let y = x let x = 2; console.log(y);&#125;f() // 1 四、严格模式只要函数参数使用了默认值、解构赋值、或者扩展运算符，那么函数内部就不能显式设定为严格模式，否则会报错 12345678910111213141516171819202122232425// 报错function doSomething(a, b = a) &#123; &#x27;use strict&#x27;; // code&#125;// 报错const doSomething = function (&#123;a, b&#125;) &#123; &#x27;use strict&#x27;; // code&#125;;// 报错const doSomething = (...a) =&gt; &#123; &#x27;use strict&#x27;; // code&#125;;const obj = &#123; // 报错 doSomething(&#123;a, b&#125;) &#123; &#x27;use strict&#x27;; // code &#125;&#125;; 五、箭头函数使用“箭头”（=&gt;）定义函数 123456var f = v =&gt; v;// 等同于var f = function (v) &#123; return v;&#125;; 如果箭头函数不需要参数或需要多个参数，就使用一个圆括号代表参数部分 123456789var f = () =&gt; 5;// 等同于var f = function () &#123; return 5 &#125;;var sum = (num1, num2) =&gt; num1 + num2;// 等同于var sum = function(num1, num2) &#123; return num1 + num2;&#125;; 如果箭头函数的代码块部分多于一条语句，就要使用大括号将它们括起来，并且使用return语句返回 1var sum = (num1, num2) =&gt; &#123; return num1 + num2; &#125; 如果返回对象，需要加括号将对象包裹 1let getTempItem = id =&gt; (&#123; id: id, name: &quot;Temp&quot; &#125;); 注意点： 函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象 不可以当作构造函数，也就是说，不可以使用new命令，否则会抛出一个错误 不可以使用arguments对象，该对象在函数体内不存在。如果要用，可以用 rest 参数代替 不可以使用yield命令，因此箭头函数不能用作 Generator 函数","categories":[{"name":"ES6","slug":"ES6","permalink":"http://example.com/categories/ES6/"}],"tags":[{"name":"ES6","slug":"ES6","permalink":"http://example.com/tags/ES6/"}]},{"title":"单页应用（SPA）","slug":"单页应用（SPA）","date":"2018-04-29T14:41:23.000Z","updated":"2022-05-30T02:12:03.205Z","comments":true,"path":"2018/04/29/单页应用（SPA）/","link":"","permalink":"http://example.com/2018/04/29/%E5%8D%95%E9%A1%B5%E5%BA%94%E7%94%A8%EF%BC%88SPA%EF%BC%89/","excerpt":"","text":"一、什么是SPASPA（single-page application），翻译过来就是单页应用SPA是一种网络应用程序或网站的模型，它通过动态重写当前页面来与用户交互，这种方法避免了页面之间切换打断用户体验在单页应用中，所有必要的代码（HTML、JavaScript和CSS）都通过单个页面的加载而检索，或者根据需要（通常是为响应用户操作）动态装载适当的资源并添加到页面页面在任何时间点都不会重新加载，也不会将控制转移到其他页面举个例子来讲就是一个杯子，早上装的牛奶，中午装的是开水，晚上装的是茶，我们发现，变的始终是杯子里的内容，而杯子始终是那个杯子结构如下图 我们熟知的JS框架如react,vue,angular,ember都属于SPA 二、SPA和MPA的区别上面大家已经对单页面有所了解了，下面来讲讲多页应用MPA（MultiPage-page application），翻译过来就是多页应用在MPA中，每个页面都是一个主页面，都是独立的当我们在访问另一个页面的时候，都需要重新加载html、css、js文件，公共文件则根据需求按需加载如下图 单页应用与多页应用的区别 单页面应用（SPA） 多页面应用（MPA） 组成 一个主页面和多个页面片段 多个主页面 刷新方式 局部刷新 整页刷新 url模式 哈希模式 历史模式 SEO搜索引擎优化 难实现，可使用SSR方式改善 容易实现 数据传递 容易 通过url、cookie、localStorage等传递 页面切换 速度快，用户体验良好 切换加载资源，速度慢，用户体验差 维护成本 相对容易 相对复杂 单页应用优缺点优点： 具有桌面应用的即时性、网站的可移植性和可访问性 用户体验好、快，内容的改变不需要重新加载整个页面 良好的前后端分离，分工更明确 缺点： 不利于搜索引擎的抓取 首次渲染速度相对较慢","categories":[{"name":"vue","slug":"vue","permalink":"http://example.com/categories/vue/"}],"tags":[{"name":"vue","slug":"vue","permalink":"http://example.com/tags/vue/"}]},{"title":"v-if和v-for不要一起使用","slug":"v-if和v-for不要一起使用","date":"2018-04-03T03:33:04.000Z","updated":"2022-05-30T02:55:01.251Z","comments":true,"path":"2018/04/03/v-if和v-for不要一起使用/","link":"","permalink":"http://example.com/2018/04/03/v-if%E5%92%8Cv-for%E4%B8%8D%E8%A6%81%E4%B8%80%E8%B5%B7%E4%BD%BF%E7%94%A8/","excerpt":"","text":"一、作用v-if 指令用于条件性地渲染一块内容。这块内容只会在指令的表达式返回 true值的时候被渲染 v-for 指令基于一个数组来渲染一个列表。v-for 指令需要使用 item in items 形式的特殊语法，其中 items 是源数据数组或者对象，而 item 则是被迭代的数组元素的别名 在 v-for 的时候，建议设置key值，并且保证每个key值是独一无二的，这便于diff算法进行优化 两者在用法上 12345&lt;Modal v-if=&quot;isShow&quot; /&gt;&lt;li v-for=&quot;item in items&quot; :key=&quot;item.id&quot;&gt; &#123;&#123; item.label &#125;&#125;&lt;/li&gt; 二、优先级v-if与v-for都是vue模板系统中的指令 在vue模板编译的时候，会将指令系统转化成可执行的render函数 编写一个p标签，同时使用v-if与 v-for 12345&lt;div id=&quot;app&quot;&gt; &lt;p v-if=&quot;isShow&quot; v-for=&quot;item in items&quot;&gt; &#123;&#123; item.title &#125;&#125; &lt;/p&gt;&lt;/div&gt; 创建vue实例，存放isShow与items数据 123456789101112131415const app = new Vue(&#123; el: &quot;#app&quot;, data() &#123; return &#123; items: [ &#123; title: &quot;foo&quot; &#125;, &#123; title: &quot;baz&quot; &#125;] &#125; &#125;, computed: &#123; isShow() &#123; return this.items &amp;&amp; this.items.length &gt; 0 &#125; &#125;&#125;) 模板指令的代码都会生成在render函数中，通过app.$options.render就能得到渲染函数 123456ƒ anonymous() &#123; with (this) &#123; return _c(&#x27;div&#x27;, &#123; attrs: &#123; &quot;id&quot;: &quot;app&quot; &#125; &#125;, _l((items), function (item) &#123; return (isShow) ? _c(&#x27;p&#x27;, [_v(&quot;\\n&quot; + _s(item.title) + &quot;\\n&quot;)]) : _e() &#125;), 0) &#125;&#125; _l是vue的列表渲染函数，函数内部都会进行一次if判断 初步得到结论：v-for优先级是比v-if高 再将v-for与v-if置于不同标签 12345&lt;div id=&quot;app&quot;&gt; &lt;template v-if=&quot;isShow&quot;&gt; &lt;p v-for=&quot;item in items&quot;&gt;&#123;&#123;item.title&#125;&#125;&lt;/p&gt; &lt;/template&gt;&lt;/div&gt; 再输出下render函数 123456ƒ anonymous() &#123; with(this)&#123;return _c(&#x27;div&#x27;,&#123;attrs:&#123;&quot;id&quot;:&quot;app&quot;&#125;&#125;, [(isShow)?[_v(&quot;\\n&quot;), _l((items),function(item)&#123;return _c(&#x27;p&#x27;,[_v(_s(item.title))])&#125;)]:_e()],2)&#125;&#125; 这时候我们可以看到，v-for与v-if作用在不同标签时候，是先进行判断，再进行列表的渲染 我们再在查看下vue源码 源码位置：\\vue-dev\\src\\compiler\\codegen\\index.js 1234567891011121314151617181920export function genElement (el: ASTElement, state: CodegenState): string &#123; if (el.parent) &#123; el.pre = el.pre || el.parent.pre &#125; if (el.staticRoot &amp;&amp; !el.staticProcessed) &#123; return genStatic(el, state) &#125; else if (el.once &amp;&amp; !el.onceProcessed) &#123; return genOnce(el, state) &#125; else if (el.for &amp;&amp; !el.forProcessed) &#123; return genFor(el, state) &#125; else if (el.if &amp;&amp; !el.ifProcessed) &#123; return genIf(el, state) &#125; else if (el.tag === &#x27;template&#x27; &amp;&amp; !el.slotTarget &amp;&amp; !state.pre) &#123; return genChildren(el, state) || &#x27;void 0&#x27; &#125; else if (el.tag === &#x27;slot&#x27;) &#123; return genSlot(el, state) &#125; else &#123; // component or element ...&#125; 在进行if判断的时候，v-for是比v-if先进行判断 最终结论：v-for优先级比v-if高 三、注意事项 永远不要把 v-if 和 v-for 同时用在同一个元素上，带来性能方面的浪费（每次渲染都会先循环再进行条件判断） 如果避免出现这种情况，则在外层嵌套template（页面渲染不生成dom节点），在这一层进行v-if判断，然后在内部进行v-for循环 123&lt;template v-if=&quot;isShow&quot;&gt; &lt;p v-for=&quot;item in items&quot;&gt;&lt;/template&gt; 如果条件出现在循环内部，可通过计算属性computed提前过滤掉那些不需要显示的项 1234567computed: &#123; items: function() &#123; return this.list.filter(function (item) &#123; return item.isShow &#125;) &#125;&#125;","categories":[{"name":"vue","slug":"vue","permalink":"http://example.com/categories/vue/"}],"tags":[{"name":"vue","slug":"vue","permalink":"http://example.com/tags/vue/"}]},{"title":"v-show和v-if的区别","slug":"v-show和v-if的区别","date":"2018-04-03T02:21:06.000Z","updated":"2022-05-30T02:54:44.353Z","comments":true,"path":"2018/04/03/v-show和v-if的区别/","link":"","permalink":"http://example.com/2018/04/03/v-show%E5%92%8Cv-if%E7%9A%84%E5%8C%BA%E5%88%AB/","excerpt":"","text":"一、v-show与v-if的共同点在 vue 中 v-show 与 v-if 的作用效果是相同的(不含v-else)，都能控制元素在页面是否显示 在用法上也是相同的 12&lt;Model v-show=&quot;isShow&quot; /&gt;&lt;Model v-if=&quot;isShow&quot; /&gt; 当表达式为true的时候，都会占据页面的位置 当表达式都为false时，都不会占据页面位置 二、v-show与v-if的区别控制手段： v-show隐藏则是为该元素添加css--display:none，dom元素依旧还在。 v-if显示隐藏是将dom元素整个添加或删除 编译过程： v-if切换有一个局部编译&#x2F;卸载的过程，切换过程中合适地销毁和重建内部的事件监听和子组件； v-show只是简单的基于css切换 编译条件： v-if是真正的条件渲染，它会确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建。只有渲染条件为假时，并不做操作，直到为真才渲染。 v-show 由false变为true的时候不会触发组件的生命周期 v-if由false变为true的时候，触发组件的beforeCreate、create、beforeMount、mounted钩子，由true变为false的时候触发组件的beforeDestory、destoryed方法 性能消耗：v-if有更高的切换消耗；v-show有更高的初始渲染消耗； 三、v-show与v-if原理分析具体解析流程这里不展开讲，大致流程如下 将模板template转为ast结构的JS对象 用ast得到的JS对象拼装render和staticRenderFns函数 render和staticRenderFns函数被调用后生成虚拟VNODE节点，该节点包含创建DOM节点所需信息 vm.patch函数通过虚拟DOM算法利用VNODE节点创建真实DOM节点 v-show原理不管初始条件是什么，元素总是会被渲染 我们看一下在vue中是如何实现的 代码很好理解，有transition就执行transition，没有就直接设置display属性 12345678910111213141516171819202122// https://github.com/vuejs/vue-next/blob/3cd30c5245da0733f9eb6f29d220f39c46518162/packages/runtime-dom/src/directives/vShow.tsexport const vShow: ObjectDirective&lt;VShowElement&gt; = &#123; beforeMount(el, &#123; value &#125;, &#123; transition &#125;) &#123; el._vod = el.style.display === &#x27;none&#x27; ? &#x27;&#x27; : el.style.display if (transition &amp;&amp; value) &#123; transition.beforeEnter(el) &#125; else &#123; setDisplay(el, value) &#125; &#125;, mounted(el, &#123; value &#125;, &#123; transition &#125;) &#123; if (transition &amp;&amp; value) &#123; transition.enter(el) &#125; &#125;, updated(el, &#123; value, oldValue &#125;, &#123; transition &#125;) &#123; // ... &#125;, beforeUnmount(el, &#123; value &#125;) &#123; setDisplay(el, value) &#125;&#125; v-if原理v-if在实现上比v-show要复杂的多，因为还有else else-if 等条件需要处理，这里我们也只摘抄源码中处理 v-if 的一小部分 返回一个node节点，render函数通过表达式的值来决定是否生成DOM 1234567891011121314151617181920212223242526// https://github.com/vuejs/vue-next/blob/cdc9f336fd/packages/compiler-core/src/transforms/vIf.tsexport const transformIf = createStructuralDirectiveTransform( /^(if|else|else-if)$/, (node, dir, context) =&gt; &#123; return processIf(node, dir, context, (ifNode, branch, isRoot) =&gt; &#123; // ... return () =&gt; &#123; if (isRoot) &#123; ifNode.codegenNode = createCodegenNodeForBranch( branch, key, context ) as IfConditionalExpression &#125; else &#123; // attach this branch&#x27;s codegen node to the v-if root. const parentCondition = getParentCondition(ifNode.codegenNode!) parentCondition.alternate = createCodegenNodeForBranch( branch, key + ifNode.branches.length - 1, context ) &#125; &#125; &#125;) &#125;) 四、v-show与v-if的使用场景v-if 与 v-show 都能控制dom元素在页面的显示 v-if 相比 v-show 开销更大的（直接操作dom节点增加与删除） 如果需要非常频繁地切换，则使用 v-show 较好 如果在运行时条件很少改变，则使用 v-if 较好","categories":[{"name":"vue","slug":"vue","permalink":"http://example.com/categories/vue/"}],"tags":[{"name":"vue","slug":"vue","permalink":"http://example.com/tags/vue/"}]},{"title":"vue生命周期","slug":"vue生命周期","date":"2018-04-01T14:49:10.000Z","updated":"2022-05-30T02:11:10.048Z","comments":true,"path":"2018/04/01/vue生命周期/","link":"","permalink":"http://example.com/2018/04/01/vue%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/","excerpt":"","text":"一、生命周期是什么生命周期（Life Cycle）的概念应用很广泛，特别是在政治、经济、环境、技术、社会等诸多领域经常出现，其基本涵义可以通俗地理解为“从摇篮到坟墓”（Cradle-to-Grave）的整个过程在Vue中实例从创建到销毁的过程就是生命周期，即指从创建、初始化数据、编译模板、挂载Dom→渲染、更新→渲染、卸载等一系列过程我们可以把组件比喻成工厂里面的一条流水线，每个工人（生命周期）站在各自的岗位，当任务流转到工人身边的时候，工人就开始工作PS：在Vue生命周期钩子会自动绑定 this 上下文到实例中，因此你可以访问数据，对 property 和方法进行运算这意味着你不能使用箭头函数来定义一个生命周期方法 (例如 created: () =&gt; this.fetchTodos()) 二、生命周期有哪些Vue生命周期总共可以分为8个阶段：创建前后, 载入前后,更新前后,销毁前销毁后，以及一些特殊场景的生命周期 生命周期 描述 beforeCreate 组件实例被创建之初 created 组件实例已经完全创建 beforeMount 组件挂载之前 mounted 组件挂载到实例上去之后 beforeUpdate 组件数据发生变化，更新之前 updated 组件数据更新之后 beforeDestroy 组件实例销毁之前 destroyed 组件实例销毁之后 activated keep-alive 缓存的组件激活时 deactivated keep-alive 缓存的组件停用时调用 errorCaptured 捕获一个来自子孙组件的错误时被调用 三、生命周期整体流程Vue生命周期流程图 具体分析beforeCreate -&gt; created 初始化vue实例，进行数据观测 created 完成数据观测，属性与方法的运算，watch、event事件回调的配置 可调用methods中的方法，访问和修改data数据触发响应式渲染dom，可通过computed和watch完成数据计算 此时vm.$el 并没有被创建 created -&gt; beforeMount 判断是否存在el选项，若不存在则停止编译，直到调用vm.$mount(el)才会继续编译 优先级：render &gt; template &gt; outerHTML vm.el获取到的是挂载DOM的 beforeMount 在此阶段可获取到vm.el 此阶段vm.el虽已完成DOM初始化，但并未挂载在el选项上 beforeMount -&gt; mounted 此阶段vm.el完成挂载，vm.$el生成的DOM替换了el选项所对应的DOM mounted vm.el已完成DOM的挂载与渲染，此刻打印vm.$el，发现之前的挂载点及内容已被替换成新的DOM beforeUpdate 更新的数据必须是被渲染在模板上的（el、template、render之一） 此时view层还未更新 若在beforeUpdate中再次修改数据，不会再次触发更新方法 updated 完成view层的更新 若在updated中再次修改数据，会再次触发更新方法（beforeUpdate、updated） beforeDestroy 实例被销毁前调用，此时实例属性与方法仍可访问 destroyed 完全销毁一个实例。可清理它与其它实例的连接，解绑它的全部指令及事件监听器 并不能清除DOM，仅仅销毁实例 使用场景分析 生命周期 描述 beforeCreate 执行时组件实例还未创建，通常用于插件开发中执行一些初始化任务 created 组件初始化完毕，各种数据可以使用，常用于异步数据获取 beforeMount 未执行渲染、更新，dom未创建 mounted 初始化结束，dom已创建，可用于获取访问数据和dom元素 beforeUpdate 更新前，可用于获取更新前各种状态 updated 更新后，所有状态已是最新 beforeDestroy 销毁前，可用于一些定时器或订阅的取消 destroyed 组件已销毁，作用同上 四、数据请求在created和mouted的区别created是在组件实例一旦创建完成的时候立刻调用，这时候页面dom节点并未生成mounted是在页面dom节点渲染完毕之后就立刻执行的触发时机上created是比mounted要更早的两者相同点：都能拿到实例对象的属性和方法讨论这个问题本质就是触发的时机，放在mounted请求有可能导致页面闪动（页面dom结构已经生成），但如果在页面加载前完成则不会出现此情况建议：放在create生命周期当中","categories":[{"name":"vue","slug":"vue","permalink":"http://example.com/categories/vue/"}],"tags":[{"name":"vue","slug":"vue","permalink":"http://example.com/tags/vue/"}]},{"title":"什么是vue","slug":"什么是vue","date":"2018-03-29T14:25:14.000Z","updated":"2022-05-29T14:42:36.807Z","comments":true,"path":"2018/03/29/什么是vue/","link":"","permalink":"http://example.com/2018/03/29/%E4%BB%80%E4%B9%88%E6%98%AFvue/","excerpt":"","text":"一、Vue是什么Vue.js（&#x2F;vjuː&#x2F;，或简称为Vue）是一个用于创建用户界面的开源JavaScript框架，也是一个创建单页应用（SPA）的Web应用框架。2016年一项针对JavaScript的调查表明，Vue有着89%的开发者满意度。在GitHub上，该项目平均每天能收获95颗星，为Github有史以来星标数第3多的项目同时也是一款流行的JavaScript前端框架，旨在更好地组织与简化Web开发。Vue所关注的核心是MVC模式中的视图层，同时，它也能方便地获取数据更新，并通过组件内部特定的方法实现视图与模型的交互。 1、前端工程化前端工程化，是一种当下流行的软件开发观念。可能很多小伙伴在学习前端的时候，是先从Html、Css、JavaScript开始学起的，在学习和使用的过程中会发现，这样的进行开发需要重复写很多的代码，而且，代码的逻辑关联性较低，还会出现Css或者JavaScript配置文件冲突或者相互之间产生干扰的问题，会给开发以及debug带来很多的问题，可能找半天都没有找到是什么地方错了，总之，比较凌乱。 而前端工程化是为了解决上诉的这些问题，针对具体的生产开发环境而提出的方案。前端工程化包含了：工程化的目的是为了，提高开发效率、保证开发质量。 1）规范化，也就是制定或者约定一个开发规则、开发标准，比如，类的命名规范、制定编码模板代码，等等，提倡约定大于配置（vue、springboot等等当中就有约定大于配置的规范）。 2）可定量的过程化方法，简单来说就是制定衡量整个开发流程和进度的方法。 3）版本控制，来管理代码的更新。 4）开发使用的技术、方法。 2、前后端分离前端：负责View（视图层）和Controller（业务模块流程控制层）。 后端：负责Model层、业务、数据处理等。 这样子的好处，前端UI的设计可以根据业务需求进行修改，而不会干扰，后端的开发，后端可以专注于后端的事情，前端也不用关心后端开发的问题，只需要留有前后端对接的接口就可以了。 3、组件化开发组件化开发，让前端重复的使用的代码可以单独拎出来成为一个组件来供整个项目各个页面的使用，Css、JavaScript的脚本的内容可以限定作用的域，从而大幅度减少了开发的冲突问题。 二、Vue核心特性数据驱动（MVVM)1MVVM表示的是 Model-View-ViewModel Model：模型层，负责处理业务逻辑以及和服务器端进行交互 View：视图层：负责将数据模型转化为UI展示出来，可以简单的理解为HTML页面 ViewModel：视图模型层，用来连接Model和View，是Model和View之间的通信桥梁 组件化1.什么是组件化一句话来说就是把图形、非图形的各种逻辑均抽象为一个统一的概念（组件）来实现开发的模式，在Vue中每一个.vue文件都可以视为一个组件2.组件化的优势 降低整个系统的耦合度，在保持接口不变的情况下，我们可以替换不同的组件快速完成需求，例如输入框，可以替换为日历、时间、范围等组件作具体的实现 调试方便，由于整个系统是通过组件组合起来的，在出现问题的时候，可以用排除法直接移除组件，或者根据报错的组件快速定位问题，之所以能够快速定位，是因为每个组件之间低耦合，职责单一，所以逻辑会比分析整个系统要简单 提高可维护性，由于每个组件的职责单一，并且组件在系统中是被复用的，所以对代码进行优化可获得系统的整体升级 指令系统解释：指令 (Directives) 是带有 v- 前缀的特殊属性作用：当表达式的值改变时，将其产生的连带影响，响应式地作用于 DOM 常用的指令 条件渲染指令 v-if 列表渲染指令v-for 属性绑定指令v-bind 事件绑定指令v-on 双向数据绑定指令v-model","categories":[{"name":"vue","slug":"vue","permalink":"http://example.com/categories/vue/"}],"tags":[{"name":"vue","slug":"vue","permalink":"http://example.com/tags/vue/"}]},{"title":"防抖与节流","slug":"防抖与节流","date":"2018-02-27T07:58:47.000Z","updated":"2022-05-27T08:24:19.863Z","comments":true,"path":"2018/02/27/防抖与节流/","link":"","permalink":"http://example.com/2018/02/27/%E9%98%B2%E6%8A%96%E4%B8%8E%E8%8A%82%E6%B5%81/","excerpt":"","text":"一、是什么本质上是优化高频率执行代码的一种手段 如：浏览器的 resize、scroll、keypress、mousemove 等事件在触发时，会不断地调用绑定在事件上的回调函数，极大地浪费资源，降低前端性能 为了优化体验，需要对这类事件进行调用次数的限制，对此我们就可以采用 防抖（debounce） 和 节流（throttle） 的方式来减少调用频率 定义 节流: n 秒内只运行一次，若在 n 秒内重复触发，只有一次生效 防抖: n 秒后在执行该事件，若在 n 秒内被重复触发，则重新计时 一个经典的比喻: 想象每天上班大厦底下的电梯。把电梯完成一次运送，类比为一次函数的执行和响应 假设电梯有两种运行策略 debounce 和 throttle，超时设定为15秒，不考虑容量限制 电梯第一个人进来后，15秒后准时运送一次，这是节流 电梯第一个人进来后，等待15秒。如果过程中又有人进来，15秒等待重新计时，直到15秒后开始运送，这是防抖 代码实现节流1234567891011121314151617181920212223242526272829&lt;div id=&quot;div1&quot; draggable=&quot;true&quot;&gt;可拖拽&lt;div&gt;&lt;style&gt;#div1 &#123; border: 1px solid #ccc; width: 200px; height: 100px;&#125;&lt;/style&gt; &lt;script&gt; // 节流 const div1 = document.getElementById(&#x27;div1&#x27;) function throttle(fn, delay = 500) &#123; let timer = null return function () &#123; if (timer) &#123; return &#125; timer = setTimeout(() =&gt; &#123; fn.apply(this, arguments) timer = null &#125;, delay) &#125; &#125; div1.addEventListener(&#x27;drag&#x27;, throttle(function (e) &#123; console.log(e.offsetX, e.offsetY) &#125;)) &lt;/script&gt; 防抖123456789101112131415161718192021222324&lt;input type=&quot;text&quot; id=&quot;input1&quot;&gt; &lt;script&gt; // 防抖 const input1 = document.getElementById(&#x27;input1&#x27;) function debounce(fn, delay = 500) &#123; let timer = null return function () &#123; if (timer) &#123; clearTimeout(timer) &#125; timer = setTimeout(() =&gt; &#123; fn.apply(this, arguments) timer = null &#125;, delay) &#125; &#125; input1.addEventListener(&#x27;keyup&#x27;, debounce(function () &#123; console.log(input1.value) &#125;, 600)) &lt;/script&gt; 二、区别相同点： 都可以通过使用 setTimeout 实现 目的都是，降低回调执行频率，节省计算资源 不同点： 函数防抖，在一段连续操作结束后，处理回调，利用clearTimeout和 setTimeout实现。函数节流，在一段连续操作中，每一段时间只执行一次，频率较高的事件中使用来提高性能 函数防抖关注一定时间连续触发的事件，只在最后执行一次，而函数节流一段时间内只执行一次 三、应用场景防抖在连续的事件，只需触发一次回调的场景有： 搜索框搜索输入。只需用户最后一次输入完，再发送请求 手机号、邮箱验证输入检测 窗口大小resize。只需窗口调整完成后，计算窗口大小。防止重复渲染。 登录时防止用户多次点击登录，造成重复发送请求 节流在间隔一段时间执行一次回调的场景有： 滚动加载，加载更多或滚到底部监听 搜索框，搜索联想功能","categories":[{"name":"javascript","slug":"javascript","permalink":"http://example.com/categories/javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://example.com/tags/javascript/"}]},{"title":"AJAX","slug":"AJAX","date":"2017-11-04T02:35:00.000Z","updated":"2022-05-28T03:10:26.718Z","comments":true,"path":"2017/11/04/AJAX/","link":"","permalink":"http://example.com/2017/11/04/AJAX/","excerpt":"","text":"AJAX定义ajax全称“Asynchronous Javascript And XML”，是由javascript、xml、XMLHttpRequest组合在一起、能实现异步提交的功能，是一种创建交互式网页应用的网页开发技术。 前后台分离的项目架构 ajax包含哪些技术AJAX:(Asynchronous JavaScript and XML)并不是一项新技术,其实是多种技术的综合，包括Javascript、XHTML和CSS、DOM、XML和XMLHttpRequest。 服务器端语言：服务器需要具备向浏览器发送特定信息的能力。Ajax与服务器端语言无关。 XML (eXtensible Markup Language，可扩展标记语言) 是一种描述数据的格式。AJAX程序需要某种格式化的格式来在服务器和客户端之间传递信息，XML 是其中的一种选择。 XHTMLXHTML（eXtended Hypertext Markup Language,使用扩展超媒体标记语言）和 CSS（Cascading Style Sheet,级联样式单）标准化呈现； DOM（Document Object Model,文档对象模型）实现动态显示和交互； 使用XMLHTTP组件XMLHttpRequest对象进行异步数据读取 使用JavaScript绑定和处理所有数据。 同步和异步同步处理：我们通过实践触发ajax，请求服务器，在这个期间等待服务器处理请求，在这个期间客户端不能做任何处理。当 ajax 执行完毕才会继续执行其他代码。 异步处理：就是我们通过事件触发到ajax，请求服务器，在这个期间无论服务器有没有响应，客户端的其他代码一样可以运行。 同步机制流程图 Ajax异步交互原理AJAX采用异步交互过程。AJAX在用户与服务器之间引入一个中间媒介，从而消除了网络交互过程中的处理—等待—处理—等待缺点。 用户的浏览器在执行任务时即装载了AJAX引擎。AJAX引擎用JavaScript语言编写，通常藏在一个隐藏的框架中。它负责编译用户界面及与服务器之间的交互。 AJAX引擎允许用户与应用软件之间的交互过程异步进行，独立于用户与网络服务器间的交流。现在，可以用Javascript调用AJAX引擎来代替产生一个HTTP的用户动作，内存中的数据编辑、页面导航、数据校验这些不需要重新载入整个页面的需求可以交给AJAX来执行。 使用AJAX，可以为开发人员、终端用户带来可见的便捷： XMLHttpRequst对象XMLHttpRequest是XMLHTTP组件的对象，通过这个对象，AJAX可以像桌面应用程序一样只同服务器进行数据层面的交换，而不用每次都刷新界面，也不用每次将数据处理的工作都交给服务器来做；这样既减轻了服务器负担又加快了响应速度、缩短了用户等待的时间。 XMLHttpRequest最早是在IE5中以ActiveX组件的形式实现的。非W3C标准。 创建XMLHttpRequest对象（由于非标准所以实现方法不统一） Internet Explorer把XMLHttpRequest实现为一个ActiveX对象 其他浏览器（Firefox、Safari、Opera…）把它实现为一个本地的JavaScript对象。 XMLHttpRequest在不同浏览器上的实现是兼容的，所以可以用同样的方式访问XMLHttpRequest实例的属性和方法，而不论这个实例创建的方法是什么。 12345678910111213141516//兼容性写法function createXmlHttpRequest()&#123; var xmlHttp; try&#123; //Firefox, Opera 8.0+, Safari xmlHttp=new XMLHttpRequest(); &#125;catch (e)&#123; try&#123; //Internet Explorer xmlHttp=new ActiveXObject(&quot;Msxml2.XMLHTTP&quot;); &#125;catch (e)&#123; try&#123; xmlHttp=new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;); &#125;catch (e)&#123;&#125; &#125; &#125; return xmlHttp; &#125; XMLHttpRequest方法 XMLHttpRequst对象属性 发送请求利用XMLHttpRequest 实例与服务器进行异步通信包含以下3个关键部分： onreadystatechange 事件处理函数 open 方法 send 方法 open(method, url, asynch) XMLHttpRequest 对象的 open 方法允许程序员用一个Ajax调用向服务器发送请求。 method：请求类型，类似 “GET”或”POST”的字符串。若只想从服务器检索一个文件，而不需要发送任何数据，使用GET(可以在GET请求里通过附加在URL上的查询字符串来发送数据，不过数据大小限制为2000个字符)。若需要向服务器发送数据，用POST。 在某些情况下，有些浏览器会把多个XMLHttpRequest请求的结果缓存在同一个URL。如果对每个请求的响应不同，这就会来不好的结果。把当前时间戳追加到URL的最后，就能确保URL的惟一性，从而避免浏览器缓存结果。 onreadystatechange: 该事件处理函数由服务器触发，而不是用户 在 Ajax 执行过程中，服务器会通知客户端当前的通信状态。这依靠更新 XMLHttpRequest 对象的 readyState 来实现。改变 readyState 属性是服务器对客户端连接操作的一种方式。 每次 readyState 属性的改变都会触发 readystatechange事件 参数设置 url：路径字符串，指向你所请求的服务器上的那个文件。可以是绝对路径或相对路径。 async：表示请求是否要异步传输，默认值为true(异步)。指定true，在读取后面的脚本之前，不需要等待服务器的相应。指定false，当脚本处理过程经过这点时，会停下来，一直等到Ajax请求执行完毕再继续执行。 send方法send(data)： open 方法定义了 Ajax 请求的一些细节。send 方法可为已经待命的请求发送指令 data：将要传递给服务器的字符串。 若选用的是 GET 请求，则不会发送任何数据， 给 send 方法传递 null 即可：request.send(null); 当向send()方法提供参数时，要确保open()中指定的方法是POST，如果没有数据作为请求体的一部分发送，则使用null. 完整的 Ajax 的 GET 请求示例： 123456789101112131415const xhr = new XMLHttpRequest()xhr.open(&#x27;GET&#x27;, &#x27;/data/test.json&#x27;, true)xhr.onreadystatechange = function () &#123; if (xhr.readyState === 4) &#123; if (xhr.status === 200) &#123; // console.log( // JSON.parse(xhr.responseText) // ) alert(xhr.responseText) &#125; else if (xhr.status === 404) &#123; console.log(&#x27;404 not found&#x27;) &#125; &#125;&#125;xhr.send(null) 注意：使用get请求时send方法参数时null,如果传值的话，服务器也接收不到 发送Post请求setRequestHeader(header,value)当浏览器向服务器请求页面时，它会伴随这个请求发送一组首部信息。这些首部信息是一系列描述请求的元数据(metadata)。 首部信息用来声明一个请求是 GET 还是 POST。 Ajax 请求中，发送首部信息的工作可以由 setRequestHeader完成参数header： 首部的名字; 参数value：首部的值。 如果用 POST 请求向服务器发送数据，需要将 “Content-type” 的首部设置为 “application&#x2F;x-www-form-urlencoded”.它会告知服务器正在发送数据，并且数据已经符合URL编码了。 该方法必须在open()之后才能调用完整的 Ajax 的 POST 请求示例： 12345678910111213141516171819function ajax(url) &#123; const p = new Promise((resolve, reject) =&gt; &#123; const xhr = new XMLHttpRequest() xhr.open(&#x27;POST&#x27;, url, true) xhr.onreadystatechange = function () &#123; if (xhr.readyState === 4) &#123; if (xhr.status === 200) &#123; resolve( JSON.parse(xhr.responseText) ) &#125; else if (xhr.status === 404 || xhr.status === 500) &#123; reject(new Error(&#x27;404 not found&#x27;)) &#125; &#125; &#125; xhr.send(null) &#125;) return p&#125; 接收数据的方法和属性用XMLHttpRequest的方法可向服务器发送请求。在Ajax处理过程中，XMLHttpRequest的如下属性可被服务器更改： readyState status responseText responseXML readyState（请求状态）readyState 属性表示Ajax请求的当前状态。它的值用数字代表。 0 代表未初始化。 还没有调用 open 方法 1 代表正在加载。 open 方法已被调用，但 send 方法还没有被调用 2 代表已加载完毕。send 已被调用。请求已经开始 3 代表交互中。服务器正在发送响应 4 代表完成。响应发送完毕 每次 readyState 值的改变，都会触发 readystatechange 事件。如果把 onreadystatechange 事件处理函数赋给一个函数，那么每次 readyState 值的改变都会引发该函数的执行。 readyState 值的变化会因浏览器的不同而有所差异。但是，当请求结束的时候，每个浏览器都会把 readyState 的值统一设为 4。 status（服务器状态码）服务器发送的每一个响应也都带有首部信息。三位数的状态码是服务器发送的响应中最重要的首部信息，并且属于超文本传输协议中的一部分。 在 XMLHttpRequest 对象中，服务器发送的状态码都保存在 status 属性里。通过把这个值和 200 或 304 比较，可以确保服务器是否已发送了一个成功的响应。 常用状态码及其含义： 404 没找到页面(not found) 403 禁止访问(forbidden) 500 内部服务器出错(internal service error) 200 一切正常(ok) 304 没有被修改(not modified)(服务器返回304状态，表示源文件没有被修改 ) responseTextXMLHttpRequest 的 responseText 属性包含了从服务器发送的数据。它是一个HTML,XML或普通文本，这取决于服务器发送的内容。 当 readyState 属性值变成 4 时, responseText 属性才可用，表明 Ajax 请求已经结束。 1234567891011//指定响应处理函数XMLHttpReq.onreadystatechange=function()&#123; //判断对象状态 4代表完成 if(XMLHttpReq.readyState==4)&#123; //信息已经成功返回，开始处理信息 if(XMLHttpReq.status==200 || XMLHttpReq.status==304)&#123; // 开始处理信息 alert(XMLHttpReq.responseText); &#125; &#125;&#125; 两种数据格式XMLHttpRequest对成功返回的信息有两种处理方式： responseText：将传回的信息当字符串使用； responseXML：将传回的信息当XML文档使用，可以用DOM处理。 如果服务器返回的是 XML， 那么数据将储存在 responseXML 属性中只用服务器发送了带有正确首部信息的数据时， responseXML 属性才是可用的。 MIME 类型必须为 text&#x2F;xml 12345678//处理返回信息的函数function processResponse()&#123; if(XMLHttpReq.readyState==4)&#123; //判断对象状态 4代表完成 if(XMLHttpReq.status==200)&#123; //信息已经成功返回，开始处理信息 document.getElementById(&quot;chatArea&quot;).value=XMLHttpReq.responseText; &#125; &#125;&#125; get和post区别","categories":[{"name":"AJAX","slug":"AJAX","permalink":"http://example.com/categories/AJAX/"}],"tags":[{"name":"AJAX","slug":"AJAX","permalink":"http://example.com/tags/AJAX/"}]},{"title":"flex布局","slug":"flex布局","date":"2017-10-15T03:45:54.000Z","updated":"2022-05-30T06:04:13.274Z","comments":true,"path":"2017/10/15/flex布局/","link":"","permalink":"http://example.com/2017/10/15/flex%E5%B8%83%E5%B1%80/","excerpt":"","text":"一、是什么Flexible Box 简称 flex，意为”弹性布局”，可以简便、完整、响应式地实现各种页面布局 采用Flex布局的元素，称为flex容器container 它的所有子元素自动成为容器成员，称为flex项目item 容器中默认存在两条轴，主轴和交叉轴，呈90度关系。项目默认沿主轴排列，通过flex-direction来决定主轴的方向 每根轴都有起点和终点，这对于元素的对齐非常重要 二、属性关于flex常用的属性，我们可以划分为容器属性和容器成员属性 容器属性有： flex-direction flex-wrap flex-flow justify-content align-items align-content flex-direction决定主轴的方向(即项目的排列方向) 123.container &#123; flex-direction: row | row-reverse | column | column-reverse; &#125; 属性对应如下： row（默认值）：主轴为水平方向，起点在左端 row-reverse：主轴为水平方向，起点在右端 column：主轴为垂直方向，起点在上沿。 column-reverse：主轴为垂直方向，起点在下沿 如下图所示： flex-wrap弹性元素永远沿主轴排列，那么如果主轴排不下，通过flex-wrap决定容器内项目是否可换行 123.container &#123; flex-wrap: nowrap | wrap | wrap-reverse;&#125; 属性对应如下： nowrap（默认值）：不换行 wrap：换行，第一行在下方 wrap-reverse：换行，第一行在上方 默认情况是不换行，但这里也不会任由元素直接溢出容器，会涉及到元素的弹性伸缩 flex-flow是flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap 123.box &#123; flex-flow: &lt;flex-direction&gt; || &lt;flex-wrap&gt;;&#125; justify-content定义了项目在主轴上的对齐方式 123.box &#123; justify-content: flex-start | flex-end | center | space-between | space-around;&#125; 属性对应如下： flex-start（默认值）：左对齐 flex-end：右对齐 center：居中 space-between：两端对齐，项目之间的间隔都相等 space-around：两个项目两侧间隔相等 效果图如下： align-items定义项目在交叉轴上如何对齐 123.box &#123; align-items: flex-start | flex-end | center | baseline | stretch;&#125; 属性对应如下： flex-start：交叉轴的起点对齐 flex-end：交叉轴的终点对齐 center：交叉轴的中点对齐 baseline: 项目的第一行文字的基线对齐 stretch（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度 align-content定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用 123.box &#123; align-content: flex-start | flex-end | center | space-between | space-around | stretch;&#125; 属性对应如吓： flex-start：与交叉轴的起点对齐 flex-end：与交叉轴的终点对齐 center：与交叉轴的中点对齐 space-between：与交叉轴两端对齐，轴线之间的间隔平均分布 space-around：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍 stretch（默认值）：轴线占满整个交叉轴 效果图如下： 容器成员属性如下： order flex-grow flex-shrink flex-basis flex align-self order定义项目的排列顺序。数值越小，排列越靠前，默认为0 123.item &#123; order: &lt;integer&gt;;&#125; flex-grow上面讲到当容器设为flex-wrap: nowrap;不换行的时候，容器宽度有不够分的情况，弹性元素会根据flex-grow来决定 定义项目的放大比例（容器宽度&gt;元素总宽度时如何伸展） 默认为0，即如果存在剩余空间，也不放大 123.item &#123; flex-grow: &lt;number&gt;;&#125; 如果所有项目的flex-grow属性都为1，则它们将等分剩余空间（如果有的话） 如果一个项目的flex-grow属性为2，其他项目都为1，则前者占据的剩余空间将比其他项多一倍 弹性容器的宽度正好等于元素宽度总和，无多余宽度，此时无论flex-grow是什么值都不会生效 flex-shrink定义了项目的缩小比例（容器宽度&lt;元素总宽度时如何收缩），默认为1，即如果空间不足，该项目将缩小 123.item &#123; flex-shrink: &lt;number&gt;; /* default 1 */&#125; 如果所有项目的flex-shrink属性都为1，当空间不足时，都将等比例缩小 如果一个项目的flex-shrink属性为0，其他项目都为1，则空间不足时，前者不缩小 在容器宽度有剩余时，flex-shrink也是不会生效的 flex-basis设置的是元素在主轴上的初始尺寸，所谓的初始尺寸就是元素在flex-grow和flex-shrink生效前的尺寸 浏览器根据这个属性，计算主轴是否有多余空间，默认值为auto，即项目的本来大小，如设置了width则元素尺寸由width/height决定（主轴方向），没有设置则由内容决定 123.item &#123; flex-basis: &lt;length&gt; | auto; /* default auto */&#125; 当设置为0的是，会根据内容撑开 它可以设为跟width或height属性一样的值（比如350px），则项目将占据固定空间 flexflex属性是flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto，也是比较难懂的一个复合属性 123.item &#123; flex: none | [ &lt;&#x27;flex-grow&#x27;&gt; &lt;&#x27;flex-shrink&#x27;&gt;? || &lt;&#x27;flex-basis&#x27;&gt; ]&#125; 一些属性有： flex: 1 &#x3D; flex: 1 1 0% flex: 2 &#x3D; flex: 2 1 0% flex: auto &#x3D; flex: 1 1 auto flex: none &#x3D; flex: 0 0 auto，常用于固定尺寸不伸缩 flex:1 和 flex:auto 的区别，可以归结于flex-basis:0和flex-basis:auto的区别 当设置为0时（绝对弹性元素），此时相当于告诉flex-grow和flex-shrink在伸缩的时候不需要考虑我的尺寸 当设置为auto时（相对弹性元素），此时则需要在伸缩时将元素尺寸纳入考虑 注意：建议优先使用这个属性，而不是单独写三个分离的属性，因为浏览器会推算相关值 align-self允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性 默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch 123.item &#123; align-self: auto | flex-start | flex-end | center | baseline | stretch;&#125; 效果图如下： 三、应用场景在以前的文章中，我们能够通过flex简单粗暴的实现元素水平垂直方向的居中，以及在两栏三栏自适应布局中通过flex完成，这里就不再展开代码的演示 包括现在在移动端、小程序这边的开发，都建议使用flex进行布局","categories":[{"name":"css","slug":"css","permalink":"http://example.com/categories/css/"}],"tags":[{"name":"css","slug":"css","permalink":"http://example.com/tags/css/"}]},{"title":"BOM","slug":"BOM","date":"2017-08-02T00:06:25.000Z","updated":"2022-05-28T03:18:50.715Z","comments":true,"path":"2017/08/02/BOM/","link":"","permalink":"http://example.com/2017/08/02/BOM/","excerpt":"","text":"BOM定义BOM（Browser Object Model）即浏览器对象模型。 BOM提供了独立于内容而与浏览器窗口进行交互的对象； 由于BOM主要用于管理窗口与窗口之间的通讯，因此其核心对象是window； BOM由一系列相关的对象构成，并且每个对象都提供了很多方法与属性； BOM组成 window：代表整个浏览器窗口） Navigator：代表浏览器当前的信息； Location：代表浏览器当前的地址信息 History：代表浏览器的历史信息 Screen：代表用户的屏幕信息 Window对象BOM的核心是window对象,表示浏览器的实例。window对象在浏览器中有两重身份，一个是ECMAScript中的Global对象，另一个就是浏览器窗口的JavaScript接口。这意味着网页中定义的所有对象、变量和函数都以window作为其Global对象，都可以访问其上定义的parseInt()等全局方法。 Global作用域因为window对象被复用为ECMAScript的Global对象，所以通过var声明的所有全局变量和函数都会变成window对象的属性和方法。 12345var age = 29;var sayAge = () =&gt;alert(this.age);alert(window.age);sayAge();window.sayAge(); 这里，变量age和函数sayAge()被定义在全局作用域中，它们自动成为了window对象的成员。因此，变量age可以通过window.age来访问，而函数sayAge()也可以通过window.sayAge()来访问。因为sayAge()存在于全局作用域，this.age映射到window.age，所以就可以显示正确的结果了。 如果在这里使用let或const替代var，则不会把变量添加给全局对象: 12345let age = 29;const sayAge = () =&gt; alert(this.age);alert(window.age); // undefinedsayAge(); // undefinedwindow.sayAge(); // TypeError: window.sayAge is not a function 导航与打开新窗口window.open()方法可以用于导航到指定URL，也可以用于打开新浏览器窗口。这个方法接收4个参数：要加载的URL、目标窗口、特性字符串和表示新窗口在浏览器历史记录中是否替代当前加载页面的布尔值。通常，调用这个方法时只传前3个参数，最后一个参数只有在不打开新窗口时才会使用。 如果window.open()的第二个参数是一个已经存在的窗口或窗格（frame）的名字，则会在对应的窗口或窗格中打开URL。下面是一个例子： 1window.open(&quot;http://www.wrox.com/&quot;, &quot;topFrame&quot;); 执行这行代码的结果就如同用户点击了一个href属性为”http://www.wrox.com&quot;，target属性为&quot;topFrame&quot;的链接。如果有一个窗口名叫&quot;topFrame&quot;，则这个窗口就会打开这个URL；否则就会打开一个新窗口并将其命名为&quot;topFrame&quot;。第二个参数也可以是一个特殊的窗口名，比如_self、_parent、_top或_blank。 弹出窗口 如果window.open()的第二个参数不是已有窗口，则会打开一个新窗口或标签页。第三个参数，即特性字符串，用于指定新窗口的配置。如果没有传第三个参数，则新窗口（或标签页）会带有所有默认的浏览器特性（工具栏、地址栏、状态栏等都是默认配置）。如果打开的不是新窗口，则忽略第三个参数。 特性字符串是一个逗号分隔的设置字符串，用于指定新窗口包含的特性。下表列出了一些选项。 这些设置需要以逗号分隔的名值对形式出现，其中名值对以等号连接。 来看下面的例子： 1window.open(&quot;http://www.wrox.com/&quot;,&quot;wroxWindow&quot;,&quot;height=400,width=400,top=10,left=10,resizable=yes&quot;); 这行代码会打开一个可缩放的新窗口，大小为400像素×400像素，位于离屏幕左边及顶边各10像素的位置。 window.open()方法返回一个对新建窗口的引用。这个对象与普通window对象没有区别，只是为控制新窗口提供了方便。例如，某些浏览器默认不允许缩放或移动主窗口，但可能允许缩放或移动通过window.open()创建的窗口。跟使用任何window对象一样，可以使用这个对象操纵新打开的窗口。 123456let wroxWin = window.open(&quot;http://www.wrox.com/&quot;,&quot;wroxWindow&quot;,&quot;height=400,width=400,top=10,left=10,resizable=yes&quot;);// 缩放wroxWin.resizeTo(500, 500);// 移动wroxWin.moveTo(100, 100);wroxWin.close();//关闭新打开的窗口 定时器setTimeout()的参数 code&#x2F;function：必需。要调用一个代码串，也可以是一个函数，或者函数名。 milliseconds：可选。执行或调用 code&#x2F;function 需要等待的时间，以毫秒计。默认为 0。 param1, …：可选，多个。 传给执行函数的其他参数（IE9 及其更早版本不支持该参数）。 使用函数名称 12345678function myFunction() &#123; myVar = setTimeout(alertFunc, 3000);&#125; function alertFunc() &#123; alert(&quot;Hello!&quot;);&#125; 使用匿名函数 12345var myWindow = window.open(&quot;&quot;, &quot;&quot;, &quot;width=200, height=100&quot;);myWindow.document.write(&quot;&lt;p&gt;新窗口&#x27;&lt;/p&gt;&quot;);setTimeout(function()&#123; myWindow.close() &#125;, 3000); 给函数传参 12345678910function alertFunc(r, g)&#123; alert(r + g); &#125;function myStartFunction() &#123; myVar = setTimeout(alertFunc, 2000, &quot;Runoob&quot;, &quot;Google&quot;);&#125;//使用匿名函数function myStartFunction() &#123; myVar = setTimeout(function()&#123; alertFunc(&quot;Runoob&quot;, &quot;Google&quot;); &#125;, 2000);&#125; setTimeout的特点 setTimeout() 方法用于在指定的毫秒数后调用函数或计算表达式。 方法只会被调用一次1000的单位是毫秒，1000毫秒&#x3D;1秒 setInterval()的特点 setInterval() 方法可按照指定的周期来调用函数或计算表达式。 setInterval() 方法会不停地调用函数1000的单位是毫秒，1000毫秒&#x3D;1秒 12345678910111213141516var myVar;function myFunction() &#123; myVar = setTimeout(function()&#123; alert(&quot;Hello&quot;); &#125;, 3000);&#125;function myStopFunction() &#123; clearTimeout(myVar);&#125;var myVar;function myFunction() &#123; myVar = setInterval(function()&#123; alert(&quot;Hello&quot;); &#125;, 3000);&#125; function myStopFunction() &#123; clearInterval(myVar);&#125; clearTimeout():可取消由 setTimeout() 方法设置的定时操作 clearInterval():可取消由 setInterval() 函数设定的定时执行操作 看到了setTimeout函数。 它会在给定的毫秒数之后，调度另一个函数在稍后调用。 有时需要取消调度的函数。可以存储setTimeout的返回值，并将作为参数调用clearTimeout。 12345678let bombTimer = setTimeout(() =&gt; &#123; console.log(&quot;BOOM!&quot;);&#125;, 500);if (Math.random() &lt; 0.5) &#123; // 50% chance console.log(&quot;Defused.&quot;); clearTimeout(bombTimer);&#125; 函数cancelAnimationFrame作用与clearTimeout相同，使用requestAnimationFrame的返回值调用该函数，可以取消帧（假定函数还没有被调用）。 还有setInterval和clearInterval这种相似的函数，用于设置计时器，每隔一定毫秒数重复执行一次。 12345678let ticks = 0;let clock = setInterval(() =&gt; &#123; console.log(&quot;tick&quot;, ticks++); if (ticks == 10) &#123; clearInterval(clock); console.log(&quot;stop.&quot;); &#125;&#125;, 200); 降频某些类型的事件可能会连续、迅速触发多次（例如mousemove和scroll事件）。处理这类事件时，你必须小心谨慎，防止处理任务耗时过长，否则处理器会占据过多事件，导致用户与文档交互变得非常慢。 若你需要在这类处理器中编写一些重要任务，可以使用setTimeout来确保不会频繁进行这些任务。我们通常称之为“事件降频（Debounce）”。有许多方法可以完成该任务。 在第一个示例中，当用户输入某些字符时，我们想要有所反应，但我们不想在每个按键事件中立即处理该任务。当用户输入过快时，我们希望暂停一下然后进行处理。我们不是立即在事件处理器中执行动作，而是设置一个定时器。我们也会清除上一次的定时器（如果有），因此当两个事件触发间隔过短（比定时器延时短），就会取消上一次事件设置的定时器。 123456789&lt;textarea&gt;Type something here...&lt;/textarea&gt;&lt;script&gt; let textarea = document.querySelector(&quot;textarea&quot;); let timeout; textarea.addEventListener(&quot;input&quot;, () =&gt; &#123; clearTimeout(timeout); timeout = setTimeout(() =&gt; console.log(&quot;Typed!&quot;), 500); &#125;);&lt;/script&gt; 将undefined传递给clearTimeout或在一个已结束的定时器上调用clearTimeout是没有效果的。因此，我们不需要关心何时调用该方法，只需要每个事件中都这样做即可。 如果我们想要保证每次响应之间至少间隔一段时间，但不希望每次事件发生时都重置定时器，而是在一连串事件连续发生时能够定时触发响应，那么我们可以使用一个略有区别的方法来解决问题。例如，我们想要响应&quot;mousemove&quot;事件来显示当前鼠标坐标，但频率只有 250ms。 12345678910111213&lt;script&gt; let scheduled = null; window.addEventListener(&quot;mousemove&quot;, event =&gt; &#123; if (!scheduled) &#123; setTimeout(() =&gt; &#123; document.body.textContent = `Mouse at $&#123;scheduled.pageX&#125;, $&#123;scheduled.pageY&#125;`; scheduled = null; &#125;, 250); &#125; scheduled = event; &#125;);&lt;/script&gt; location对象location是最有用的BOM对象之一，提供了当前窗口中加载文档的信息，以及通常的导航功能。这个对象独特的地方在于，它既是window的属性，也是document的属性。也就是说，window.location和document.location指向同一个对象。location对象不仅保存着当前加载文档的信息，也保存着把URL解析为离散片段后能够通过属性访问的信息。 假设浏览器当前加载的URL是http://foouser:barpassword@www.wrox.com:80/WileyCDA/?q=javascript#contents，location对象的内容如下表所示。 查找字符串location的多数信息都可以通过上面的属性获取。但是URL中的查询字符串并不容易使用。虽然location.search返回了从问号开始直到URL末尾的所有内容，但没有办法逐个访问每个查询参数。下面的函数解析了查询字符串，并返回一个以每个查询参数为属性的对象： 123456789101112131415let getQueryStringArgs = function() &#123; // 取得没有开头问号的查询字符串 let qs = (location.search.length &gt; 0 ? location.search.substring(1) : &quot;&quot;), // 保存数据的对象 args = &#123;&#125;; // 把每个参数添加到 args 对象 for (let item of qs.split(&quot;&amp;&quot;).map(kv =&gt; kv.split(&quot;=&quot;))) &#123; let name = decodeURIComponent(item[0]), value = decodeURIComponent(item[1]); if (name.length) &#123; args[name] = value; &#125; &#125; return args;&#125; 这个函数首先删除了查询字符串开头的问号，当然前提是location.search必须有内容。解析后的参数将被保存到args对象，这个对象以字面量形式创建。接着，先把查询字符串按照&amp;分割成数组，每个元素的形式为name&#x3D;value。for循环迭代这个数组，将每一个元素按照&#x3D;分割成数组，这个数组第一项是参数名，第二项是参数值。参数名和参数值在使用decodeURIComponent()解码后（这是因为查询字符串通常是被编码后的格式）分别保存在name和value变量中。最后，name作为属性而value作为该属性的值被添加到args对象。这个函数可以像下面这样使用： 1234// 假设查询字符串为?q=javascript&amp;num=10let args = getQueryStringArgs();alert(args[&quot;q&quot;]); // &quot;javasalert(args[&quot;num&quot;]); // &quot;10&quot; 操作地址可以通过修改location对象修改浏览器的地址。首先，最常见的是使用assign()方法并传入一个URL，如下所示： 1location.assign(&quot;http://www.wrox.com&quot;) 这行代码会立即启动导航到新URL的操作，同时在浏览器历史记录中增加一条记录。如果给location.href或window.location设置一个URL，也会以同一个URL值调用assign()方法。比如，下面两行代码都会执行与显式调用assign()一样的操作： 12window.location=&quot;http://www.wrox.com&quot;;location.href=&quot;http://www.wrox.com&quot;; 在这3种修改浏览器地址的方法中，设置location.href是最常见的。 修改location对象的属性也会修改当前加载的页面。其中，hash、search、hostname、pathname和port属性被设置为新值之后都会修改当前URL，如下面的例子所示： 1234567891011//假设当前URL为http://www.wrox.com/WileyCDA///把URL修改为http://www.wrox.com/WileyCDA/#section1location.hash=&quot;#section1&quot;;//把URL修改为http://www.wrox.com/WileyCDA/?q=javascriptlocation.search=&quot;?q=javascript&quot;;//把URL修改为http://www.somewhere.com/WileyCDA/location.hostname=&quot;www.somewhere.com&quot;;//把URL修改为http://www.somewhere.com/mydir/location.pathname=&quot;mydir&quot;;//把URL修改为http://www.somewhere.com:8080/WileyCDA/location.port=8080; 除了hash之外，只要修改location的一个属性，就会导致页面重新加载新URL。 注意修改hash的值会在浏览器历史中增加一条新记录。在早期的IE中，点击“后退”和“前进”按钮不会更新hash属性，只有点击包含散列的URL才会更新hash的值。 在以前面提到的方式修改URL之后，浏览器历史记录中就会增加相应的记录。当用户单击“后退”按钮时，就会导航到前一个页面。如果不希望增加历史记录，可以使用replace()方法。这个方法接收一个URL参数，但重新加载后不会增加历史记录。调用replace()之后，用户不能回到前一页。比如下面的例子： 123456789101112&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;title&gt;You won&#x27;t be able to get back here&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;Enjoy this page for a second, because you won&#x27;t be coming back here.&lt;/p&gt;&lt;script&gt; setTimeout(() =&gt; location.replace(&quot;http://www.wrox.com/&quot;), 1000);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 浏览器加载这个页面1秒之后会重定向到www.wrox.com。此时，“后退”按钮是禁用状态，即不能返回这个示例页面，除非手动输入完整的URL。 最后一个修改地址的方法是reload()，它能重新加载当前显示的页面。调用reload()而不传参数，页面会以最有效的方式重新加载。也就是说，如果页面自上次请求以来没有修改过，浏览器可能会从缓存中加载页面。如果想强制从服务器重新加载，可以像下面这样给reload()传个true： location.reload();&#x2F;&#x2F;重新加载，可能是从缓存加载 location.reload(true);&#x2F;&#x2F;重新加载，从服务器加载 脚本中位于reload()调用之后的代码可能执行也可能不执行，这取决于网络延迟和系统资源等因素。为此，最好把reload()作为最后一行代码。 navigator对象navigator是由NetscapeNavigator2最早引入浏览器的，现在已经成为客户端标识浏览器的标准。只要浏览器启用JavaScript，navigator对象就一定存在。但是与其他BOM对象一样，每个浏览器都支持自己的属性。 navigator属性如下表： appCodeName ：返回浏览器的代码名。 appMinorVersion：返回浏览器的次级版本。 appName：返回浏览器的名称。 appVersion ：返回浏览器的平台和版本信息。 browserLanguage ：返回当前浏览器的语言。 cookieEnabled：返回指明浏览器中是否启用 cookie 的布尔值。 cpuClass ：返回浏览器系统的 CPU 等级。 onLine：返回指明系统是否处于脱机模式的布尔值。 platform：返回运行浏览器的操作系统平台。 systemLanguage：返回 OS 使用的默认语言。 userAgent ：返回由客户机发送服务器的 user-agent 头部的值。 userLanguage ：返回 OS 的自然语言设置。 我们使用的比较多的是他的userAgent，经常需要判断的情况有： （1）PC还是移动端 （2）安卓还是IOS （3）浏览器的类型 示例代码： 123456789101112131415161718var browser=&#123; versions:function()&#123; var u = navigator.userAgent, app = navigator.appVersion; return &#123; //移动终端浏览器版本信息 trident: u.indexOf(&#x27;Trident&#x27;) &gt; -1, //IE内核 presto: u.indexOf(&#x27;Presto&#x27;) &gt; -1, //opera内核 webKit: u.indexOf(&#x27;AppleWebKit&#x27;) &gt; -1, //苹果、谷歌内核 gecko: u.indexOf(&#x27;Gecko&#x27;) &gt; -1 &amp;&amp; u.indexOf(&#x27;KHTML&#x27;) == -1, //火狐内核 mobile: !!u.match(/AppleWebKit.*Mobile.*/), //是否为移动终端 ios: !!u.match(/\\(i[^;]+;( U;)? CPU.+Mac OS X/), //ios终端 android: u.indexOf(&#x27;Android&#x27;) &gt; -1 || u.indexOf(&#x27;Linux&#x27;) &gt; -1, //android终端或uc浏览器 iPhone: u.indexOf(&#x27;iPhone&#x27;) &gt; -1 , //是否为iPhone或者QQHD浏览器 iPad: u.indexOf(&#x27;iPad&#x27;) &gt; -1, //是否iPad webApp: u.indexOf(&#x27;Safari&#x27;) == -1 //是否web应该程序，没有头部与底部 &#125;; &#125;(), language:(navigator.browserLanguage || navigator.language).toLowerCase()&#125; screen对象window的另一个属性screen对象，是为数不多的几个在编程中很少用的JavaScript对象。这个对象中保存的纯粹是客户端能力信息，也就是浏览器窗口外面的客户端显示器的信息，比如像素宽度和像素高度。每个浏览器都会在screen对象上暴露不同的属性。 下表总结了这些属性: availHeight 屏幕像素高度减去系统组件高度（只读） availLeft 没有被系统组件占用的屏幕的最左侧像素（只读） availTop 没有被系统组件占用的屏幕的最顶端像素（只读） availWidth 屏幕像素宽度减去系统组件宽度（只读） colorDepth 表示屏幕颜色的位数；多数系统是 32（只读） height 屏幕像素高度 left 当前屏幕左边的像素距离 pixelDepth 屏幕的位深（只读） top 当前屏幕顶端的像素距离 width 屏幕像素宽度 orientation 返回 Screen Orientation API中屏幕的朝向 history对象history对象表示当前窗口首次使用以来用户的导航历史记录。因为history是window的属性，所以每个window都有自己的history对象。出于安全考虑，这个对象不会暴露用户访问过的 URL，但可以通过它在不知道实际URL的情况下前进和后退。 导航go()方法可以在用户历史记录中沿任何方向导航，可以前进也可以后退。这个方法只接收一个参数，这个参数可以是一个整数，表示前进或后退多少步。负值表示在历史记录中后退，而正值表示在历史记录中前进。 下面来看几个例子： 123456// 后退一页history.go(-1);// 前进一页history.go(1);// 前进两页history.go(2); go()有两个简写方法：back()和forward()。顾名思义，这两个方法模拟了浏览器的后退按钮和前进按钮： 1234//后退一页history.back();//前进一页history.forward(); history对象还有一个length属性，表示历史记录中有多个条目。这个属性反映了历史记录的数量，包括可以前进和后退的页面。对于窗口或标签页中加载的第一个页面，history.length等于1。 通过以下方法测试这个值，可以确定用户浏览器的起点是不是你的页面： 123if (history.length == 1)&#123;// 这是用户窗口中的第一个页面&#125; history对象通常被用于创建“后退”和“前进”按钮，以及确定页面是不是用户历史记录中的第一条记录。","categories":[{"name":"BOM","slug":"BOM","permalink":"http://example.com/categories/BOM/"}],"tags":[{"name":"BOM","slug":"BOM","permalink":"http://example.com/tags/BOM/"}]},{"title":"DOM事件","slug":"DOM事件","date":"2017-07-21T13:37:27.000Z","updated":"2022-05-28T02:30:02.728Z","comments":true,"path":"2017/07/21/DOM事件/","link":"","permalink":"http://example.com/2017/07/21/DOM%E4%BA%8B%E4%BB%B6/","excerpt":"","text":"事件DOM事件的定义定义:DOM事件是由DOM中的事件源触发，可以引发事件响应的操作。 DOM事件流事件发生时会在元素节点与根节点之间按照特定的顺序传播，路径经过的所有节点都会收到该事件，这个传播过程即DOM事件流。 DOM标准规定事件流包括三个阶段： 捕获阶段： 事件自上而下传播，从Document根节点到再到 处理阶段： 目标节点（）处理事件的阶段 冒泡阶段： 事件自下而上传播，依次传播回Document根节点。 案例—–DOM事件流 三个逐层嵌套的圆，最里层的圆被点击，事件逐层传播。 123456789101112131415161718192021&lt;div id=&quot;outer&quot;&gt; &lt;div id=&quot;middle&quot;&gt; &lt;div id=&quot;inner&quot;&gt; Click me! &lt;/div&gt; &lt;/div&gt;&lt;/div&gt;&lt;script&gt; var innerCircle = document.getElementById(&#x27;inner&#x27;); innerCircle.onclick = function()&#123; alert(&quot;最内层的圆&quot;); &#125; var middleCircle = document.getElementById(&#x27;middle&#x27;); middleCircle.onclick = function()&#123; alert(&quot;中间层的圆&quot;); &#125; var outerCircle = document.getElementById(&#x27;outer&#x27;); outerCircle.onclick = function()&#123; alert(&quot;最外层的圆&quot;); &#125;&lt;/script&gt; 备注：触发一个DOM事件，会产生一个事件对象；JavaScript通过事件对象获取事件的信息。 事件对象触发DOM事件时，在事件处理函数中产生一个对应的事件对象 事件对象是在触发DOM事件时，在事件处理函数中产生并代表该事件状态的对象。 事件对象包含所有与事件有关的信息，包括导致事件被触发的元素、事件的类型，以及与特定事件相关的其他信息。 事件对象通常用event表示，可以作为参数传递给事件处理函数。 1）标准属性：type ：返回当前 Event 对象表示的事件的名称； bubbles ：返回布尔值，指示事件是否是起泡事件类型； cancelable ：返回布尔值，指示事件是否可拥可取消的默认动作； currentTarget ：返回其事件监听器触发该事件的元素； eventPhase ：返回事件传播的当前阶段； target ：返回触发此事件的元素（事件的目标节点）； timeStamp ：返回事件生成的日期和时间； 2）鼠标&#x2F;键盘属性altKey ：返回当事件被触发时，”ALT” 是否被按下； button ：返回当事件被触发时，哪个鼠标按钮被点击； clientX ：返回当事件被触发时，鼠标指针的水平坐标； clientY ：返回当事件被触发时，鼠标指针的垂直坐标； ctrlKey ：返回当事件被触发时，”CTRL” 键是否被按下； metaKey ：返回当事件被触发时，”meta” 键是否被按下； relatedTarget ：返回与事件的目标节点相关的节点； screenX ：返回当某个事件被触发时，鼠标指针的水平坐标； screenY ：返回当某个事件被触发时，鼠标指针的垂直坐标； shiftKey ：返回当事件被触发时，”SHIFT” 键是否被按下； 内联模式事件绑定直接写在html上 这里button的click事件的绑定直接写在html中 脚本模型脚本模型是通过DOM选择器选中操作元素，单独封装事件操作在Js中，把事件操作与HTML代码分离的一种事件操作形式。 上一节讲了内联模式,内联模式的缺点：函数违反了标记&#x2F;行为展现&#x2F;Javascript分离的层次分离原则。 案例：灯泡点亮 创建html页面，页面内如图有一图片；编写JS代码，给图片增加鼠标移过事件，触发函数；编写JS函数，实现给页面元素属性赋值。 事件函数鼠标事件 鼠标点击 鼠标点击事件包括 4 个：click（单击）、dblclick（双击）、mousedown（按下）和 mouseup（松开）。其中 click 事件类型比较常用，而 mousedown 和 mouseup 事件类型多用在鼠标拖放、拉伸操作中。当这些事件处理函数的返回值为 false 时，会禁止绑定对象的默认行为。 示例 在下面示例中，当定义超链接指向自身时（多在设计过程中 href 属性值暂时使用 “#”或“?”表示），可以取消超链接被单击时的默认行为，即刷新页面。 123456789101112&lt;a name=&quot;tag&quot; id=&quot;tag&quot; href=&quot;#&quot;&gt;a&lt;/a&gt;&lt;script&gt;var a = document.getElementsByTagName(&quot;a&quot;); //获取页面中所有超链接元素for (var i = 0; i &lt; a.length; i ++) &#123; //遍历所有a元素 if ((new RegExp(window.location.href)).test(a[i].href)) &#123; //如果当前超链接href属性中包含本页面的URL信息 a[i].onclick = function () &#123; //则为超链接注册鼠标单击事件 return false; //将禁止超链接的默认行为 &#125; &#125;&#125;&lt;/script&gt; 鼠标移动 mousemove 事件类型是一个实时响应的事件，当鼠标指针的位置发生变化时（至少移动一个像素），就会触发 mousemove 事件。该事件响应的灵敏度主要参考鼠标指针移动速度的快慢以及浏览器跟踪更新的速度。 示例下面示例演示了如何综合应用各种鼠标事件实现页面元素拖放操作的设计过程。实现拖放操作设计需要解决以下几个问题。定义拖放元素为绝对定位以及设计事件的响应过程，这个比较容易实现。 清楚几个坐标概念：按下鼠标时的指针坐标，移动中当前鼠标指针坐标，松开鼠标时的指针坐标，拖放元素的原始坐标，拖动中的元素坐标。 算法设计：按下鼠标时，获取被拖放元素和鼠标指针的位置，在移动中实时计算鼠标偏移的距离，并利用该偏移距离加上被拖放元素的原坐标位置，获得拖放元素的实时坐标。 如下图所示，其中变量 ox 和 oy 分别记录按下鼠标时被拖放元素的纵横坐标值，它们可以通过事件对象的 offsetLeft 和 offsetTop 属性获取。变量 mx 和 my 分别表示按下鼠标时，鼠标指针的坐标位置。而 event.mx 和 event.my 是事件对象的自定义属性，用它们来存储当鼠标移动时鼠标指针的实时位置。 当获取了上面 3 对坐标值之后，就可以动态计算拖动中元素的实时坐标位置，即 x 轴值为 ox+event.mx-mx，y 轴为 oy+event.my-my。当释放鼠标按钮时，就可以释放事件类型，并记下松开鼠标指针时拖动元素的坐标值，以及鼠标指针的位置，留待下一次拖放操作时调用。 整个拖放操作的示例代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;div id=&quot;box&quot; &gt;&lt;/div&gt;&lt;script&gt; // 初始化拖放对象 var box = document.getElementById(&quot;box&quot;); // 获取页面中被拖放元素的引用指针 box.style.position = &quot;absolute&quot;; // 绝对定位 box.style.width = &quot;160px&quot;; // 定义宽度 box.style.height = &quot;120px&quot;; // 定义高度 box.style.backgroundColor = &quot;red&quot;; // 定义背景色 // 初始化变量，标准化事件对象 var mx, my, ox, oy; // 定义备用变量 function e(event)&#123; // 定义事件对象标准化函数 if( ! event)&#123; // 兼容IE浏览器 event = window.event; event.target = event.srcElement; event.layerX = event.offsetX; event.layerY = event.offsetY; &#125; event.mx = event.pageX || event.clientX + document.body.scrollLeft; // 计算鼠标指针的x轴距离 event.my = event.pageY || event.clientY + document.body.scrollTop; // 计算鼠标指针的y轴距离 return event; // 返回标准化的事件对象 &#125; // 定义鼠标事件处理函数 document.onmousedown = function(event)&#123; // 按下鼠标时，初始化处理 event = e(event); // 获取标准事件对象 o = event.target; // 获取当前拖放的元素 ox = parseInt(o.offsetLeft); // 拖放元素的x轴坐标 oy = parseInt(o.offsetTop); // 拖放元素的y轴坐标 mx = event.mx; // 按下鼠标指针的x轴坐标 my = event.my; // 按下鼠标指针的y轴坐标 document.onmousemove = move; // 注册鼠标移动事件处理函数 document.onmouseup = stop; // 注册松开鼠标事件处理函数 &#125; function move(event)&#123; // 鼠标移动处理函数 event = e(event); o.style.left = ox + event.mx - mx + &quot;px&quot;; // 定义拖动元素的x轴距离 o.style.top = oy + event.my - my + &quot;px&quot;; // 定义拖动元素的y轴距离 &#125; function stop(event)&#123; // 松开鼠标处理函数 event = e(event); ox = parseInt(o.offsetLeft); // 记录拖放元素的x轴坐标 oy = parseInt(o.offsetTop); // 记录拖放元素的y轴坐标 mx = event.mx ; // 记录鼠标指针的x轴坐标 my = event.my ; // 记录鼠标指针的y轴坐标 o = document.onmousemove = document.onmouseup = null; // 释放所有操作对象 &#125;&lt;/script&gt; 鼠标经过 鼠标经过包括移过和移出两种事件类型。当移动鼠标指针到某个元素上时，将触发 mouseover 事件；而当把鼠标指针移出某个元素时，将触发 mouseout 事件。如果从父元素中移到子元素中时，也会触发父元素的 mouseover 事件类型。 示例 在下面示例中，分别为3个嵌套的div元素定义了mouseover和mouseout事件处理函数，这样当从外层的父元素中移动到内部的子元素中时，将会触发父元素的 mouseover 事件类型，但是不会触发 mouseout 事件类型。 1234567891011121314151617&lt;div&gt; &lt;div&gt; &lt;div&gt;盒子&lt;/div&gt; &lt;/div&gt;&lt;/div&gt;&lt;script&gt; var div = document.getElementsByTagName(&quot;div&quot;); // 获取3个嵌套的div元素 for(var i=0;i&lt;div.length;i++)&#123; // 遍历嵌套的div元素 div[i].onmouseover = function(e)&#123; // 注册移过事件处理函数 this.style.border = &quot;solid blue&quot;; &#125; div[i].onmouseout = function()&#123; // 注册移出事件处理函数 this.style.border = &quot;solid red&quot;; &#125; &#125;&lt;/script&gt; 鼠标来源 当一个事件发生后，可以使用事件对象的 target 属性获取发生事件的节点元素。如果在 IE 事件模型中实现相同的目标，可以使用 srcElement 属性。 示例： 在下面示例中，当鼠标移过页面中的 div 元素时，会弹出提示对话框，提示当前元素的节名称。 123456789&lt;div&gt;div元素&lt;/div&gt;&lt;script&gt; var div = document.getElementsByTagName(&quot;div&quot;)[0]; div.onmouseover = function(e)&#123; // 注册mouseover事件处理函数 var e = e || window.event; // 标准化事件对象，兼容DOM和IE事件模型 var o = e.target || e.srcElement; // 标准化事件属性，获取当前事件的节点 alert(o.tagName); // 返回字符串“DIV” &#125;&lt;/script&gt; 在 DOM 事件模型中还定义了 currentTarget 属性，当事件在传播过程中（如捕获和冒泡阶段）时，该属性值与 target 属性值不同。因此，一般在事件处理函数中，有你哥哥使用该属性而不是 this 关键词获取当前对象。 除了使用上面提到的通用事件属性外，如果想获取鼠标指针来移动某个元素，在 DOM 事件模型中可以使用 relatedTarget 属性获取当前事件对象的相关节点元素；而在 IE 事件模型中，可以使用 fromElement 获取 mouseover 事件中鼠标移到过的元素，使用 toElement 属性获取在 mouseout 事件中鼠标移到的文档元素。 示例2： 在下面示例中，当鼠标移到 div 元素上时，会弹出“BODY”字符提示信息，说明鼠标指针是从 body 元素过来的；而移开鼠标指针时，又弹出“BODY”字符提示信息，说明离开 div 元素将要移到的元素。 1234567891011121314&lt;div&gt;div元素&lt;/div&gt;&lt;script&gt; var div = document.getElementsByTagName(&quot;div&quot;)[0]; div.onmouseover = function(e)&#123; var e = e || window.event; var o = e.relatedTarget || e.fromElement; //标准化事件属性，获取与当前事件相关的节点 alert(o.tagName); &#125; div.onmouseout = function(e)&#123; var e = e || window.event; var o = e.relatedTarget || e.toElement; // 标准化事件属性，获取与当前事件相关的节点 alert(o.tagName); &#125;&lt;/script&gt; 键盘事件在JavaScript中，当用户操作键盘时，会触发键盘事件，键盘事件主要包括下面3种类型： keydown：在键盘上按下某个键时触发。如果按住某个键，会不断触发该事件，但是Opera浏览器不支持这种连续操作。该事件处理函数返回false时，会取消默认的动作（如输入的键盘字符，在IE和Safari浏览器下还会禁止keypress事件响应）。 keypress：按下某个键盘键并释放时触发。如果按住某个键，会不断触发该事件。该事件处理函数返回false时，会取消默认的动作（如输入的键盘字符）。 keyup：释放某个键盘键时触发。该事件仅在松开键盘时触发一次，不是一个持续的响应状态。 当获取用户正按下键码时，可以使用keydown、keypress和keyup事件获取这些信息。其中keydown和keypress事件基本上是同义事件，它们的表现也完全一致，不过一些浏览器不允许使用keypress事件获取按键信息。所有元素都支持键盘事件，但键盘事件多被应用在表单输入中。 示例 下面示例实时捕获键盘操作的各种细节，即键盘响应事件类型及对应的键值。 123456789101112&lt;textarea id=&quot;key&quot;&gt;&lt;/textarea&gt;&lt;script&gt; var key = document.getElementById(&quot;key&quot;); key.onkeydown =f; //注册keydown事件处理函数 key.onkeyup = f; //注册keyup事件处理函数 key.onkeypress = f; //注册keypress事件处理函数 function f (e) &#123; var e = e || window.event; //标准化事件处理 var s = e.type + &quot; &quot; + e.keyCode; //获取键盘事件类型和按下的值 key.value = s; &#125;&lt;/script&gt; 键盘事件属性 键盘定义了很多属性，如下表所示。利用这些属性可以精确控制键盘操作。键盘事件属性一般只在键盘相关事件发生时才会存在于事件对象中，但是 ctrlKey 和 shiftKey 属性除外，因为它们可以在水保事件中存在。例如，当按下 Ctrl 或Shift 键时单击鼠标操作。 keyCode ：该属性包含键盘中对应键位的键值 charCode ：该属性包含键盘中对应键位的 Unicode 编码，仅 DOM 支持 target：发生事件的节点（包含元素），仅 DOM 支持 srcElement ：发生事件的元素，仅 IE 支持 shiftKey：是否按下 Shift 键，如果按下返回 true，否则为false ctrlKey：是否按下 Ctrl 键，如果按下返回 true，否则为false altKey：是否按下 Alt 键，如果按下返回 true，否则为false metaKey：是否按下 Mtea 键，如果按下返回 true，否则为false，仅 DOM 支持 示例： ctrlKey和shiftKey属性可存在于键盘和鼠标事件中，表示键盘上的Ctrl和Shift键是否被按住。下面示例能够监测Ctrl 和Shift键是否被同时按下。如果同时按下，且鼠标单击某个页面元素，则会把该元素从页面中删除。 1234567document.onclick = function (e) &#123; var e = e || window.event; //标准化事件对象 var t = e.target || e.srcElement; //获取发生事件的元素，兼容IE和DOM if (e.ctrlKey &amp;&amp; e.shiftKey) &#123; //如果同时按下Ctrl和Shift键 t.parentNode.removeChild(t); //移出当前元素 &#125;&#125; 09（数字键）：4857 AZ（字母键）：6590 Backspace（退格键）：8 Tab（制表键）：9 Enter（回车键）：13 Space（空格键）：32 Left arrow（左箭头键）：37 Top arrow（上箭头键）：38 Right arrow（右箭头键）：39 Down arrow（下箭头键）：40 示例2： 下面示例演示了如何使用方向键控制页面元素的移动效果。 12345678910111213141516171819202122232425262728&lt;div id=&quot;box&quot;&gt;&lt;/div&gt;&lt;script&gt; var box = document.getElementById(&quot;box&quot;); // 获取页面元素的引用指针 box.style.position = &quot;absolute&quot;; // 色块绝对定位 box.style.width = &quot;20px&quot;; // 色块宽度 box.style.height = &quot;20px&quot;; // 色块高度 box.style.backgroundColor = &quot;red&quot;; // 色块背景 document.onkeydown = keyDown; //在Document对象中注册keyDown事件处理函数 function keyDown(event)&#123; // 方向键控制元素移动函数 var event = event || window.event; // 标准化事件对象 switch(event.keyCode)&#123; // 获取当前按下键盘键的编码 case 37 : // 按下左箭头键，向左移动5个像素 box.style.left = box.offsetLeft - 5 + &quot;px&quot;; break; case 39 : // 按下右箭头键，向右移动5个像素 box.style.left = box.offsetLeft + 5 + &quot;px&quot;; break; case 38 : // 按下上箭头键，向上移动5个像素 box.style.top = box.offsetTop - 5 + &quot;px&quot;; break; case 40 : // 按下下箭头键，向下移动5个像素 box.style.top = box.offsetTop + 5 + &quot;px&quot;; break; &#125; return false &#125;&lt;/script&gt; 在上面示例中，首先获取页面元素，通过 CSS 脚本控制元素绝对定位、大小和背景色。然后在 document 对象上注册鼠标按下事件类型处理函数，在事件回调函数 keyDown() 中侦测当前按下的方向键，并决定定位元素在窗口中的位置。其中元素的 offsetLeft 和 offsetTop 属性可以存取它在页面中的位置。 键盘响应顺序 当按下键盘时，会连续触发多个事件，它们将按如下顺序发生。 对于字符键来说，键盘事件的响应顺序：keydown → keypress → keyup。 对于非字符键（如功能键或特殊键）来说，键盘事件的相应顺序：keydown → keyup。 如果按下字符键不放，则 keydown 和 keypress 事件将逐个持续发生，直至松开按键。 如果按下非字符键不放，则只有 keydown 事件持续发生，直至松开按键。 示例 下面设计一个简单示例，以获取键盘事件相应顺序。 12345678910111213&lt;textarea id=&quot;text&quot; cols=&quot;26&quot; rows=&quot;16&quot;&gt;&lt;/textarea&gt;&lt;script&gt; var n = 1; // 定义编号变量 var text = document.getElementById(&quot;text&quot;); // 获取文本区域的引用指针 text.onkeydown = f; // 注册keydown事件处理函数 text.onkeyup = f; // 注册keyup事件处理函数 text.onkeypress = f; // 注册keypress事件处理函数 function f(e)&#123; // 事件调用函数 var e = e || window.event; // 标准化事件对象 text.value += (n++) + &quot;=&quot; + e.type +&quot; (keyCode=&quot; + e.keyCode + &quot;)\\n&quot;; //捕获事件响应信息 &#125;&lt;/script&gt; 表单事件onblur:元素失去焦点时触发 123456789101112&lt;script type=&quot;text/javascript&quot;&gt;function upperCase()&#123; var x=document.getElementById(&quot;fname&quot;).value document.getElementById(&quot;fname&quot;).value=x.toUpperCase()&#125;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;输入您的姓名：&lt;input type=&quot;text&quot; id=&quot;fname&quot; onblur=&quot;upperCase()&quot; /&gt;&lt;/body&gt; onfocus:元素获取焦点时触发 123456789101112131415&lt;html&gt;&lt;head&gt;&lt;script type=&quot;text/javascript&quot;&gt;function setStyle(x)&#123; document.getElementById(x).style.background=&quot;yellow&quot;&#125;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;First name: &lt;input type=&quot;text&quot; onfocus=&quot;setStyle(this.id)&quot; id=&quot;fname&quot; /&gt;&lt;br /&gt;Last name: &lt;input type=&quot;text&quot; onfocus=&quot;setStyle(this.id)&quot; id=&quot;lname&quot; /&gt;&lt;/body&gt;&lt;/html&gt; onsubmit:表单提交时触发 12345678910111213141516171819202122232425262728&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;onsubmit用户提交,submit属性,事件&lt;/title&gt;&lt;/head&gt;&lt;script type=&quot;text/javascript&quot;&gt; function test()&#123; var s1 =document.mianform.user.value; var s2 = document.mianform.pwd.value ; if(s1 == &quot;&quot;||s2 ==&quot;&quot;)&#123; alert(&#x27;请将内容填写完整&#x27;); return false ;//false不提交 &#125; return true ; // true提交 &#125;&lt;/script&gt;&lt;body&gt; &lt;form name=&quot;mianform&quot; onsubmit=&quot;return test()&quot;&gt; &lt;label&gt;姓名:&lt;/label&gt; &lt;input type=&quot;text&quot; name=&quot;user&quot; onfocus=&quot;console.log(&#x27;点击这里输入用户名&#x27;);&quot; onblur=&quot;console.log(&#x27;文本失去焦点&#x27;);&quot;&gt; &lt;br&gt; &lt;label&gt;密码:&lt;/label&gt; &lt;input type=&quot;password&quot; name=&quot;pwd&quot; &gt; &lt;br&gt; &lt;input type=&quot;submit&quot; value=&quot;提交&quot; &gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; onreset:表单重置时触发 onchange:表单域里的内容改变时触发 onselect:用户选取表单域里的文本时触发 12345678910111213141516&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot;&gt;&lt;title&gt; 内容选中事件 &lt;/title&gt;&lt;script type=&quot;text/javascript&quot;&gt; function message()&#123; alert(&quot;您触发了选中事件！&quot;); &#125;&lt;/script&gt; &lt;/head&gt;&lt;body&gt; &lt;form&gt; 个人简介：&lt;br&gt; &lt;textarea name=&quot;summary&quot; cols=&quot;60&quot; rows=&quot;5&quot; onselect=&quot;message()&quot;&gt;请写入个人简介，不少于200字！&lt;/textarea&gt; &lt;/form&gt;&lt;/body&gt; 绑定和删除事件addEventListener()方法用于向指定元素添加事件句柄 removeEventListener()方法用于移除由addEventLister()方法添加的事件句柄 其他事件1）页面事件 onload 页面载入完毕时触发 onunload 用户退出页面时触发 2）窗口事件 onresize 窗口被调整大小时触发 onscroll 元素滚动条在滚动时触发","categories":[{"name":"DOM","slug":"DOM","permalink":"http://example.com/categories/DOM/"}],"tags":[{"name":"DOM","slug":"DOM","permalink":"http://example.com/tags/DOM/"}]},{"title":"DOM","slug":"DOM","date":"2017-07-15T13:19:55.000Z","updated":"2022-05-28T02:29:45.829Z","comments":true,"path":"2017/07/15/DOM/","link":"","permalink":"http://example.com/2017/07/15/DOM/","excerpt":"","text":"DOM简介Document Object Model 文档对象模型 DOM包含了所有HTML元素的属性和方法，以及访问操作他们的方式； 认识dom树和dom节点什么是Dom操作？ DOM是一个使程序和脚本有能力动态地访问和更新文档的内容、结构以及样式的平台和语言中立的接口 在HTML和JavaScript的学习中，DOM操作可谓时重中之重 Dom树 DOM节点的分类：DOM节点分为三大类：元素（标签）节点、属性节点、文本节点； 节点之间的关系：由DOM树我们可以看到，文本节点、属性节点属于元素节点的子节点 在操作元素节点和文本节点前，一定要先获取到元素节点。 访问节点通过ID名查找dom元素语法：document.getElementById(“id名”) 功能：找页面中对应id名的元素； 返回值：dom元素 返回值类型：object; 说明：getELementById()前面必须的document对象（即文档对象）如果页面中没有这个id元素，返回null; 通过标签名找元素语法1：document.getElementsByTagName(“标签名”) 功能：获取页面中所有指定标签； 返回值：返回一个类数组（即一个集合）；换句话说，就是将页面中所有的指定标签放在一个方括号的集合里面。 获取具体的某个元素； 通过name属性找元素document.getElementByName: 方法可返回带有指定名称的对象的集合 通过指定的类名获取元素语法：document.getElementsByClassName() 功能：返回文档中所有指定类名的元素集合，作为 NodeList 对象。 HTML 5 为 document 对象和 HTML 元素新增了 getElementsByClassName() 方法，使用该方法可以选择指定类名的元素。 getElementsByClassName() 方法可以接收一个字符串参数，包含一个或多个类名，类名通过空格分隔，不分先后顺序，方法返回带有指定类的所有元素 NodeList。 浏览器支持状态：IE 9+、Firefox 3.0+、Safari 3+、Chrome 和 Opera 9.5+。 如果不考虑兼容早期 IE 浏览器或者怪异模式，用户可以放心使用。 示例1 下面示例使用 getElementsByClassName(“red”) 方法选择文档中所有包含 red 类的元素。 123456789&lt;div class=&quot;red&quot;&gt;红盒子&lt;/div&gt;&lt;div class=&quot;blue red&quot;&gt;蓝盒子&lt;/div&gt;&lt;div class=&quot;green red&quot;&gt;绿盒子&lt;/div&gt;&lt;script&gt; var divs = document.getElementsByClassName(&quot;red&quot;); for (var i = 0; i &lt; divs.length; i ++) &#123; console.log(divs[i].innerHTML); &#125;&lt;/script&gt; 示例2 下面示例使用 document.getElementById(“box”) 方法先获取 ，然后在它下面使用 getElementsByClassName(“blue red”) 选择同时包含 red 和 blue 类的元素。 12345678910&lt;div id=&quot;box&quot;&gt; &lt;div class=&quot;blue red green&quot;&gt;blue red green&lt;/div&gt;&lt;/div&gt;&lt;div class=&quot;blue red black&quot;&gt;blue red black&lt;/div&gt;&lt;script&gt; var divs = document.getElementById(&quot;box&quot;).getElementsByClassName(&quot;blue red&quot;); for (var i = 0; i &lt; divs.length; i ++) &#123; console.log(divs[i].innerHTML); &#125;&lt;/script&gt; 在 document 对象上调用 getElementsByClassName() 会返回与类名匹配的所有元素，在元素上调用该方法就只会返回后代元素中匹配的元素。 通过样式查找单个元素语法：元素.querySelector(“css选择器”); 功能：返回文档中匹配指定 CSS 选择器的一个元素 返回值：DOM对象 传递一个标签选择器 传递一个类选择器 传递一个交集选择器 获取文档中有 “target” 属性的第一个 元素 并集选择器 通过样式获取所有元素语法：元素.querySelectorAll(“css选择器”);语法：元素.querySelectorAll(“css选择器”); 功能：该方法和document.querySelector()用法类似，不同的是它会将符合条件的元素封装到一个数组中返回。即使符合条件的元素只有一个，它也会返回数组. 返回值：类数组 Document类型JavaScript 通过 Document 类型表示文档。在浏览器中，document 对象是 HTMLDocument（继承自 Document 类型）的一个实例，表示整个 HTML 页面。而且，document 对象是 window 对象的一个属性，因此可以将其作为全局对象来访问。Document 节点具有下列特征： nodeType 的值为9； nodeName 的值为 &quot;#document&quot;； nodeValue 的值为 null； parentNode 的值为 null； ownerDocument 的值为 null； 其子节点可能是一个 DocumentType（最多一个）、Element（最多一个）、ProcessingInstruction 或 Comment。 Document 类型可以表示 HTML 页面或者其他基于 XML 的文档。不过，最常见的应用还是作为 HTMLDocument 实例的 document 对象。通过这个文档对象，不仅可以取得与页面有关的信息，而且还能操作页面的外观及其底层结构。 文档的子节点虽然 DOM 标准规定 Document 节点的子节点可以是DocumentType、Element、ProcessingInstruction 或 Comment，但还有两个内置的访问其子节点的快捷方式。第一个就是documentElement 属性，该属性始终指向 HTML 页面中的 html 元素。另一个就是通过 childNodes 列表访问文档元素，但通过 documentElement 属性则能更快捷、更直接地访问该元素。以下面这个简单的页面为例。 1234&lt;html&gt; &lt;body&gt; &lt;/body&gt;&lt;/html&gt; 这个页面在经过浏览器解析后，其文档中只包含一个子节点，即 html 元素。可以通过 documentElement 或 childNodes 列表来访问这个元素，如下所示。 123var html = document.documentElement; // 取得对&lt;html&gt;的引用console.log(html === document.childNodes[0]); // trueconsole.log(html === document.firstChild); // true 这个例子说明，documentElement、firstChild 和 childNodes[0] 的值相同，都指向 &lt;html&gt; 元素。 作为 HTMLDocument 的实例，document 对象还有一个 body 属性，直接指向 &lt;body&gt; 元素。因为开发人员经常要使用这个元素，所以 document.body 在 JavaScript 代码中出现的频率非常高，其用法如下。 1var body = document.body; // 取得对&lt;body&gt;的引用 所有浏览器都支持 document.documentElement 和 document.body 属性。 Document 另一个可能的子节点是 DocumentType。通常将 &lt;!DOCTYPE&gt; 标签看成一个与文档其他部分不同的实体，可以通过 doctype 属性（在浏览器中是 document.doctype ）来访问它的信息。 1var doctype = document.doctype; // 取得对&lt;!DOCTYPE&gt;的引用 浏览器对 document.doctype 的支持差别很大，可以给出如下总结。 IE8 及之前版本：如果存在文档类型声明，会将其错误地解释为一个注释并把它当作 Comment 节点；而 document.doctype 的值始终为 null。 IE9+ 及 Firefox：如果存在文档类型声明，则将其作为文档的第一个子节点；document.doctype 是一个 DocumentType 节点，也可以通过 document.firstChild 或 document.childNodes[0] 访问同一个节点。 Safari、Chrome 和 Opera：如果存在文档类型声明，则将其解析，但不作为文档的子节点。document.doctype 是一个 DocumentType 节点，但该节点不会出现在 document.childNodes 中。 由于浏览器对 document.doctype 的支持不一致，因此这个属性的用处很有限。 文档信息作为 HTMLDocument 的一个实例，document 对象还有一些标准的 Document 对象所没有的属性。这些属性提供了 document 对象所表现的网页的一些信息。其中第一个属性就是 title，包含着 &lt;title&gt; 元素中的文本——显示在浏览器窗口的标题栏或标签页上。通过这个属性可以取得当前页面的标题，也可以修改当前页面的标题并反映在浏览器的标题栏中。 12345// 取得文档标题var originalTitle = document.title;// 设置文档标题document.title = &quot;New page title&quot;; 接下来要介绍的3个属性都与对网页的请求有关，它们是 URL、domain 和 referrer。URL 属性中包含页面完整的 URL（即地址栏中显示的URL），domain 属性中只包含页面的域名，而 referrer 属性中则保存着链接到当前页面的那个页面的 URL。在没有来源页面的情况下，referrer 属性中可能会包含空字符串。所有这些信息都存在于请求的 HTTP 头部，只不过是通过这些属性让我们能够在 JavaScrip 中访问它们而已，如下面的例子所示。 12345678// 取得完整的URLvar url = document.URL;// 取得域名var domain = document.domain;// 取得来源页面的URLvar referrer = document.referrer; 更改节点内容 获取元素的内容 语法：元素.innerHTML; 说明：获取到的内容都是string 类型； 修改设置元素的内容 语法：元素.innerHTML &#x3D; ‘内容’ 元素的行内样式获取元素的行内样式 style 语法：元素.style.css属性； 注意：复合属性需要转驼峰； 设置元素的行内样式语法：元素.style.css属性 &#x3D; 属性值； 获取元素的html属性语法：元素.html属性 Eg: 元素.id 元素.src 元素.alt 元素.value 等； 设置修改元素的html属性语法：元素.属性 &#x3D; 属性值； 初始 修改后 Node 属性概述Node 常用属性主要有以下10个，接下来我们会着重讲解部分属性。 nodeType：显示节点的类型 nodeName：显示节点的名称 nodeValue：显示节点的值 attributes：获取一个属性节点 firstChild：表示某一节点的第一个节点 lastChild：表示某一节点的最后一个子节点 childNodes：表示所在节点的所有子节点 parentNode：表示所在节点的父节点 nextSibling：紧挨着当前节点的下一个节点 previousSibling：紧挨着当前节点的上一个节点 nodeName 和 nodeValue 属性要了解节点的具体信息，可以使用 nodeName 和 nodeValue 这两个属性。这两个属性的值完全取决于节点的类型。在使用这两个值以前，最好是像下面这样先检测一下节点的类型。 123if (someNode.nodeType == 1)&#123; value = someNode.nodeName; // nodeName的值是元素的标签名&#125; 在这个例子中，首先检查节点类型，看它是不是一个元素。如果是，则取得并保存 nodeName 的值。对于元素节点，nodeName 中保存的始终都是元素的标签名，而 nodeValue 的值则始终为 null。 属性节点的主要特征值：nodeType 等于 2、nodeName 等于属性的名称、nodeValue 等于属性的值、parentNode 等于 null，在 HTML 中不包含子节点。属性节点继承于 Node 类型，包含以下 3 个专用属性。 name：表示属性名称，等效于 nodeName。 value：表示属性值，可读可写，等效于 nodeValue。 specified：如果属性值是在代码中设置的，则返回 true；如果为默认值，则返回 false。 创建属性节点使用 document 对象的 createAttribute() 方法可以创建属性节点，具体用法如下： 1document.createAttribute(name) 参数 name 表示新创建的属性的名称。 示例1 下面示例创建一个属性节点，名称为 align，值为 center，然后为标签 设置属性 align，最后分别使用 3 种方法读取属性 align 的值。 12345678910&lt;div id=&quot;box&quot;&gt;document.createAttribute(name)&lt;/div&gt;&lt;script&gt; var element = document.getElementById(&quot;box&quot;); var attr = document.createAttribute(&quot;align&quot;); attr.value = &quot;center&quot;; element.setAttributeNode(attr); console.log(element.attributes[&quot;align&quot;].value); //&quot;center&quot; console.log(element.getAttributeNode(&quot;align&quot;).value); //&quot;center&quot; console.log(element.getAttribute(&quot;align&quot;)); //&quot;center&quot;&lt;/script&gt; 属性节点一般位于元素的头部标签中。元素的属性列表会随着元素信息预先加载，并被存储在关联数组中。例如，针对下面 HTML 结构。 1&lt;div id=&quot;div1&quot; class=&quot;style1&quot; lang=&quot;en&quot; title=&quot;div&quot;&gt;&lt;/div&gt; 当 DOM 加载后，表示 HTML div 元素的变量 divElement 就会自动生成一个关联集合，它以名值对形式检索这些属性。 123456divElement.attributes = &#123; id : &quot;div1&quot;, class : &quot;style1&quot;, lang : &quot;en&quot;, title : &quot;div&quot;&#125; 在传统 DOM 中，常用点语法通过元素直接访问 HTML 属性，如 img.src、a.href 等，这种方式虽然不标准，但是获得了所有浏览器的支持。 示例2 img 元素拥有 src 属性，所有图像对象都拥有一个 src 脚本属性，它与 HTML 的 src 特性关联在一起。下面两种用法都可以很好地工作在不同浏览器中。 123456&lt;img id=&quot;img1&quot; src=&quot;&quot; /&gt;&lt;script&gt; var img = document.getElementById(&quot;img1&quot;); img.setAttribute(&quot;src&quot;, &quot;http://www.w3.org&quot;); //HTML 属性 img.src = &quot;http://www.w3.org&quot;; //JavaScript 属性&lt;/script&gt; 类似的还有 onclick、style 和 href 等。为了保证 JavaScript 脚本在不同浏览器中都能很好地工作，建议采用标准用法，而且很多 HTML 属性并没有被 JavaScript 映射，所以也就无法直接通过脚本属性进行读写。 读取属性值使用元素的 getAttribute() 方法可以读取指定属性的值。用法如下： 1getAttribute(name) 参数 name 表示属性名称。 使用元素的 attributes 属性、getAttributeNode() 方法可以返回对应属性节点。 示例1 下面示例访问红色盒子和蓝色盒子，然后读取这些元素所包含的 id 属性值。 12345678&lt;div id=&quot;red&quot;&gt;红盒子&lt;/div&gt;&lt;div id=&quot;blue&quot;&gt;蓝盒子&lt;/div&gt;&lt;script&gt; var red = document.getElementById(&quot;red&quot;); //获取红色盒子 console.log(red.getAttribute(&quot;id&quot;)); //显示红色盒子的id属性值 var blue = document.getElementById(&quot;blue&quot;); //获取蓝色盒子 console.log(blue.getAttribute(&quot;id&quot;)); //显示蓝色盒子的id属性值&lt;/script&gt; 示例2 HTML DOM 也支持使用点语法读取属性值，使用比较简便，也获得了所有浏览器的支持。 1234var red = document.getElementById(&quot;red&quot;);console.log(red.id);var blue = document.getElementById(&quot;blue&quot;);console.log(blue.id); 对于 class 属性，则必须使用 className 属性名，因为 class 是 JavaScript 的保留字；对于 for 属性，则必须使用 htmlFor 属性名，这与 CSS 脚本中 float 和 text 属性被改名为 cssFloat 和 cssText 是一个道理。 示例3 使用 className 读写样式类。 12345678&lt;label id=&quot;label1&quot; class=&quot;class1&quot; for=&quot;textfield&quot;&gt;文本框： &lt;input type=&quot;text&quot; name=&quot;textfield&quot; id=&quot;textfield&quot; /&gt;&lt;/label&gt;&lt;script&gt; var label = document.getElementById(&quot;label1&quot;); console.log(label.className); console.log(label.htmlFor);&lt;/script&gt; 示例4 对于复合类样式，需要使用 split() 方法劈开返回的字符串，然后遍历读取类样式。 12345678&lt;div id=&quot;red&quot; class=&quot;red blue&quot;&gt;红盒子&lt;/div&gt;&lt;script&gt; //所有类名生成的数组 var classNameArray = document.getElementById(&quot;red&quot;).className.split(&quot; &quot;); for (var i in classNameArray) &#123; //遍历数组 console.log(classNameArray[i]); //当前class名 &#125;&lt;/script&gt; 设置属性值使用元素的 setAttribute() 方法可以设置元素的属性值。用法如下： 1setAttribute(name) 参数 name 和 value 分别表示属性名称和属性值。属性名和属性值必须以字符串的形式进行传递。如果元素中存在指定的属性，它的值将被刷新；如果不存在，则 setAttribute() 方法将为元素创建该属性并赋值。 示例1 下面示例分别为页面中 div 元素设置 title 属性。 12345678&lt;div id=&quot;red&quot;&gt;红盒子&lt;/div&gt;&lt;div id=&quot;blue&quot;&gt;蓝盒子&lt;/div&gt;&lt;script&gt; var red = document.getElementById(&quot;red&quot;); //获取红盒子的引用 var blue= document.getElementById(&quot;blue&quot;); //获取蓝盒子的引用 red.setAttribute(&quot;title&quot;, &quot;这是红盒子&quot;); //为红盒子对象设置title属性和值 blue.setAttribute(&quot;title&quot;, &quot;这是蓝盒子&quot;); //为蓝盒子对象设置title属性和值&lt;/script&gt; 示例2 下面示例定义了一个文本节点和元素节点，并为一级标题元素设置 title 属性，最后把它们添加到文档结构中。 12345var hello = document.createTextNode(&quot;Hello World!&quot;); //创建一个文本节点var h1 = document.createElement(&quot;h1&quot;); //创建一个一级标题h1.setAttribute(&quot;title&quot;, &quot;你好，欢迎光临！&quot;); //为以及标题定义title 属性h1.appendChild(hello); //把文本节点增加到一级标题中document.body.appendChild(h1); //把一级标题增加到文档 示例3 也可以使用快捷方法设置 HTML DOM 文档中元素的属性值。 12345678&lt;label id=&quot;label1&quot;&gt;文本框： &lt;input type=&quot;text&quot; name=&quot;textfield&quot; id=&quot;textfield&quot; /&gt;&lt;/label&gt;&lt;script&gt; var label1 = document.getElementById(&quot;label1&quot;); label.className = &quot;class1&quot;; label.htmlFor = &quot;textfield&quot;;&lt;/script&gt; DOM 支持使用 getAttribute() 和 setAttribute() 方法读写自定义属性，不过 IE 6.0 及其以下版本浏览器对其的支持不是很完善。 示例4 直接使用 className 添加类样式，会覆盖掉元素原来的类样式。这时可以采用叠加的方式添加类。 123456&lt;div id=&quot;red&quot;&gt;红盒子&lt;/div&gt;&lt;script&gt; var red = document.getElementById(&quot;red&quot;); red.className = &quot;red&quot;; red.className += &quot;blue&quot;;&lt;/script&gt; 示例5 使用叠加的方式添加类也存在问题，这样容易添加大量重复的类。为此，定义一个检测函数，判断元素是否包含指定的类，然后再决定是否添加类。 12345678910111213141516&lt;script&gt; function hasClass (element, className) &#123; //检测类名函数 var reg = new RegExp(&#x27;(\\\\s|^)&#x27; + className + &#x27;(\\\\s|$)&#x27;); return reg.test(element.className); //使用正则检测是否有相同的样式 &#125; function addClass (element, className) &#123; //添加类名函数 if (! hasClass (element, className)) element.className += &#x27; &#x27; + className; &#125;&lt;/script&gt;&lt;div id=&quot;red&quot;&gt;红盒子&lt;/div&gt;&lt;script&gt; var red = document.getElementById(&quot;red&quot;); addClass(red, &#x27;red&#x27;); addClass(red, &#x27;blue&#x27;);&lt;/script&gt; 删除属性使用元素的 removeAttribute() 方法可以删除指定的属性。用法如下： 1removeAttribute(name) 参数 name 表示元素的属性名。 示例1 下面示例演示了如何动态设置表格的边框 123456789101112131415161718&lt;script&gt; window.onload = function () &#123; //绑定页面加载完毕时的事件处理函数 var table = document.getElementByTagName(&quot;table&quot;)[0]; //获取表格外框的引用 var del = document.getElementById(&quot;del&quot;); var reset = document.getElementById(&quot;reset&quot;); del.onclick = function () &#123; table.removeAttribute(&quot;border&quot;); &#125; reset.onclick = function () &#123; table.setAttribute(&quot;border&quot;, &quot;2&quot;); &#125;&lt;/script&gt;&lt;table width=&quot;100%&quot; border=&quot;2&quot;&gt; &lt;tr&gt; &lt;td&gt;数据表格&lt;/td&gt; &lt;tr&gt;&lt;/table&gt;&lt;button id=&quot;del&quot;&gt;删除&lt;/button&gt;&lt;button id=&quot;reset&quot;&gt;恢复&lt;/button&gt; 在上面示例中设计了两个按钮，并分别绑定了不同的事件处理函数。单击“删除”按钮即可调用表格的 removeAttribute() 方法清除表格边框，单击“恢复”按钮即可调用表格的 setAttribute() 方法重新设置表哥便可的粗细。 示例2 下面示例演示了如何自定义删除类函数，并调用该函数删除指定类名。 12345678910111213141516&lt;script&gt; function hasClass (element, className) &#123; //类名检测函数 var reg = new RegExp (&#x27;(\\\\s|^)&#x27; + className + &#x27;(\\\\s|$)&#x27;); return reg.test (element, className); //使用正则检测是否有相同的样式 &#125; function deleteClass (element, className) &#123; if (hasClass (element, className)) &#123; element.className.replace (reg, &#x27; &#x27;); //捕获要删除样式，然后替换为空白字符串 &#125; &#125;&lt;/script&gt;&lt;div id=&quot;red&quot; class=&quot;red blue bold&quot;&gt;盒子&lt;/div&gt;&lt;script&gt; var red = document.getElementById (&quot;red&quot;); deleteClass (red, &#x27;blue&#x27;);&lt;/script&gt; 上面代码使用正则表达式检测 className 属性值字符串中是否包含指定的类名，如果存在，则使用空字符串替换掉匹配到的子字符串，从而实现删除类名的目的。 创建节点createElement() 方法创建新的元素节点。 document.createElement()是在对象中创建一个对象，要与appendChild()或insertBefore()方法联合使用。其中，appendChild()方法在节点的子节点列表末添加新的子节点。insertBefore()方法在节点的子节点列表任意位置插入新的节点。 添加节点appendChild() 方法向已存在的节点添加子节点。 示例： 12345678&lt;div id=&quot;board&quot;&gt;&lt;/div&gt;&lt;script&gt;var board = document.getElementById(&quot;board&quot;);var e = document.createElement(&quot;input&quot;);e.type = &quot;button&quot;;e.value = &quot;这是测试加载的小例子&quot;;var object = board.appendChild(e);&lt;/script&gt; 示例2： 12345678&lt;script type=&quot;text/javascript&quot;&gt; var board = document.getElementById(&quot;board&quot;); var e2 = document.createElement(&quot;select&quot;); e2.options[0] = new Option(&quot;加载项1&quot;, &quot;&quot;); e2.options[1] = new Option(&quot;加载项2&quot;, &quot;&quot;); e2.size = &quot;2&quot;; var object = board.appendChild(e2);&lt;/script&gt; 示例3： 123456789&lt;script type=&quot;text/javascript&quot;&gt; var board = document.getElementById(&quot;board&quot;); var e3 = document.createElement(&quot;input&quot;); e4.setAttribute(&quot;type&quot;, &quot;text&quot;); e4.setAttribute(&quot;name&quot;, &quot;q&quot;); e4.setAttribute(&quot;value&quot;, &quot;使用setAttribute&quot;); e4.setAttribute(&quot;onclick&quot;, &quot;javascript:alert(&#x27;This is a test!&#x27;);&quot;); var object = board.appendChild(e3);&lt;/script&gt; 替换节点replaceChild() 方法可以将某个子节点替换为另一个。 语法： 1nodeObject.replaceChild(new_node, old_node) 其中参数 new_node 为指定新的节点，old_node 为被替换的节点。如果替换成功，则返回被替换的节点；如果替换失败，则返回 null。 示例1： 以上示例为基础重写脚本，新建一个二级标题元素并替换掉红色盒子中的一级标题元素。 1234567var ok = document.getElementById(&quot;ok&quot;); //获取按钮元素的引用ok.onclick = function () &#123; //为按钮注册一个鼠标单击事件处理函数 var red = document.getElementById(&quot;red&quot;); //获取红色盒子的引用 var h1 = document.getElementsByTagName(&quot;h1&quot;)[0]; //获取一级标题的引用 var h2 = documeng.createElement(&quot;h2&quot;); //创建二级标题元素并引用 red.replaceChild(h2, h1); //把一级标题替换为二级标题&#125; 示例2： 在下面示例中使用蓝盒子替换掉红盒子中包含的一级标题元素。此时可以看到，蓝盒子原来显示的位置已经被删除显示，同时被替换元素 h1 也被删除。 1234567var ok = document.getElementById(&quot;ok&quot;); //获取按钮元素的引用ok.onclick = function () &#123; //为按钮注册一个鼠标单击事件处理函数 var red = document.getElementById(&quot;red&quot;); //获取红色盒子的引用 var blue= document.getElementById(&quot;blue&quot;); //获取蓝色盒子的引用 var h1 = document.getElementsByTagName(&quot;h1&quot;)[0]; //获取一级标题的引用 red.replaceChild(blue, h1); //把红盒子中包含的一级标题替换为蓝盒子&#125; 示例3： replaceChild() 方法能够返回被替换掉的节点引用，因此还可以把被替换掉的元素给找回来，并增加到文档中的指定节点中。 针对上面示例，使用一个变量 del_h1 存储被替换掉的一级标题，然后再把它插入到红色盒子前面。 12345678var ok = document.getElementById(&quot;ok&quot;); //获取按钮元素的引用ok.onclick = function () &#123; //为按钮注册一个鼠标单击事件处理函数 var red = document.getElementById(&quot;red&quot;); //获取红色盒子的引用 var blue= document.getElementById(&quot;blue&quot;); //获取蓝色盒子的引用 var h1 = document.getElementsByTagName(&quot;h1&quot;)[0]; //获取一级标题的引用 var del_h1 = red,replaceChild(blue, h1); //把红盒子中包含的一级标题替换为蓝盒子 red.parentNode.insertBefore(del_h1, red); //把替换掉的一级标题插入到红盒子前面&#125; 自定义属性HTML 5 允许用户为元素自定义属性，但要求添加 data- 前缀，目的是为元素提供与渲染无关的附加信息，或者提供语义信息。例如： 1&lt;div id=&quot;box&quot; data-myid=&quot;12345&quot; data-myname=&quot;zhangsan&quot; data-mypass=&quot;zhang123&quot;&gt;自定义数据属性&lt;/div&gt; 添加自定义属性之后，可以通过元素的 dataset 属性访问自定义属性。dataset 属性的值是一个 DOMStringMap 实例，也就是一个名值对的映射。在这个映射中，每个 data-name 形式的属性都会有一个对应的属性，只不过属性名没有 data- 前缀。 浏览器支持状态：Firefox 6+ 和 Chrome。 示例 下面代码演示了如何自定义属性，以及如何读取这些附加信息。 12345678910111213var div = document.getElementById(&quot;box&quot;);//访问自定义属性值var id = div.dataset.myid;var name = div.dataset.myname;var pass = div.dataset.mypass;//重置自定义属性值div.dataset.myid = &quot;66666&quot;;div.dataset.myname = &quot;zhangsan&quot;;div.dataset.mypass = &quot;zhangsan666&quot;;//检测自定义属性if (div.dataset.myname) &#123; console.log(div.dataset.myname);&#125; 虽然上述用法未获得所有浏览器支持，但是我们仍然可以使用这种方式为元素添加自定义属性，然后使用 getAttribute() 方法读取元素附加的信息。 节点关系识别空白文本元素.firstChild 第一个子节点 元素.lastChild 最后一个子节点 元素.childNodes 获取所有的子节点 元素.attributes 获取某个元素的所有属性节点 元素.nextSibling 获取下一个兄弟节点 元素.previousSibling 获取上一个兄弟节点 不识别空白文本元素.children 获取所有的元素子节点 元素.firstElementChild 获取第一个元素子节点 元素.lastElementChild 获取最后一个元素子节点 元素.nextElementSibling 获取下一个元素兄弟节点 元素.previousElementSibling 获取上一个元素兄弟节点 元素.parentNode 父节点","categories":[{"name":"DOM","slug":"DOM","permalink":"http://example.com/categories/DOM/"}],"tags":[{"name":"DOM","slug":"DOM","permalink":"http://example.com/tags/DOM/"}]},{"title":"面向对象编程","slug":"面向对象编程","date":"2017-06-20T03:48:17.000Z","updated":"2022-05-28T04:00:27.116Z","comments":true,"path":"2017/06/20/面向对象编程/","link":"","permalink":"http://example.com/2017/06/20/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/","excerpt":"","text":"一、面向对象与面向过程 面向过程：根据业务逻辑从上到下写代码。 面向对象：将变量与函数绑定到一起，分类进行封装，每个程序只要负责分配给自己的分类，这样能够更快速的开发程序，减少了重复代码。 面向过程编程最易被初学者接受，其往往用一长段代码来实现指定功能，开发过程的思路是将数据与函数按照执行的逻辑顺序组织在一起，数据与函数分开考虑，面向过程基本是由函数组成的。 面向过程编程面向过程编程的关注点在于怎么做 把完成某一个需求的 所有步骤 从头到尾 逐步实现 根据开发需求，将某些 功能独立 的代码 封装 成一个又一个 函数 最后完成的代码，就是顺序地调用 不同的函数 特点: 注重步骤与过程，不注重职责分工 如果需求复杂，代码会变得很复杂 开发复杂项目，没有固定的套路，开发难度很大！ 面向对象基本概念面向对象编程（Object Oriented Programming，OOP，面向对象程序设计）和面相过程编程，是两种不同的编程方式。 面向对象编程的关注点在于谁来做 相比较函数，面向对象是更大的封装，根据职责在 一个对象中封装多个方法 在完成某一个需求前，首先确定职责 —— 要做的事情（方法） 根据 职责 确定不同的 对象，在对象内部封装不同的方法（多个） 最后完成的代码，就是顺序地调用不同对象的相应方法。 特点: 注重 对象和职责，不同的对象承担不同的职责。 更加适合应对复杂的需求变化，是专门应对复杂项目开发，提供的固定套路。 需要在面向过程基础上，再学习一些面向对象的语法。 类和对象类和对象是面向对象编程的两个核心概念。 类类是对一群具有相同特征或者行为 的事物的一个统称，是抽象的，不能直接使用 特征其实就是一个变量，在类里我们称之为属性。 行为其实就是一个函数，在类里我们称之为方法。 类其实就是由 属性 和 方法 组成的一个抽象概念。 类就相当于制造飞机时的图纸，是一个模板。这个模板只规定了飞机的某些特征(例如大小，颜色，型号等等)和行为(例如起飞，降落，飞行等等)，它并不是一个具体的飞机，而是对飞机的一个抽象概念。它出现的目的，是为了让我们的创建飞机对象。 对象对象是由类创建出来的一个具体存在，可以直接使用。由哪一个类创建出来的 对象，就拥有在哪一个类中定义的属性和方法。 对象 就相当于用图纸制造的飞机。在开发中，应该先有类，在类里定义好属性和行为，再根据类来创建对象。 类和对象的关系 类是模板，对象是根据类这个模板创建出来的，应该先有类，再有对象。 使用同一个类，能够创建出很多对象。 类中定义了什么属性和方法，对象中就有什么属性和方法。 不同对象对应的属性值也会不同。 例如：定义了一个狗类，这个狗类有以下属性： 品种 颜色 性别 名字 现在根据这个类创建出了两条狗，这两条狗分别是 哈士奇、灰色、母、二哈 和 中华田园犬、黄色、公、旺财。我们发现，这两条狗都具有 品种、颜色、性别和名字这些属性，但是每条狗对应的属性值却不一样。 类的设计在程序开发中，要设计一个类，通常需要满足一下三个要素： 类名 这类事物的名字，安照大驼峰命名法(每个单词的首字母大写)起名。 属性 这类事物具有什么样的特征。 方法 这类事物具有什么样的行为。 定义类名名词提炼法:分析整个业务流程，出现的名词，通常就是找到的类。 属性和方法的确定 对对象的特征描述，可以定义成属性 对象具有的行为（动词）可以定义成方法 面向对象基本语法在Python中，对象几乎是无处不在的，我们可以使用dir内置函数来查看这个对象里的方法。 定义简单的类（只包含方法） 面向对象是更大的封装，在一个类中封装多个方法，这样通过这个类创建出来的对象，就可以直接调用这些方法了！ 定义类在Python中要定义一个只包含方法的类，语法格式如下： 12345class 类名: def 方法1(self,参数列表): pass def 方法2(self,参数列表): pass 方法的定义格式和函数一样。 方法里的第一个参数必须是self。. 类名要遵守大驼峰命名法。 创建实例对象当一个类定义完成之后，要使用这个类来创建对象，语法格式如下： 1对象变量名 = 类名() 案例需求 小猫 爱 吃 鱼，小猫 要 喝 水 分析 定义一个猫类 Cat 定义两个方法 eat 和 drink 按照需求 —— 不需要定义属性 12345678910111213141516class Cat: &quot;&quot;&quot;这是个猫类&quot;&quot;&quot; def eat(self): print(&quot;小猫在吃东西&quot;) def drink(self): print(&quot;小猫在喝水&quot;)tom = Cat() # 创建了一个Cat对象tom.eat()tom.drink()hello_kitty = Cat() # 又创建了一个新的Cat对象hello_kitty.eat()hello_kitty.drink( self的使用给对象添加属性python支持动态属性，当一个对象创建好了以后，直接使用 对象.属性名 = 属性值 就可以很方便的给对象添加一个属性。 12tom = Cat()tom.name = &#x27;Tom&#x27; # 可以直接给 tom 对象添加一个 name 属性 这种方法很方便，但是，不建议使用这种方式给对象添加属性。 self的概念哪个对象调用了方法，方法里的self指的就是谁。 通过 self.属性名 可以访问到这个对象的属性；通过 self.方法名() 可以调用这个对象的方法。 1234567891011class Cat: def eat(self): print(&quot;%s爱吃鱼&quot; %self.name)tom = Cat()tom.name = &#x27;Tom&#x27; # 给 tom 对象添加了一个name属性tom.eat() # Tom爱吃鱼lazy_cat = Cat()lazy_cat.name = &quot;大懒猫&quot;lazy_cat.eat() # 大懒猫爱吃鱼 直接给对象添加属性的缺点上述代码中，我们是先创建对象，然后再给对象添加 name 属性，但是这样做会有问题。 123tom = Cat()tom.eat()tom.name = &quot;Tom&quot; 程序运行时会报错： 12AttributeError: &#x27;Cat&#x27; object has no attribute &#x27;name&#x27;错误提示：&#x27;Cat&#x27;对象没有 &#x27;name&#x27; 属性 在日常开发中，不推荐在类的外部直接给对象添加属性这种方式。对象应该具有哪些属性，我们应该封装在类的内部。","categories":[{"name":"python","slug":"python","permalink":"http://example.com/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"http://example.com/tags/python/"}]},{"title":"javascript函数","slug":"javascript函数","date":"2017-05-26T03:24:17.000Z","updated":"2022-05-26T11:38:23.302Z","comments":true,"path":"2017/05/26/javascript函数/","link":"","permalink":"http://example.com/2017/05/26/javascript%E5%87%BD%E6%95%B0/","excerpt":"","text":"函数函数是一个代码块，定义之后，可以被执行或调用任意多次。Js函数是参数化的，即函数定义可以包含一组标识符，称为参数或形参。 定义函数在Js中定义函数最直观的方式就是使用function关键字，这个关键字可以用作声明或表达式。 命名函数的标识符 一对圆括号，中间包含逗号分隔的零或多个标识符。 一对花括号，其中包含零或多个Js语句。 123function 函数名(参数,参数2,......)&#123; 表达式&#125; 例如，这段代码定义了square，来引用一个函数，它产生给定数字的平方： 123456const square = function(x) &#123; return x * x;&#125;;console.log(square(12));// → 144 变量和作用域每个变量都有一个作用域，它是程序的一部分，其中变量是可见的。 对于在任何函数或块之外定义的变量，作用域是整个程序 - 您可以在任何地方引用这种变量。它们被称为全局的。 但是为函数参数创建的，或在函数内部声明的变量，只能在该函数中引用，所以它们被称为局部变量。 每次调用该函数时，都会创建这些变量的新实例。 这提供了函数之间的一些隔离 - 每个函数调用，都在它自己的小世界（它的局部环境）中运行，并且通常可以在不知道全局环境中发生的事情的情况下理解。 用let和const声明的变量，实际上是它们的声明所在的块的局部对象，所以如果你在循环中创建了一个，那么循环之前和之后的代码就不能“看见”它。JavaScript 2015 之前，只有函数创建新的作用域，因此，使用var关键字创建的旧式变量，在它们出现的整个函数中内都可见，或者如果它们不在函数中，在全局作用域可见。 12345678910let x = 10;if (true) &#123; let y = 20; var z = 30; console.log(x + y + z); // → 60&#125;// y is not visible hereconsole.log(x + z);// → 40 每个作用域都可以“向外查看”它周围的作用域，所以示例中的块内可以看到x。 当多个变量具有相同名称时例外 - 在这种情况下，代码只能看到最内层的那个。 例如，当halve函数中的代码引用n时，它看到它自己的n，而不是全局的n。 12345678const halve = function(n) &#123; return n / 2;&#125;let n = 10;console.log(halve(100));// → 50console.log(n);// → 10 嵌套作用域JavaScript 不仅区分全局和局部变量。 块和函数可以在其他块和函数内部创建，产生多层局部环境。 例如，这个函数的内部有另一个函数： 123456789101112131415const hummus = function(factor) &#123; const ingredient = function(amount, unit, name) &#123; let ingredientAmount = amount * factor; if (ingredientAmount &gt; 1) &#123; unit += &quot;s&quot;; &#125; console.log(`$&#123;ingredientAmount&#125; $&#123;unit&#125; $&#123;name&#125;`); &#125;; ingredient(1, &quot;can&quot;, &quot;chickpeas&quot;); ingredient(0.25, &quot;cup&quot;, &quot;tahini&quot;); ingredient(0.25, &quot;cup&quot;, &quot;lemon juice&quot;); ingredient(1, &quot;clove&quot;, &quot;garlic&quot;); ingredient(2, &quot;tablespoon&quot;, &quot;olive oil&quot;); ingredient(0.5, &quot;teaspoon&quot;, &quot;cumin&quot;);&#125;; ingredient函数中的代码，可以从外部函数中看到factor变量。 但是它的局部变量，比如unit或ingredientAmount，在外层函数中是不可见的。 简而言之，每个局部作用域也可以看到所有包含它的局部作用域。 块内可见的变量集，由这个块在程序文本中的位置决定。 每个局部作用域也可以看到包含它的所有局部作用域，并且所有作用域都可以看到全局作用域。 这种变量可见性方法称为词法作用域。 作为值的函数函数变量通常只充当程序特定部分的名称。 这样的变量被定义一次，永远不会改变。 这使得容易混淆函数和名称。 123456let launchMissiles = function(value) &#123; missileSystem.launch(&quot;now&quot;);&#125;;if (safeMode) &#123; launchMissiles = function() &#123;/* do nothing */&#125;;&#125; 箭头函数箭头函数的一般形式是圆括号中逗号分隔的参数列表，后跟箭头&#x3D;&gt;，再跟包含在花括号中的函数体： 1const sum = (x,y) =&gt;&#123;return x+y&#125; 调用函数语法： 123456function add(参数,参数2....)&#123;&#125;调用方法：add(参数,参数2....) 对象中方法调用 12345678let calculator = &#123; operand1 : 1, operand2 : 2, add()&#123; this.result = this.operand1 + this.operand2 &#125;&#125;calculator.add(); this关键字不具有变量那样的作用域机制，除了箭头函数，嵌套函数不会继承包含函数的this值。如果嵌套函数被当做方法来调用，那它的this值就是调用它的对象。 可选参数与默认值当调用函数时传入的实参少于声明的形参时，额外的形参会获得默认值，通常是undefined. 1234567891011121314//把对象o的可枚举属性名放到数组a中，返回a//如果不传a,则创建一个新数组function getPropertyNames(o,a)&#123; if(a === undefined)&#123; a = []; &#125; for(let property in o)&#123; a.push(property) &#125; return a;&#125;let o = &#123;x:1&#125;,p=&#123;y:2,z:3&#125;let a = getPropertyNames(o);getPropertyNames(p,a); 现在可以直接在函数形参列表中为每个参数定义默认值。语法是形参名后面加上等于号和默认值，这样在没有给该形参传值时就会使用这个默认值。 123456function getPropertyNames(o ,a = [])&#123; for(let property in o)&#123; a.push(property) &#125; return a;&#125; 闭包闭包（closure）就是能够读取其他函数内部变量的函数。 由于在Javascript语言中，只有函数内部的子函数才能读取局部变量，因此可以把闭包简单理解成”定义在一个函数内部的函数”。 所以，在本质上，闭包就是将函数内部和函数外部连接起来的一座桥梁。 变量作用域要理解闭包，首先必须理解Javascript特殊的变量作用域。 变量的作用域无非就是两种：全局变量和局部变量。 Javascript语言的特殊之处，就在于函数内部可以直接读取全局变量。 12345var n=999;function f1()&#123; alert(n);&#125;f1(); // 999 另一方面，在函数外部自然无法读取函数内的局部变量。 12345function f1()&#123; var n=999;&#125;alert(n); // error 这里有一个地方需要注意，函数内部声明变量的时候，一定要使用var命令。如果不用的话，你实际上声明了一个全局变量！ 1234567function f1()&#123; n=999;&#125;f1();alert(n); // 999 如何从外部获取内部变量出于种种原因，我们有时候需要得到函数内的局部变量。但是，前面已经说过了，正常情况下，这是办不到的，只有通过变通方法才能实现。 那就是在函数的内部，再定义一个函数。 1234567function f1()&#123; var n=999; function f2()&#123; alert(n); // 999 &#125;&#125; 在上面的代码中，函数f2就被包括在函数f1内部，这时f1内部的所有局部变量，对f2都是可见的。但是反过来就不行，f2内部的局部变量，对f1就是不可见的。这就是Javascript语言特有的”链式作用域”结构（chain scope），子对象会一级一级地向上寻找所有父对象的变量。所以，父对象的所有变量，对子对象都是可见的，反之则不成立。 既然f2可以读取f1中的局部变量，那么只要把f2作为返回值，我们不就可以在f1外部读取它的内部变量了吗！ 123456789101112131415function f1()&#123; var n=999; function f2()&#123; alert(n); &#125; return f2;&#125;var result=f1();result(); // 999 闭包的用途闭包可以用在许多地方。它的最大用处有两个，一个是前面提到的可以读取函数内部的变量，另一个就是让这些变量的值始终保持在内存中。 123456789101112131415161718192021function f1()&#123; var n=999; nAdd=function()&#123;n+=1&#125; function f2()&#123; alert(n); &#125; return f2;&#125;var result=f1();result(); // 999nAdd();result(); // 1000 在这段代码中，result实际上就是闭包f2函数。它一共运行了两次，第一次的值是999，第二次的值是1000。这证明了，函数f1中的局部变量n一直保存在内存中，并没有在f1调用后被自动清除。 为什么会这样呢？原因就在于f1是f2的父函数，而f2被赋给了一个全局变量，这导致f2始终在内存中，而f2的存在依赖于f1，因此f1也始终在内存中，不会在调用结束后，被垃圾回收机制（garbage collection）回收。 这段代码中另一个值得注意的地方，就是”nAdd&#x3D;function(){n+&#x3D;1}”这一行，首先在nAdd前面没有使用var关键字，因此nAdd是一个全局变量，而不是局部变量。其次，nAdd的值是一个匿名函数（anonymous function），而这个匿名函数本身也是一个闭包，所以nAdd相当于是一个setter，可以在函数外部对函数内部的局部变量进行操作。 立即执行函数立即执行函数通常有下面两种写法： 12345678//第一种写法(function()&#123; ...&#125;)();//第二种写法(function()&#123; ...&#125;()); 立即执行函数的作用 立即执行函数只有一个作用：创建一个独立的作用域。这个作用域里面的变量，外面访问不到（即避免了「变量污染」）。 123456var liList = ul.getElementsByTagName(&#x27;li&#x27;)for(var i=0; i&lt;6; i++)&#123; liList[i].onclick = function()&#123; alert(i) // 为什么 alert 出来的总是 6，而不是 0、1、2、3、4、5 &#125;&#125; 因为输出的 i 是全局作用域的，当循环结束后 i 的值是 6，所以输出的 i 就是6。 用立即执行函数可以解决这个问题。 12345678var liList = document.getElementsByTagName(&#x27;li&#x27;);for(var i=0; i&lt;6; i++)&#123; (function(j)&#123; liList[j].onclick = function()&#123; alert(j) // 0、1、2、3、4、5 &#125; &#125;)(i)&#125; 因为 JS 中调用函数传递参数都是值传递 ，所以当立即执行函数执行时，首先会把参数 i 的值复制一份，然后再创建函数作用域来执行函数，循环5次就会创建5个作用域，所以每个 li 元素访问的都是不同作用域的 i 的值 。","categories":[{"name":"javascript","slug":"javascript","permalink":"http://example.com/categories/javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://example.com/tags/javascript/"}]},{"title":"javascript对象","slug":"javascript对象","date":"2017-05-26T02:54:56.000Z","updated":"2022-05-26T11:38:46.781Z","comments":true,"path":"2017/05/26/javascript对象/","link":"","permalink":"http://example.com/2017/05/26/javascript%E5%AF%B9%E8%B1%A1/","excerpt":"","text":"对象对象是一种复合值，它汇聚多个值并允许它们按名字存储和获取这些值。对象是一个属性的无序集合，每个属性都有名字和值。 1）创建对象对象可以通过对象字面量、new关键字和object.create()函数来创建。 对象字面量创建对象最简单的方式是js代码中直接包含对象字面量。对象字面量的最简单形式是包含在一对花括号中的一组逗号分隔的“键:值”对。属性名是js标识符或字符串字面量。属性值是任何js的表达式，这个表达式的值会变成属性的值。 12let empty = &#123;&#125;let point = &#123;x:0,y:0&#125; 使用New创建对象new操作符用于创建和初始化一个新对象。new关键字后面必须跟一个函数调用。以这种方式使用的函数被称为构造函数，目的是初始化新创建的对象。 12let o = new Object(); //&#123;&#125;let a = new Array();//[] Object.create()ECMAScript 5 定义了一个名为 Object.create() 的方法，它创建一个新对象，其中第一个参数是这个对象的原型。Object.create() 提供第二个可选参数，用以对对象的属性进行进一步描述。Object.create() 是一个静态函数，而不是提供给某个对象调用的方法。使用它的方法很简单，只须传入所需的原型对象即可。例如： 123var person = Object.create(Object.prototype);person.name = &quot;stone&quot;;person.age = 28; 其中 var person = Object.create(Object.prototype); 也等价于 var person = &#123;&#125;; 。 2）原型所有通过对象字面量创建的对象都具有同一个原型对象，并可以通过 JavaScript 代码 Object.prototype 获得对原型对象的引用。通过关键字 new 和构造函数调用创建的对象的原型就是构造函数的 prototype 属性的值。因此，同使用 &#123;&#125; 创建对象一样，通过 new Object() 创建的对象也继承自 Object.prototype。同样，通过 new Array() 创建的对象的原型就是 Array.prototype，通过 new Date() 创建的对象的原型就是 Date.prototype。 没有原型的对象为数不多，Object.prototype 就是其中之一。它不继承任何属性。其他原型对象都是普通对象，普通对象都具有原型。所有的内置构造函数（以及大部分自定义的构造函数）都具有一个继承自 Object.prototype 的原型。例如，Date.prototype 的属性继承自 Object.prototype，因此由 new Date() 创建的 Date 对象的属性同时继承自 Date.prototype 和 Object.prototype。 3）查询或设置属性前面有提到过，可以通过点 . 或方括号 [] 运算符来获取属性的值。对于点 . 来说，左侧应当是一个对象，右侧必须是一个以属性名称命名的简单标识符。对于方括号来说 [] ，方括号内必须是一个计算结果为字符串的表达式，这个字符串就是属性的名称。例如： 1234567// 推荐写法console.log(person.name); // &quot;stone&quot;console.log(person.age); // &quot;28&quot;// 也可以写成console.log(person[&quot;name&quot;]); // stoneconsole.log(person[&quot;age&quot;]); // 28 和获取属性的值写法一样，通过点和方括号也可以创建属性或给属性赋值，但需要将它们放在赋值表达式的左侧。例如： 123456789// 推荐写法person.name = &quot;sophie&quot;; // 赋值person.age = 30; // 赋值person.weight = 38; // 创建// 也可以写成person[&quot;name&quot;] = &quot;sophie&quot;; // 赋值person[&quot;age&quot;] = 30; // 赋值person[&quot;weight&quot;] = 38; // 创建 当使用方括号时，方括号内的表达式必须返回字符串。更严格地讲，表达式必须返回字符串或返回一个可以转换为字符串的值。 查看一个对象本身的所有属性，可以使用Object.keys方法。 1234567var obj = &#123; key1: 1, key2: 2&#125;;Object.keys(obj);// [&#x27;key1&#x27;, &#x27;key2&#x27;] 4）属性的访问错误查询一个不存在的属性并不会报错，如果在对象 o 自身的属性或继承的属性中均未找到属性 x，属性访问表达式 o.x 返回 undefined。例如： 12var person = &#123;&#125;;person.wife; // undefined 但是，如果对象不存在，那么试图查询这个不存在的对象的属性就会报错。null 和 undefined 值都没有属性，因此查询这些值的属性会报错。例如： 12var person = &#123;&#125;;person.wife.name; // Uncaught TypeError: Cannot read property &#x27;name&#x27; of undefined. 除非确定 person 和 person.wife 都是对象，否则不能这样写表达式 person.wife.name，因为会报「未捕获的错误类型」，下面提供了两种避免出错的方法： 123456789// 冗余但易懂的写法var name;if (person) &#123; if (person.wife) name = person.wife.name;&#125;// 简练又常用的写法（推荐写法）var name = person &amp;&amp; person.wife &amp;&amp; person.wife.name; 5）删除属性delete操作符用于从对象中移除属性。它唯一的操作数应该是一个属性访问表达式。 123456var obj = &#123; p: 1 &#125;;Object.keys(obj) // [&quot;p&quot;]delete obj.p // trueobj.p // undefinedObject.keys(obj) // [] 上面代码中，delete命令删除对象obj的p属性。删除后，再读取p属性就会返回undefined，而且Object.keys方法的返回值也不再包括该属性。 注意，删除一个不存在的属性，delete不报错，而且返回true。 12var obj = &#123;&#125;;delete obj.p // true 上面代码中，对象obj并没有p属性，但是delete命令照样返回true。因此，不能根据delete命令的结果，认定某个属性是存在的。 另外，需要注意的是，delete命令只能删除对象本身的属性，无法删除继承的属性。 123var obj = &#123;&#125;;delete obj.toString // trueobj.toString // function toString() &#123; [native code] &#125; 上面代码中，toString是对象obj继承的属性，虽然delete命令返回true，但该属性并没有被删除，依然存在。这个例子还说明，即使delete返回true，该属性依然可能读取到值。 6）检测属性JavaScript 对象可以看做属性的集合，我们经常会检测集合中成员的所属关系（判断某个属性是否存在于某个对象中）。可以通过 in 运算符、hasOwnPreperty() 和 propertyIsEnumerable() 来完成这个工作，甚至仅通过属性查询也可以做到这一点。 in 运算符的左侧是属性名（字符串），右侧是对象。如果对象的自有属性或继承属性中包含这个属性则返回 true。例如： 1234var o = &#123; x: 1 &#125;console.log(&quot;x&quot; in o); // true，x是o的属性console.log(&quot;y&quot; in o); // false，y不是o的属性console.log(&quot;toString&quot; in o); // true，toString是继承属性 对象的 hasOwnProperty() 方法用来检测给定的名字是否是对象的自有属性。对于继承属性它将返回 false。例如： 1234var o = &#123; x: 1 &#125;console.log(o.hasOwnProperty(&quot;x&quot;)); // true，x是o的自有属性console.log(o.hasOwnProperty(&quot;y&quot;)); // false，y不是o的属性console.log(o.hasOwnProperty(&quot;toString&quot;)); // false，toString是继承属性 propertyIsEnumerable() 是 hasOwnProperty() 的增强版，只有检测到是自有属性且这个属性的可枚举性（enumerable attribute）为 true 时它才返回 true。某些内置属性是不可枚举的。通常由 JavaScript 代码创建的属性都是可枚举的，除非在 ECMAScript 5 中使用一个特殊的方法来改变属性的可枚举性。例如： 12345var o = inherit(&#123; y: 2 &#125;);o.x = 1;o.propertyIsEnumerable(&quot;x&quot;); // true:，x是o的自有属性，可枚举o.propertyIsEnumerable(&quot;y&quot;); // false，y是继承属性Object.prototype.propertyIsEnumerable(&quot;toString&quot;); // false，不可枚举 除了使用 in 运算符之外，另一种更简便的方法是使用 !== 判断一个属性是否是 undefined。例如： 1234var o = &#123; x: 1 &#125;console.log(o.x !== undefined); // true，x是o的属性console.log(o.y !== undefined); // false，y不是o的属性console.log(o.toString !== undefined); // true，toString是继承属性 然而有一种场景只能使用 in 运算符而不能使用上述属性访问的方式。in 可以区分不存在的属性和存在但值为 undefined 的属性。例如： 1234567var o = &#123; x: undefined &#125; // 属性被显式赋值为undefinedconsole.log(o.x !== undefined); // false，属性存在，但值为undefinedconsole.log(o.y !== undefined); // false，属性不存在console.log(&quot;x&quot; in o); // true，属性存在console.log(&quot;y&quot; in o); // false，属性不存在console.log(delete o.x); // true，删除了属性xconsole.log(&quot;x&quot; in o); // false，属性不再存在 7）枚举属性除了检测对象的属性是否存在，我们还会经常遍历对象的属性。通常使用 for-in 循环遍历，ECMAScript 5 提供了两个更好用的替代方案。 for-in 循环可以在循环体中遍历对象中所有可枚举的属性（包括自有属性和继承的属性），把属性名称赋值给循环变量。对象继承的内置方法不可枚举的，但在代码中给对象添加的属性都是可枚举的。例如： 123456789101112var obj = &#123;a: 1, b: 2, c: 3&#125;;for (var i in obj) &#123; console.log(&#x27;键名：&#x27;, i); console.log(&#x27;键值：&#x27;, obj[i]);&#125;// 键名： a// 键值： 1// 键名： b// 键值： 2// 键名： c// 键值： 3 for...in循环有两个使用注意点。 它遍历的是对象所有可遍历（enumerable）的属性，会跳过不可遍历的属性。 它不仅遍历对象自身的属性，还遍历继承的属性。 举例来说，对象都继承了toString属性，但是for...in循环不会遍历到这个属性。 12345678var obj = &#123;&#125;;// toString 属性是存在的obj.toString // toString() &#123; [native code] &#125;for (var p in obj) &#123; console.log(p);&#125; // 没有任何输出 上面代码中，对象obj继承了toString属性，该属性不会被for...in循环遍历到，因为它默认是“不可遍历”的。关于对象属性 的可遍历性，参见《标准库》章节中 Object 一章的介绍。 如果继承的属性是可遍历的，那么就会被for...in循环遍历到。但是，一般情况下，都是只想遍历对象自身的属性，所以使 用for...in的时候，应该结合使用hasOwnProperty方法，在循环内部判断一下，某个属性是否为对象自身的属性。 12345678var person = &#123; name: &#x27;老张&#x27; &#125;;for (var key in person) &#123; if (person.hasOwnProperty(key)) &#123; console.log(key); &#125;&#125;// name 8）属性的 getter 和 setter我们知道，对象属性是由名字、值和一组特性（attribute）构成的。在 ECMAScript 5 中，属性值可以用一个或两个方法替代，这两个方法就是 getter 和 setter。由 getter 和 setter 定义的属性称做「存取器属性（accessor property）」，它不同于「数据属性（data property）」，数据属性只有一个简单的值。 当程序查询存取器属性的值时，JavaScript 调用 getter 方法。这个方法的返回值就是属性存取表达式的值。当程序设置一个存取器属性的值时，JavaScript 调用 setter 方法，将赋值表达式右侧的值当做参数传入 setter。从某种意义上讲，这个方法负责「设置」属性值。可以忽略 setter 方法的返回值。 和数据属性不同，存取器属性不具有可写性（writable attribute）。如果属性同时具有 getter 和 setter 方法，那么它是一个读&#x2F;写属性。如果它只有 getter 方法，那么它是一个只读属性。如果它只有 setter 方法，那么它是一个只写属性，读取只写属性总是返回 undefined。定义存取器属性最简单的方法是使用对象直接量语法的一种扩展写法。例如： 12345678var o = &#123; // 普通的数据属性 data_prop: value, // 存取器属性都是成对定义的函数 get accessor_prop() &#123; /*这里是函数体 */ &#125;, set accessor_prop(value) &#123; /* 这里是函数体*/ &#125;&#125;; 存取器属性定义为一个或两个和属性同名的函数，这个函数定义没有使用 function 关键字，而是使用 get 或 set。注意，这里没有使用冒号将属性名和函数体分隔开，但在函数体的结束和下一个方法或数据属性之间有逗号分隔。 9）序列化对象（JSON）对象序列化（serialization）是指将对象的状态转换为字符串，也可将字符串还原为对象。ECMAScript 5 提供了内置函数 JSON.stringify() 和 JSON.parse() 用来序列化和还原 JavaScript 对象。这些方法都使用 JSON 作为数据交换格式，JSON 的全称是「JavaScript 对象表示法（JavaScript Object Notation）」，它的语法和 JavaScript 对象与数组直接量的语法非常相近。例如： 123o = &#123;x:1, y:&#123;z:[false,null,&quot;&quot;]&#125;&#125;; // 定义一个对象s = JSON.stringify(o); // s是 &#x27;&#123;&quot;x&quot;:1,&quot;y&quot;:&#123;&quot;z&quot;:[false,null,&quot;&quot;]&#125;&#125;&#x27;p = JSON.parse(s); // p是o的深拷贝 ECMAScript 5 中的这些函数的本地实现和 https://github.com/douglascrockford/JSON-js 中的公共域 ECMAScript 3 版本的实现非常类似，或者说完全一样，因此可以通过引入 json2.js 模块在 ECMAScript 3 的环境中使用 ECMAScript 5 中的这些函数。 JSON 的语法是 JavaScript 语法的子集，它并不能表示 JavaScript 里的所有值。它支持对象、数组、字符串、无穷大数字、true、false 和 null，可以序列化和还原它们。NaN、Infinity 和 -Infinity 序列化的结果是 null，日期对象序列化的结果是 ISO 格式的日期字符串（参照 Date.toJSON() 函数），但 JSON.parse() 依然保留它们的字符串形态，而不会将它们还原为原始日期对象。函数、RegExp、Error 对象和 undefined 值不能序列化和还原。JSON.stringify() 只能序列化对象可枚举的自有属性。对于一个不能序列化的属性来说，在序列化后的输出字符串中会将这个属性省略掉。JSON.stringify() 和 JSON.parse() 都可以接收第二个可选参数，通过传入需要序列化或还原的属性列表来定制自定义的序列化或还原操作。","categories":[{"name":"javascript","slug":"javascript","permalink":"http://example.com/categories/javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://example.com/tags/javascript/"}]},{"title":"javascript数组","slug":"javascript数组","date":"2017-05-14T03:24:06.000Z","updated":"2022-05-26T11:37:43.526Z","comments":true,"path":"2017/05/14/javascript数组/","link":"","permalink":"http://example.com/2017/05/14/javascript%E6%95%B0%E7%BB%84/","excerpt":"","text":"数组数组是值的有序集合。每个值叫做一个元素，而每个元素在数组中有一个位置，以数字表示，称为索引。 JavaScript 数组是无类型的，数组元素可以是任意类型，并且同一个数组中的不同元素也可能有不同的类型。数组的元素甚至也可能是对象或其他数组。 JavaScript 数组是动态的，根据需要它们会增长或缩减，并且在创建数组时无须声明一个固定的大小或者在数组大小变化时无须重新分配空间。 JavaScript 数组可能是稀疏的，数组元素的索引不一定要连续的，它们之间可以有空缺。每个 JavaScript 数组都有一个 length 属性。针对非稀疏数组，该属性就是数组元素的个数。针对稀疏数组，length 比所有元素的索引要大。 JavaScript 数组是 JavaScript 对象的特殊形式，数组索引实际上和碰巧是整数的属性名差不多。通常，数组的实现是经过优化的，用数字索引来访问数组元素一般来说比访问常规的对象属性要快很多。 数组继承自 Array.prototype 中的属性，它定义了一套丰富的数组操作方法。 1）创建数组1）数组字面量 12345678910var empty = []; // 没有元素的数组var primes = [2, 3, 5, 7, 11]; // 有5个数值的数组var misc = [1.1, true, &quot;a&quot;]; // 3个不同类型的元素// 数组直接量中的值不一定要是常量，可以是任意的表达式var base = 1024;var table = [base, base+1, base+2, base+3];// 也可以包含对象直接量或其他数组直接量var b = [[1, &#123;x:1, y:2&#125;], [2, &#123;x:3, y:4&#125;]]; 注意，不要忽略数组字面量的最后一个元素，仅以逗号结尾。下面几个案例，在不同的浏览器下，可能会被识别成2个元素，也有可能识别成3个元素，而造成程序bug。例如： 123var nums = [,,,]; // 不好的写法var names = [&quot;stone&quot;,,]; // 不好的写法var colors = [&quot;red&quot;,&quot;green&quot;,]; // 不好的写法 2）通过new Array()创建 12345678// 调用时没有参数var a = new Array();// 调用时有一个数值参数，它指定长度var a = new Array(10); // 显式指定多个数组元素或者数组的一个非数值元素var a = new Array(5, 4, 3, 2, 1, &quot;testing&quot;); 2）数组的读写使用 [] 操作符来访问数组中的一个元素。数组的引用位于方括号的左边。方括号中是一个返回非负整数值的任意表达式。使用该语法既可以读又可以写数组的一个元素。例如： 1234567var a = [&quot;world&quot;]; // 从一个元素的数组开始var value = a[0]; // 读第0个元素a[1] = 3.14; // 写第1个元素var i = 2; a[i] = 3; // 写第2个元素a[i + 1] = &quot;hello&quot;; // 写第3个元素a[a[i]] = a[0]; // 读第0个和第2个元素，写第3个元素 请记住，数组是对象的特殊形式，可以为其创建任意名字的属性。但如果使用的属性是数组的索引，数组的特殊行为就是将根据需要更新它们的length属性值。 注意，可以使用负数或非整数来索引数组。这种情况下，数值转换为字符串，字符串作为属性名来用。既然名字不是非负整数，它就只能当做常规的对象属性，而非数组的索引。同样，如果凑巧使用了是非负整数的字符串，它就当做数组索引，而非对象属性。当使用的一个浮点数和一个整数相等时情况也是一样的。例如： 123a[-1.23] = true; // 这将创建一个名为&quot;-1.23&quot;的属性a[&quot;1000&quot;] = 0; // 这是数组的第1001个元素a[1.000] // 和 a[1] 相等 事实上数组索引仅仅是对象属性名的一种特殊类型，这意味着 JavaScript 数组没有「越界」错误的概念。当试图查询任何对象中不存在的属性时，不会报错，只会得到 undefined 值。 3）稀疏数组稀疏数组就是包含从0开始的不连续索引的数组。通常，数组的 length 属性值代表数组中元素的个数。如果数组是稀疏的，length 属性值大于元素的个数。可以用 Array() 构造函数或简单地指定数组的索引值大于当前的数组长度来创建稀疏数组。 123a = new Array(5); // 数组没有元素，但是 a.length = 5a = []; // 创建一个空数组，a.length = 0a[1000] = 0; // 添加一个元素，a.length 被自动更新为1001 足够稀疏的数组通常在实现上比稠密的数组更慢、内存利用率更高，在这样的数组中查找元素的时间与常规对象属性的查找时间一样长。 需要注意的是，当省略数组直接量中的值时（使用连续的逗号，比如 [1,,3] ），这时所得到的数组也是稀疏数组，省略掉的值是不存在的： 1234var a1 = [,&#x27;1&#x27;,&#x27;2&#x27;]; // 此数组长度是3 var a2 = [undefined]; // 此数组包含一个值为 undefined 的元素 console.log(0 in a1); // false，a1 在索引0处没有元素console.log(0 in a2); // true，a2 在索引0处有一个值为 undefined 的元素 了解稀疏数组是了解 JavaScript 数组的真实本质的一部分。尽管如此，实际上你所碰到的绝大多数 JavaScript 数组不是稀疏数组。并且，如果你确实碰到了稀疏数组，你的代码很可能像对待非稀疏数组一样来对待它们，只不过它们包含一些 undefined 值。 4）数组的长度每个数组有一个 length 属性，就是这个属性使其区别于常规的 JavaScript 对象。针对稠密（也就是非稀疏）数组，length 属性值代表数组中元素的个数。其值比数组中最大的索引大1。例如： 12[].length // 0，数组没有元素[&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;].length // 3，最大的索引为2，length 为3 当数组是稀疏的时，length 属性值大于元素的个数。而且关于此我们可以说的一切也就是数组长度保证大于它每个元素的索引值。或者，换一种说法，在数组中（无论稀疏与否）肯定找不到一个元素的索引值大于或等于它的长度。为了维持此规则不变化，数组有两个特殊的行为。 第一个如同上面的描述：如果为一个数组元素赋值，它的索引 i 大于或等于现有数组的长度时，length 属性的值将设置为 i+1。 第二个特殊的行为就是设置 length 属性为一个小于当前长度的非负整数 n 时，当前数组中那些索引值大于或等于 n 的元素将从中删除。例如： 1234a = [1,2,3,4,5]; // 从5个元素的数组开始a.length = 3; // 现在 a 为[1,2,3]a.length = 0; // 删除所有的元素。a 为[ ]a.length = 5; // 长度为5，但是没有元素，就像 new Array(5) 还可以将数组的 length 属性值设置为大于其当前的长度。实际上这不会向数组中添加新的元素，它只是在数组尾部创建一个空的区域。 在 ECMAScript 5 中，可以用 Object.defineProperty() 让数组的 length 属性变成只读的。例如： 123a = [1,2,3]; // 从3个元素的数组开始Object.defineProperty(a, &quot;length&quot;, &#123;writable: false&#125;); // 让 length 属性只读a.length = 0; // a 不会改变 5）添加或删除数组元素push():向数组末尾添加一个或多个元素 123let a = [];a.push(&#x27;one&#x27;);a.push(&#x27;two&#x27;,&#x27;three&#x27;) pop():删除数组最后一个元素并返回该元素。 12let a = [&#x27;one&#x27;,&#x27;two&#x27;,&#x27;three&#x27;];a.pop(); shift():删除并返回数组的第一个元素 12let a = [&#x27;one&#x27;,&#x27;two&#x27;,&#x27;three&#x27;];a.shift(); unshift():想数组首位添加一个元素 123let a = [&#x27;one&#x27;,&#x27;two&#x27;,&#x27;three&#x27;];a.unshift(&#x27;four&#x27;);a.unshift(&#x27;five&#x27;,&#x27;six&#x27;); splice(index,num): 从下标index位置开始，删除num个元素 12let color = [&#x27;red&#x27;,&#x27;yellow&#x27;,&#x27;green&#x27;,&#x27;pink&#x27;];let b = color.splice(1,2);//从下标1的位置，删除两项，并将调用splice放的返回值存放在变量b中 arr.splice(index,0,val1,val2..):在下标index位置，添加多个元素 12let color = [&#x27;red&#x27;,&#x27;yellow&#x27;,&#x27;green&#x27;,&#x27;pink&#x27;];console.log(color.splice(1,0,&#x27;#fff&#x27;,&#x27;#000&#x27;)) arr.splice(index,num,val1,val2…):先删除后添加; 从index 位置开始，先删除num个元素，再添加多个新元素； 12let color = [&#x27;red&#x27;,&#x27;yellow&#x27;,&#x27;green&#x27;,&#x27;pink&#x27;];let result = color.splice(2,2,&#x27;black&#x27;,&#x27;white&#x27;) 6）数组迭代使用 for 循环是遍历数组元素最常见的方法。例如： 123456var keys = Object.keys(o); // 获得 o 对象属性名组成的数组var values = [] // 在数组中存储匹配属性的值for(var i = 0; i &lt; keys.length; i++) &#123; // 对于数组中每个索引 var key = keys[i]; // 获得索引处的键值 values[i] = o[key]; // 在 values 数组中保存属性值&#125; 在嵌套循环或其他性能非常重要的上下文中，可以看到这种基本的数组遍历需要优化，数组的长度应该只查询一次而非每次循环都要查询。例如： 123for(var i = 0, len = keys.length; i &lt; len; i++) &#123; // 循环体仍然不变&#125; 这些例子假设数组是稠密的，并且所有的元素都是合法数据。否则，使用数组元素之前应该先检测它们。例如： 123456for(var i = 0; i &lt; a.length; i++) &#123; if (!a[i]) continue; // 跳过 null、undefined 和不存在的元素 if (!(i in a)) continue ; // 跳过不存在的元素 if (a[i] === undefined) continue; // 跳过 undefined 和不存在的元素 // 循环体&#125; 还可以使用 for-in 循环处理稀疏数组。循环每次将一个可枚举的属性名（包括数组索引）赋值给循环变量，不存在的索引将不会遍历到。例如： 1234for(var index in sparseArray) &#123; var value = sparseArray[index]; // 此处可以使用索引和值做一些事情&#125; 但由于 for-in 循环能够枚举继承的属性名，如添加到 Array.prototype 中的方法。基于这个原因，在数组上不应该使用 for-in 循环，除非使用额外的检测方法来过滤不想要的属性。例如： 1234567for(var i in a) &#123; // 跳过继承的属性 if (!a.hasOwnProperty(i)) continue; // 跳过不是非负整数的 i if (String(Math.floor(Math.abs(Number(i)))) !== i) continue;&#125; JavaScript 规范允许 for-in 循环以不同的顺序遍历对象的属性。通常数组元素的遍历实现是升序的，但不能保证一定是这样的。如果数组同时拥有对象属性和数组元素，返回的属性名很可能是按照创建的顺序而非数值的大小顺序。如何处理这个问题的实现，各个浏览器都不相同，如果算法依赖于遍历的顺序，那么最好不要使用 for-in 而用常规的 for 循环。 forEach():迭代数组的每个元素，并对每个元素都调用一次指定的函数。 12345678let data = [1,2,3,4,5,6,7],sum = 0;data.forEach(function(item)&#123; sum +=item;&#125;)或data.forEach(item=&gt;&#123; sum +=item;&#125;) map():把调用它的数组的每个元素分别传给指定的函数，返回这个函数的返回值构成的数组。 123let a = [1,2,3];let result = a.map(x =&gt; x*x)console.log(result) filter():返回一个数组，该数组包含调用它的数组的子数组。 123let a = [1,2,3,4,5,6,7,8];let result = a.filter(x=&gt;x&lt;3)let res = a.filter((x,i) =&gt; i%2===0); **some()**：类似于数学上的“存在”量词，只要数组元素中有一个让断言函数返回true它就返回true,但必须数组的所有元素对断言函数都返回false才返回false. 123let a = [1,2,3,4,5]a.some(x=&gt;x%2===0);a.some(isNaN) every():与数学上的全称量词类似，它在且只有断言函数对数组的所有元素都返回true时才返回true 123let a = [1,2,3,4,5];a.every(x=&gt;x&lt;10)a.every(x=&gt; x%2 ===0); 7）数组检测给定一个未知的对象，判定它是否为数组通常非常有用。在 ECMAScript 5 中，可以使用 Array.isArray() 函数来做这件事情。例如： 12Array.isArray([]) // trueArray.isArray(&#123;&#125;) // false 但是，在 ECMAScript 5 以前，要区分数组和非数组对象很困难。typeof 运算符对数组返回 &quot;object&quot;（并且对于除了函数以外的所有对象都是如此）。instanceof 操作符也只能用于简单的情形。例如： 12[] instanceof Array // true(&#123;&#125;) instanceof Array // false 使用 instanceof 的问题是在 Web 浏览器中有可能有多个窗体存在。每个窗体都有自己的 JavaScript 环境，有自己的全局对象。并且，每个全局对象有自己的一组构造函数。因此一个窗体中的对象将不可能是另外窗体中的构造函数的实例。窗体之间的混淆不常发生，但这个问题足已证明 instanceof 操作符不能视为一个可靠的数组检测方法。 解决方案是检查对象的类属性，对数组而言该属性的值总是 &quot;Array&quot;，因此在 ECMAScript 3 中 isArray() 函数的代码可以这样书写。例如： 123var isArray = Array.isArray || function(o) &#123; return typeof o === &quot;object&quot; &amp;&amp; Object.prototype.toString.call(o) === &quot;[object Array]&quot;;&#125;; 8）反转数组reverse():数组反转 12let a = [1,2,3,4,5]a.reverse(); 9）数组排序sort():数组的排序语法：arr.sort(function(a,b){return a-b}); 1234567891011121314升序var arr = [34,7,23,9,5];arr.sort(function(a,b)&#123; return a-b;&#125;)降序var arr = [34,7,23,9,5];arr.sort(function(a,b)&#123; return b-a;&#125;)不传参：按照ASCII码排序var arr = [34,7,23,9,5];arr.sort();console.log(arr); 10）数组合并**concat()**：将多个数组内容拿出来，合并成一个新数组； 语法：arr.concat(arr,arr1,arr2,….) 123var arr = [&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;,&#x27;d&#x27;];var arr2 = [1,2,3];console.log(arr.concat(arr2)); 11）数组的截取slice():返回截取的内容 slice的截取时，包含开始位置，不包含截取位置； arr.slice(start,end);&#x2F;&#x2F;从开始start位置截取到end位置，不包含结束位置 arr.slice(start);&#x2F;&#x2F;从开始位置一直截取最后 arr.slice();&#x2F;&#x2F;不传参：表示，截取整个数组； slice();支持负值； slice()不会改变原数组 123456789101112传两个参数：var color = [&#x27;pink&#x27;,&#x27;red&#x27;,&#x27;yellow&#x27;,&#x27;blue&#x27;,&#x27;green&#x27;];console.log(color.slice(1,3))//从下标1开始截取到下标3，不包含下标3传一个参数var color = [&#x27;pink&#x27;,&#x27;red&#x27;,&#x27;yellow&#x27;,&#x27;blue&#x27;,&#x27;green&#x27;];var a = color.slice(1);//参数1表示从下标1开始一直截取到最后不传参var color = [&#x27;pink&#x27;,&#x27;red&#x27;,&#x27;yellow&#x27;,&#x27;blue&#x27;,&#x27;green&#x27;];var b = color.slice();//不传参，表示全部截取，将截取结果赋值给b参数为负值var color = [&#x27;pink&#x27;,&#x27;red&#x27;,&#x27;yellow&#x27;,&#x27;blue&#x27;,&#x27;green&#x27;];var c = color.slice(-3,4);//坐标= 负值+数组长度 -3+5 = 2(2,4) 12）数组索引indexOf():从数组前向后中搜索指定的值并返回第一个找到的元素的索引，如果没找到则返回-1. 123var color = [&#x27;pink&#x27;,&#x27;red&#x27;,&#x27;yellow&#x27;,&#x27;blue&#x27;,&#x27;green&#x27;];console.log(color.indexOf(&#x27;red&#x27;)) lastIndexOf():从数组后向前中搜索指定的值并返回第一个找到的元素的索引，如果没找到则返回-1. 12var color = [&#x27;pink&#x27;,&#x27;red&#x27;,&#x27;yellow&#x27;,&#x27;blue&#x27;,&#x27;green&#x27;];console.log(color.lastIndexOf(&#x27;red&#x27;)) 13）数组转字符串join():将数组的每一项通过连接符，拼接为一个新字符串； 12var color = [&#x27;pink&#x27;,&#x27;red&#x27;,&#x27;yellow&#x27;,&#x27;blue&#x27;,&#x27;green&#x27;];console.log(color.join(&#x27;,&#x27;))","categories":[{"name":"javascript","slug":"javascript","permalink":"http://example.com/categories/javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://example.com/tags/javascript/"}]},{"title":"javascript字符串","slug":"javascript字符串","date":"2017-05-05T03:19:08.000Z","updated":"2022-05-26T11:37:06.331Z","comments":true,"path":"2017/05/05/javascript字符串/","link":"","permalink":"http://example.com/2017/05/05/javascript%E5%AD%97%E7%AC%A6%E4%B8%B2/","excerpt":"","text":"String对象字符串的拼接可以使用“+”操作符 1let msg = &quot;Hello&quot; + &quot;World&quot;; 可以使用标准的全等&#x3D;&#x3D;&#x3D;和不全等!&#x3D;&#x3D;操作符进行字符串比较。 字符串也可以使用&lt;、&lt;&#x3D;、&gt;和&gt;&#x3D;操作符来比较，字符串比较是通过比较16位值完成的。 1）length:字符串长度12var s = &quot;hello world&quot;;console.log(s.length) 2）截取字符串1234var s = &quot;Hello World&quot;;s.substring(1,4);//取第2-4个字符s.slice(1,4);//同上s.slice(-3);最后3个字符 3）拆分字符串12var s = &quot;Hello,World&quot;;s.split(&quot;,&quot;);//[&quot;Hello&quot;,&quot;World&quot;]从定界符处拆开 4）搜索字符串1234var s = &quot;Hello World&quot;;s.indexOf(&quot;l&quot;); //第一个字母l的位置s.indexOf(&quot;l&quot;,3);//位置3后面第一个&quot;l&quot;的位置s.indexOf(&quot;zz&quot;);// -1,s并不包含子串&quot;zz&quot; 5）从后向前搜索字符串。12var s = &quot;Hello World&quot;;s.lastIndexOf(&#x27;l&#x27;)// 9 6）字符串已那些字符开头或结尾1234var s = &quot;Hello World&quot;;s.startWith(&quot;Hell&quot;);=&gt;trues.endWith(&quot;!&quot;)=&gt;falses.includes(&quot;or&quot;) ;=&gt;true 7）替换与正则表达式匹配的子串12var s = &quot;Hello World&quot;;s.replace(&quot;llo&quot;,&#x27;ya&#x27;) 8）把字符串转换为小写123var s = &quot;HELLO WORLD&quot;;s.toLowerCase();s.toLocaleLowerCase() 9）把字符串转换为大写123var s = &quot;hello world&quot;;s.toUpperCase();s.toLocaleUpperCase() 10）返回在指定位置的字符12var s = &quot;Hello World&quot;;s.charAt(0) 11）从起始索引号提取字符串中指定数目的字符12var str=&quot;Hello world!&quot;document.write(str.substr(3)) =&gt;lo world! 12）去除空格1234var s =&quot; Hello World &quot;;s.trim();//删除两侧空格s.trimStart();//删除左侧空格s.trimEnd();//删除右侧空格 13) 字符串填充123var s =&quot;Hello World&quot;;s.padStart(3,&#x27;*&#x27;);//左侧填充三个*s.padEnd(3,&#x27;*&#x27;);//右侧填充三个*","categories":[{"name":"javascript","slug":"javascript","permalink":"http://example.com/categories/javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://example.com/tags/javascript/"}]},{"title":"javascript语句","slug":"javascript语句","date":"2017-05-03T01:34:16.000Z","updated":"2022-05-26T11:37:15.367Z","comments":true,"path":"2017/05/03/javascript语句/","link":"","permalink":"http://example.com/2017/05/03/javascript%E8%AF%AD%E5%8F%A5/","excerpt":"","text":"语句表达式在 JavaScript 中是短语，那么语句就是整句命令。表达式用来计算出一个值，语句用来执行以使某件事发生。从本质上看，语句定义了 JavaScript 中的主要语法，语句通常使用一或多个关键字来完成给定任务。语句可以很简单，例如通知函数退出；也可以比较复杂，例如指定重复执行某个命令的次数。下表列出了 JavaScript 大部分语句的语法和用途： 语句 语法 用途 break break [label]; 退出最内层循环或者退出 switch 语句，又或者退出 label 指定的语句 case case expression: 在 switch 语句中标记一条语句 continue continue [label]; 重新开始最内层的循环或重新开始 label 指定的循环 debugger debugger; 断点器调试 default default; 在 switch 中标记默认的语句 do-while do statement while(expression); while 循环的一种替代形式 empty ; 什么都不做 for for(init;expr;incr) statement 简写的循环结构 for-in for(var in object) statement 遍历一个对象的属性 function function name([param[],...])&#123;statement&#125; 声明一个函数 if-else if (expression) statement1[else statement2] 执行 statement1 或者 statement2 label label:statement 给 statement 指定一个名字 label return return [expression]; 从函数返回一个值 switch switch(expression)&#123;statement&#125; 用 case 或者 default 语句标记的多分支语句 throw throw expression; 抛出异常 try try &#123;statement&#125;[catch &#123;handler statement&#125;][finally &#123;cleaup statement&#125;] 捕获异常 use strict &quot;use strict&quot; 对脚本和函数应用严格模式 var var name=[=expr][,...]; 声明并初始化一个或多个变量 while while(expression) statement 基本的循环结构 with with(object) statement 扩展作用域链 1)条件语句if-else 语句大多数编程语言中最为常用的一个语句就是 if-else 语句。以下是 if-else 语句的语法： 1if (condition) statement1 [else statement2] 其中的 condition 可以是任意表达式；而且对这个表达式求值的结果不一定是布尔值。JavaScript 会自动调用 Boolean() 转换函数将这个表达式的结果转换为一个布尔值。如果对 condition 求值的结果是 true，则执行 statement1，如果对 condition 求值的结果是 false，则执行 statement2。而且这两个语句既可以是一行代码，也可以是一个代码块（以一对花括号括起来的多行代码）。请看下面的例子： 12345if (i &gt; 25) console.log(&quot;Greater than 25.&quot;); // 单行语句else &#123; console.log(&quot;Less than or equal to 25.&quot;); // 代码块中的语句&#125; 业界普遍推崇的最佳实践是始终使用代码块，即使要执行的只有一行代码。因为这样可以消除人们的误解，否则可能让人分不清在不同条件下要执行哪些语句。 switch 语句switch 语句与 if 语句的关系最为密切，而且也是在其他语言中普遍使用的一种流控制语句。JavaScript 中 switch 语句的语法与其他基于 C 的语言非常接近，如下所示： 1234567891011switch (expression) &#123; case value: statement break; case value: statement break; case value: statement break; case value: statement break; default: statement&#125; switch 语句中的每一种情形的含义是：“如果表达式等于这个值（value），则执行后面的语句（statement）”。而 break 关键字会导致代码执行流跳出 switch 语句。如果省略 break 关键字，就会导致执行完当前 case 后，继续执行下一个 case。最后的 default 关键字则用于在表达式不匹配前面任何一种情形的时候，也相当于一个 else 语句。从根本上讲，switch 语句就是为了让开发人员免于编写像下面这样的代码： 123456789if (i === 25)&#123; console.log(&quot;25&quot;);&#125; else if (i === 35) &#123; console.log(&quot;35&quot;);&#125; else if (i === 45) &#123; console.log(&quot;45&quot;);&#125; else &#123; console.log(&quot;Other&quot;);&#125; 而与此等价的switch语句如下所示： 12345678910111213switch (i) &#123; case 25: console.log(&quot;25&quot;); break; case 35: console.log(&quot;35&quot;); break; case 45: console.log(&quot;45&quot;); break; default: console.log(&quot;Other&quot;);&#125; 通过为每个case后面都添加一个break语句，就可以避免同时执行多个case代码的情况。假如确实需要混合几种情形，不要忘了在代码中添加注释，说明你是有意省略了break关键字。 虽然 JavaScript 中的 switch 语句借鉴自其他语言，但这个语句也有自己的特色。首先，可以在 switch 语句中使用任何数据类型（在很多其他语言中只能使用数值），无论是字符串，还是对象都没有问题。其次，每个 case 的值不一定是常量，可以是变量，甚至是表达式。请看下面这两个例子： 12345678910111213141516171819202122232425switch (&quot;hello world&quot;) &#123; case &quot;hello&quot; + &quot; world&quot;: console.log(&quot;Greeting was found.&quot;); break; case &quot;goodbye&quot;: console.log(&quot;Closing was found.&quot;); break; default: console.log(&quot;Unexpected message was found.&quot;);&#125;var num = 25;switch (true) &#123; case num &lt; 0: console.log(&quot;Less than 0.&quot;); break; case num &gt;= 0 &amp;&amp; num &lt;= 10: console.log(&quot;Between 0 and 10.&quot;); break; case num &gt; 10 &amp;&amp; num &lt;= 20: console.log(&quot;Between 10 and 20.&quot;); break; default: console.log(&quot;More than 20.&quot;);&#125; switch 语句首先计算 switch 关键字后的表达式，然后按照从上到下的顺序计算每个 case 后的表达式，直到执行到 case 的表达式的值与 switch 的表达式的值相等时为止。由于对每个 case 的匹配操作实际上是 === 恒等运算符比较，而不是 == 相等运算符比较，因此，表达式和 case 的匹配并不会做任何类型转换。 2）循环while 语句while 语句属于前测试循环语句，也就是说，在循环体内的代码被执行之前，就会对出口条件求值。因引，循环体内的代码有可能永远不会被执行。以下是 while 语句的语法： 1while(expression) statement 下面是一个示例： 1234var i = 0;while (i &lt; 10) &#123; i += 2;&#125; do-while 语句do-while 语句是一种后测试循环语句，即只有在循环体中的代码执行之后，才会测试出口条件。换句话说，在对条件表达式求值之前，循环体内的代码至少会被执行一次。以下是 do-while 语句的语法： 123do &#123; statement&#125; while (expression); 下面是一个示例： 1234var i = 0;do &#123; i += 2;&#125; while (i &lt; 10); for 语句for 语句也是一种前测试循环语句，但它具有在执行循环之前初始化变量和定义循环后要执行的代码的能力。以下是 for 语句的语法： 1for (初始化变量; 条件表达式; 操作表达式) 循环体 下面是一个示例： 1234var count = 10;for (var i = 0; i &lt; count; i++)&#123; console.log(i);&#125; 这个 for 循环语句与下面的 while 语句的功能相同： 123456var count = 10;var i = 0;while (i &lt; count)&#123; console.log(i); i++;&#125; 由于 JavaScript 中不存在块级作用域，因此在循环内部定义的变量也可以在外部访问到。例如： 12345var count = 10;for (var i = 0; i &lt; count; i++)&#123; console.log(i);&#125;console.log(i); // 10 此外，for 语句中的初始化表达式、控制表达式和循环后表达式都是可选的。将这两个表达式全部省略，就会创建一个无限循环，例如： 12345// 无限循环for (;;) &#123; doSomething();&#125; for-in 语句for-in 语句是一种精准的迭代语句，可以用来枚举对象的属性。以下是 for-in 语句的语法： 1for (property in object) statement 下面是一个示例： 123for (var propName in window) &#123; console.log(propName);&#125; 在这个例子中，我们使用 for-in 循环来显示了 BOM 中 window 对象的所有属性。每次执行循环时，都会将 window 对象中存在的一个属性名赋值给变量 propName。这个过程会一直持续到对象中的所有属性都被枚举一遍为止。与 for 语句类似，这里控制语句中的 var 操作符也不是必需的。但是，为了保证使用局部变量，我们推荐上面例子中的这种做法。 JavaScript 对象的属性没有顺序。因此，通过 for-in 循环输出的属性名的顺序是不可预测的。具体来讲，所有属性都会被返回一次，但返回的先后次序可能会因浏览器而异。 如果表示要迭代的对象的变量值为 null 或 undefined，for-in 语句会抛出错误。虽然 ECMAScript 5 更正了这一行为；对这种情况不再抛出错误，而只是不执行循环体。为了保证最大限度的兼容性，建议在使用 for-in 循环之前，先检测确认该对象的值不是 null 或 undefined。 3）跳转break 和 continue 语句break 和 continue 语句用于在循环中精确地控制代码的执行。其中，break 语句会立即退出循环，强制继续执行循环后面的语句。而 continue 语句虽然也是立即退出循环，但退出循环后会从循环的顶部继续执行。请看下面的例子： 12345678910var num = 0;for (var i=1; i &lt; 10; i++) &#123; if (i % 5 == 0) &#123; break; &#125; num++;&#125;console.log(num); // 4 这个例子中的 for 循环会将变量 i 由1递增至 10。在循环体内，有一个 if 语句检查 i 的值是否可以被 5 整除（使用求模运算符）。如果是，则执行 break 语句退出循环。另一方面，变量 num 从 0 开始，用于记录循环执行的次数。在执行 break 语句之后，结果显示 4。也就是说，在变量 i 等于 5 时，循环总共执行了 4 次；而 break 语句的执行，导致了循环在 num 再次递增之前就退出了。如果在这里把 break 替换为 continue 的话，则可以看到另一种结果： 12345678910var num = 0;for (var i=1; i &lt; 10; i++) &#123;if (i % 5 == 0) &#123; continue; &#125; num++;&#125;console.log(num); // 8 例子的结果显示 8，也就是循环总共执行了 8 次。当变量 i 等于 5 时，循环会在 num 再次递增之前退出，但接下来执行的是下一次循环，即i的值等于 6 的循环。于是，循环又继续执行，直到 i 等于 10 时自然结束。而 num 的最终值之所以是 8，是因为 continue 语句导致它少递增了一次。 break 和 continue 语句都可以与 label 语句联合使用，从而返回代码中特定的位置。这种联合使用的情况多发生在循环嵌套的情况下，如下面的例子所示： 12345678910111213var num = 0;outermost:for (var i = 0; i &lt; 10; i++) &#123; for (var j = 0; j &lt; 10; j++) &#123; if (i == 5 &amp;&amp; j == 5) &#123; break outermost; &#125; num++; &#125;&#125;console.log(num); // 55 在这个例子中，outermost 标签表示外部的 for 语句。如果每个循环正常执行 10 次，则 num++ 语句就会正常执行 100 次。换句话说，如果两个循环都自然结束，num 的值应该是 100。但内部循环中的 break 语句带了一个参数：要返回到的标签。添加这个标签的结果将导致 break 语句不仅会退出内部的 for 语句（即使用变量 j 的循环），而且也会退出外部的 for 语句（即使用变量 i 的循环）。为此，当变量 i 和 j 都等于 5 时， num的值正好是 55。同样，continue 语句也可以像这样与 label 语句联用，如下面的例子所示： 12345678910111213var num = 0;outermost:for (var i = 0; i &lt; 10; i++) &#123; for (var j = 0; j &lt; 10; j++) &#123; if (i == 5 &amp;&amp; j == 5) &#123; continue outermost; &#125; num++; &#125;&#125;console.log(num); // 95 在这种情况下，continue 语句会强制继续执行循环，退出内部循环，执行外部循环。当 j 是 5 时，continue 语句执行，而这也就意味着内部循环少执行了 5 次，因此 num 的结果是 95。 虽然联用 break、continue 和 label 语句能够执行复杂的操作，但如果使用过度，也会给调试带来麻烦。在此，我们建议如果使用 label 语句，一定要使用描述性的标签，同时不要嵌套过多的循环。 return 语句return 语句的作用是指定函数调用后的返回值。return 语句的语法如下： 1return [expression]; 下面是一个示例： 12function square(x) &#123; return x*x; &#125; // 一个包含 return 语句的函数square(2); // 调用结果为 4 return 语句只能在函数体内出现，如果不是的话会报语法错误。当执行到 return 语句的时候，函数终止执行，并返回 expression 的值给调用程序。如果没有 return 语句，则函数调用仅依次执行函数体内的每一条语句直到函数结束，最后返回调用程序。这种情况下，调用表达式的结果是 undefined。return 语句经常作为函数内的最后一条语句出现，但并不是说要一定放在函数最后。return 语句可以单独使用而不必带有 expression，这样的话函数也会向调用程序返回 undefined。 由于 JavaScript 可以自动插入分号，因此在 return 关键字和它后面的表达式之间不能有换行。 4）其他with 语句with 语句的作用是将代码的作用域设置到一个特定的对象中。with 语句的语法如下： 1with (expression) statement; 定义 with 语句的目的主要是为了简化多次编写同一个对象的工作，如下面的例子所示： 123var qs = location.search.substring(1);var hostName = location.hostname;var url = location.href; 上面几行代码都包含 location 对象。如果使用 with 语句，可以把上面的代码改写成如下所示： 12345with(location)&#123; var qs = search.substring(1); var hostName = hostname; var url = href;&#125; 在这个重写后的例子中，使用 with 语句关联了 location 对象。这意味着在 with 语句的代码块内部，每个变量首先被认为是一个局部变量，而如果在局部环境中找不到该变量的定义，就会查询 location 对象中是否有同名的属性。如果发现了同名属性，则以 location 对象属性的值作为变量的值。 由于大量使用 with 语句会导致性能下降，同时也会给调试代码造成困难，因此在开发大型应用程序时，不建议使用 with 语句。严格模式下不允许使用 with 语句，否则将视为语法错误。 代码块代码块将多个语句组合为一个复合语句。代码块其实就是一系列语句，可以放在任何期待一个语句的地方： 12345&#123; x = Math.PI cx = Math.cos(x) console.log(&quot;cos(n)= &quot; + cx)&#125; 注意：1)它没有以分号结尾。块中的单条语句都以分号结尾，但块本身没有。2）块中的代码相对于包含它们的花括号缩进","categories":[{"name":"javascript","slug":"javascript","permalink":"http://example.com/categories/javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://example.com/tags/javascript/"}]},{"title":"javascript表达式和操作符","slug":"javascript表达式和操作符","date":"2017-04-23T08:18:22.000Z","updated":"2022-05-26T11:40:01.357Z","comments":true,"path":"2017/04/23/javascript表达式和操作符/","link":"","permalink":"http://example.com/2017/04/23/javascript%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%92%8C%E6%93%8D%E4%BD%9C%E7%AC%A6/","excerpt":"","text":"表达式与操作符1）表达式表达式是由数字、运算符、数字分组符号（如括号）、自由变量和约束变量等以能求得数值的有意义排列方法所得的组合。JavaScript 表达式主要有以下几种形式： 原始表达式：常量、变量、保留字。 对象、数组初始化表达式：var obj=&#123;a:1,b:2&#125;;，var arr=[1,2,3];。 函数定义表达式：var fn=function()&#123;&#125;。 属性访问表达式：Math.abs。 调用表达式：alert(&#39;hello&#39;);。 对象创建表达式：new object();。 1）函数定义表达式函数定义表达式通常用关键字function,位于括号中的逗号分隔的0或多个标识符，以及一个位于花括号中的js代码块构成。 12345let square = function(x)&#123; return x*x;&#125;或function square(x)&#123; return x*x;&#125; 2）属性访问表达式属性访问表达式求值为对象属性或数组元素的值，其语法结构为 12expression.identifierexpression[identifier] 第一种属性访问语法是表达式后跟着一个句点和一个标识符。其中，表达式指定对象，标识符指定属性名。第二种属性访问语法是表达式后跟另一个位于方括号中的表达式。这第二个表达式指定属性名或数组元素的索引。 123456let o = &#123;x:1,y:&#123;z:3&#125;&#125;;let a = [o,4,[5,6]]o.x;o.y.za[1]a[0] 2）运算符JavaScript 中的运算符用于算术表达式、比较表达式、逻辑表达式、赋值表达式等。需要注意的是，大多数运算符都是由标点符号表示的，比如 + 和 =。而另外一些运算符则是由关键字表示的，比如 typeof 和 instanceof，关键字运算符和标点符号都是正规的运算符。 下表列出了 JavaScript 中所有的运算符，并按照运算符的优先级排序的，前面的运算符优先级要高于后面的运算符优先级，被空行分隔开来的运算符具有不同的优先级。标题为 A 的列表示运算符的结合性（Associativity），L 表示从左至右、R 表示从右至左，标题为 N 的列表示操作数的个数（Number）。 运算符 操作 A N ++ 前&#x2F;后增量 R 1 -- 前&#x2F;后增量 R 1 - 求反 R 1 + 转换为数字 R 1 ~ 按位求反 R 1 ! 逻辑非 R 1 delete 删除属性 R 1 typeof 检测类型 R 1 void 返回undefined R 1 * / % 乘，除，求模 L 2 + - 加，减 L 2 + 字符串连接 L 2 &lt;&lt; 左移位 L 2 &gt;&gt; 有符号右移 L 2 &gt;&gt;&gt; 无符号右移 L 2 &lt; &lt;= &gt; &gt;= 比较数字顺序 L 2 &lt; &lt;= &gt; &gt;= 比较字母顺序 L 2 instanceof 测试对象类 L 2 in 测试属性是否存在 L 2 == 判断相等 L 2 != 判断不等 L 2 === 判断恒等 L 2 !== 判断恒不等 L 2 &amp; 按位与 L 2 ^ 按位异或 L 2 ┃ 按位或 L 2 &amp;&amp; 逻辑与 L 2 ┃┃ 逻辑或 L 2 ?: 条件运算符 R 3 = 赋值 R 2 *= /= %= += -= &amp;= &lt;&lt;= &gt;&gt;= ^= ┃= &gt;&gt;&gt;= 运算且赋值 R 2 , 忽略第一个操作数， 返回第二个操作数 L 2 因为 | 是制表符，会导致格式混乱，所以表格中的 | 均以 ┃ 代替。 1）一元运算符（1）delete 运算符delete 运算符用来删除对象属性或者数组元素，如果删除成功或所删除的目标不存在，delete 将返回 true。然而，并不是所有的属性都可删除，一些内置核心和客户端属性是不能删除的，通过 var 语句声明的变量不能删除，通过 function 语句定义的函数也是不能删除的。例如： 1234567891011121314151617var o = &#123; x: 1, y: 2&#125;; // 定义一个对象console.log(delete o.x); // true，删除一个属性console.log(delete o.x); // true，什么都没做，x 在已上一步被删除console.log(&quot;x&quot; in o); // false，这个属性在对象中不再存在console.log(delete o.toString); // true，什么也没做，toString是继承来的console.log(delete 1); // true，无意义var a = [&quot;x&quot;,&quot;y&quot;,&quot;z&quot;]; // 定义一个数组console.log(2 in a); // true，下标为2的元素，在数组中存在console.log(delete a[2]); // true，删除下标为2的元素（最后一个数组元素）console.log(2 in a); // false，下标为2的元素，在数组中不再存在console.log(a.length); // 3，数组长度并不会因 delete 而改变console.log(a[2]); // undefined，下标为2的元素，位置被空了出来console.log(delete a); // false，通过 var 语句声明的变量不能删除function f(args)&#123;&#125; // 定义一个函数console.log(delete f); // false，通过 function 语句声明的函数不能删除 （2）void 运算符void 运算符可以应用于任何表类型的表达式，表达式会被执行，但计算结果会被忽略并返回 undefined。例如： 1234567void 0;void &quot;you are useless?&quot;;void false;void [];void /(useless)/ig;void function()&#123; console.log(&quot;you are so useless?&quot;); &#125;// always return undefined （3）typeof 运算符鉴于 JavaScript 是松散类型的，因此需要有一种手段来检测给定变量的数据类型，typeof 就是负责提供这方面信息的运算符。对一个值使用 typeof 运算符可能返回下列某个字符串： &quot;undefined&quot;，如果这个值未声明或已声明但未初始化。 &quot;boolean&quot;，如果这个值是布尔值。 &quot;string&quot;，如果这个值是字符串。 &quot;number&quot;，如果这个值是数值。 &quot;object&quot;，如果这个值是对象或 null。 &quot;function&quot;，如果这个值是函数。 下面是几个使用 typeof 运算符的例子： 1234var message = &quot;some string&quot;;console.log(typeof message); // &quot;string&quot;console.log(typeof(message)); // &quot;string&quot;console.log(typeof 95); // &quot;number&quot; 从以上例子可以看出，typeof 运算符既可以对变量使用，又可以对字面量使用。由于 typeof 是一个运算符而不是函数，因此例子中的圆括号尽管可以使用，但并不提倡。 typeof null 结果是 &quot;object&quot; 是历史遗留 Bug，在 ECMAScript 6 中，曾经有提案为历史平反, 将 typeof null 的值纠正为 &quot;null&quot;，但最后该提案被拒。理由是历史遗留代码太多，不如继续将错就错。 （4）++ -- 运算符++ -- 递增递减运算符借鉴自 C 语言，它们分前置型和后置型，作用是改变一个变量的值。例如： 12345var a = 5;console.log(a++); // 5console.log(++a); // 7console.log(a--); // 7console.log(--a); // 5 （5）+ - 运算符当 + - 作为一元运算符时，应用于数值，表示数值的正负。应用于非数值，先按 Number() 转型函数对这个值执行转换，再表示该值的正负。 （6）~ ! 运算符 ~ 按位非运算符，请参见下面「位运算符」。! 逻辑非运算符，请参见下面「逻辑运算符」。 2）乘性运算符JavaScript 定义了3个乘性运算符：乘法、除法和求模。这些运算符与 C 语言的相应运算符用途类似，只不过在操作数为非数值的情况下会执行自动的类型转换。如果参与乘法计算的某个操作数不是数值，后台会先使用 Number() 转型函数将其转换为数值。也就是说，空字符串将被当作 0，布尔值 true 将被当作 1。 （1）* 乘法运算符用于计算两个数值的乘积，在处理特殊值的情况下，乘法运算符遵循下列特殊的规则： 如果操作数都是数值，执行常规的乘法计算，即两个正数或两个负数相乘的结果还是正数，而如果只有一个操作数有符号，那么结果就是负数。如果乘积超过了 JavaScript 数值的表示范围，则返回 Infinity 或 -Infinity； 如果有一个操作数是 NaN，则结果是 NaN； 如果是 Infinity 与 0 相乘，则结果是 NaN； 如果是 Infinity 与非 0 数值相乘，则结果是 Infinity 或 -Infinity，取决于有符号操作数的符号； 如果是 Infinity 与 Infinity 相乘，则结果是 Infinity；如果有一个操作数不是数值，则在后台调用 Number()将其转换为数值，然后再应用上面的规则。 （2）/ 除法运算符用于计算两个数值的商，与乘法运算符类似，除法运算符对特殊的值也有特殊的处理规则。这些规则如下： 如果操作数都是数值，执行常规的除法计算，即两个正数或两个负数相除的结果还是正数，而如果只有一个操作数有符号，那么结果就是负数。如果商超过了 JavaScript 数值的表示范围，则返回 Infinity 或 -Infinity； 如果有一个操作数是 NaN，则结果是 NaN； 如果是 Infinity 被 Infinity 除，则结果是 NaN； 如果是零被零除，则结果是 NaN； 如果是非零的有限数被零除，则结果是 Infinity 或 -Infinity，取决于有符号操作数的符号； 如果是 Infinity 被任何非零数值除，则结果是 Infinity 或 -Infinity，取决于有符号操作数的符号； 如果有一个操作数不是数值，则在后台调用 Number() 将其转换为数值，然后再应用上面的规则。 （3）% 求模运算符用于计算两个数值的余数，与另外两个乘性运算符类似，求模运算符会遵循下列特殊规则来处理特殊的值： 如果操作数都是数值，执行常规的除法计算，返回除得的余数； 如果被除数是无穷大值而除数是有限大的数值，则结果是 NaN； 如果被除数是有限大的数值而除数是零，则结果是 NaN； 如果是 Infinity 被 Infinity 除，则结果是 NaN； 如果被除数是有限大的数值而除数是无穷大的数值，则结果是被除数； 如果被除数是零，则结果是零； 如果有一个操作数不是数值，则在后台调用 Number() 将其转换为数值，然后再应用上面的规则。 3）加性运算符加法和减法这两个加性运算符应该说是编程语言中最简单的算术运算符了。但是在 JavaScript 中，这两个运算符却都有一系列的特殊行为。与乘性运算符类似，加性运算符也会在后台转换不同的数据类型。然而，对于加性运算符而言，相应的转换规则还稍微有点复杂。 + 加法运算符如果两个运算符都是数值，执行常规的加法计算，然后根据下列规则返回结果： 如果有一个操作数是 NaN，则结果是 NaN； 如果是 Infinity 加 Infinity，则结果是 Infinity； 如果是 -Infinity 加 -Infinity，则结果是 -Infinity； 如果是 Infinity 加- Infinity，则结果是 NaN； 如果是 +0 加 +0，则结果是 +0； 如果是 -0 加 -0，则结果是 -0； 如果是 +0 加 -0，则结果是 +0; 如果有一个操作数不是数值，那么就要应用如下规则： 如果两个操作数都是字符串，则将第二个操作数与第一个操作数拼接起来； 如果只有一个操作数是字符串，则将另一个操作数转换为字符串，然后再将两个字符串拼接起来。 如果有一个操作数是对象、数值或布尔值，则调用它们的 toString() 方法取得相应的字符串值，然后再应用前面关于字符串的规则。对于 undefined 和 null，则分别调用 String() 函数并取得字符串 &quot;undefined&quot; 和 &quot;null&quot;。 如果是 null 加 null，则结果是 0; 如果是 undefined 加 undefined，则结果是 NaN; 下面来举几个例子： 12345678910var result1 = 5 + 5; // 两个数值相加console.log(result1); // 10var result2 = 5 + &quot;5&quot;; // 一个数值和一个字符串相加console.log(result2); // &quot;55&quot;var num1 = 5;var num2 = 10;var message = &quot;The sum of 5 and 10 is &quot; + num1 + num2;console.log(message); // &quot;The sum of 5 and 10 is 510&quot;，如何修改？ - 减法运算符如果两个运算符都是数值，执行常规的减法计算，然后根据下列规则返回结果： 如果有一个操作数是 NaN，则结果是 NaN； 如果是 Infinity 减 Infinity，则结果是 NaN； 如果是 -Infinity 减 -Infinity，则结果是 NaN； 如果是 Infinity 减 -Infinity，则结果是 Infinity； 如果是 -Infinity 减 Infinity，则结果是 -Infinity； 如果是 +0 减 +0，则结果是 +0； 如果是 +0 减 -0，则结果是 -0； 如果是 -0 减 -0，则结果是 +0； 如果有一个操作数不是数值，那么就要应用如下规则： 如果有一个操作数是字符串、布尔值、null 或 undefined，则先在后台调用 Number() 函数将其转换为数值，然后再根据前面的规则执行减法计算。如果转换的结果是 NaN，则减法的结果就是 NaN； 如果有一个操作数是对象，则调用对象的 valueOf() 方法以取得表示该对象的数值。如果得到的值是 NaN，则减法的结果就是 NaN。如果对象没有 valueOf() 方法，则调用其 toString()方法并将得到的字符串转换为数值。 如果是 null 减 null，则结果是 0; 如果是 undefined 减 undefined，则结果是 NaN; 下面来举几个例子： 123456var result1 = 5 - true; // 4，因为true被转换成了1var result2 = NaN - 1; // NaNvar result3 = 5 - 3; // 2var result4 = 5 - &quot;&quot;; // 5，因为&quot;&quot; 被转换成了0var result5 = 5 - &quot;2&quot;; // 3，因为&quot;2&quot;被转换成了2var result6 = 5 - null; // 5，因为null被转换成了0 4）等值运算符确定两个变量是否相等是编程中的一个非常重要的操作。在比较简单数据类型之间的相等性时，问题还比较简单。但在涉及到对象之间的比较时，问题就变得复杂了。最早的 JavaScript 中的相等和不等运算符会在执行比较之前，先将对象转换成相似的类型。后来，有人提出了这种转换到底是否合理的质疑。最后，JavaScript 的解决方案就是提供两组运算符：相等和不相等（先转换再比较），恒等和不恒等（仅比较而不转换）。 == != 运算符== != 这两个运算符都会先转换操作数（通常称为强制转型），然后再比较它们的相等性。在转换不同的数据类型时，相等和不相等运算符遵循下列基本规则： 如果有一个操作数是布尔值，则在比较相等性之前先将其转换为数值（false 转换为 0，而 true 转换为 1）； 如果一个操作数是字符串，另一个操作数是数值，在比较相等性之前先将字符串转换为数值； 如果一个操作数是对象，另一个操作数不是，则调用对象的 valueOf() 方法，用得到的基本类型值按照前面的规则进行比较； null 和 undefined 是相等的。要比较相等性之前，不能将 null 和 undefined 转换成其他任何值。 如果有一个操作数是 NaN，则相等运算符返回 false，而不相等运算符返回 true。重要提示：即使两个操作数都是 NaN，相等运算符也返回 false；因为按照规则，NaN 不等于 NaN。 如果两个操作数都是对象，则比较它们是不是同一个对象。如果两个操作数都指向同一个对象，则相等运算符返回 true；否则，返回 false。 列出了一些特殊情况及比较结果： 1234567891011null == undefined // true&quot;NaN&quot; == NaN // false5 == NaN // falseNaN == NaN // falseNaN != NaN // truefalse == 0 // truetrue == 1 // truetrue == 2 // falseundefined == 0 // falsenull == 0 // false&quot;5&quot; == 5 // true === !== 运算符除了在比较之前不转换操作数之外，恒等和不恒等运算符与相等和不相等运算符没有什么区别。它只在两个操作数未经转换就相等的情况下返回 true，如下面的例子所示： 1234var result1 = (&quot;55&quot; == 55); // true，因为转换后相等var result2 = (&quot;55&quot; === 55); // false，因为不同的数据类型不相等var result3 = (null == undefined) // true，因为它们是类似的值var result4 = (null === undefined) // false，因为它们是不同类型的值 5）关系运算符&lt; &gt; &lt;= &gt;= 运算符&lt; 小于、&gt; 大于、&lt;= 小于等于、 &gt;= 大于等于 这几个关系运算符用于对两个值进行比较返回一个布尔值。与 JavaScript 中的其他运算符一样，当关系运算符的操作数使用了非数值时，也要进行数据转换或完成某些奇怪的操作。以下就是相应的规则。 如果两个操作数都是数值，则执行数值比较。 如果两个操作数都是字符串，则比较两个字符串对应的字符编码值（可以通过字符串的 charCodeAt() 函数获取字符编码值）。 如果一个操作数是数值，则将另一个操作数转换为一个数值，然后执行数值比较。 如果一个操作数是对象，则调用这个对象的 valueOf() 方法，用得到的结果按照前面的规则执行比较。如果对象没有 valueOf()方法，则调用 toString()方法，并用得到的结果根据前面的规则执行比较。 如果一个操作数是布尔值，则先将其转换为数值，然后再执行比较。 请思考下面几个例子的结果是如何得出的： 1234567var result1 = &quot;Brick&quot; &lt; &quot;alphabet&quot;; // truevar result2 = &quot;brick&quot; &lt; &quot;alphabet&quot;; // falsevar result3 = &quot;23&quot; &lt; &quot;3&quot;; // truevar result4 = &quot;23&quot; &lt; 3; // falsevar result5 = &quot;a&quot; &lt; 3; // falsevar result6 = NaN &lt; 3; // falsevar result7 = NaN &gt;= 3; // false in 运算符in 运算符希望它的左操作数是一个字符串或可以转换为字符串，希望它的右操作数是一个对象。如果右侧的对象拥有一个名为左操作数值的属性名，那么表达式返回 true，例如： 123456789var point = &#123; x:1, y:1 &#125;; // 定义一个对象&quot;x&quot; in point // true，对象有一个名为&quot;x&quot;的属性&quot;z&quot; in point // false，对象中不存在名为&quot;z&quot;的属性&quot;toString&quot; in point // true，对象继承了toString()方法var data = [7,8,9]; // 拥有三个元素的数组&quot;0&quot; in data // true，数组包含元素&quot;0&quot;1 in data // true，数字转换为字符串3 in data // false，没有索引为3的元素 instanceof 运算符instanceof 运算符希望左操作数是一个对象，右操作数标识对象的类。如果左侧的对象是右侧类的实例，则表达式返回 true；否则返回 false。后面会讲 JavaScript 中对象的类是通过初始化它们的构造函数来定义的。这样的话，instanceof 的右操作数应当是一个函数。比如： 123456789var d = new Date(); // 通过 Date() 构造函数来创建一个新对象d instanceof Date; // true，d 是由 Date() 创建的d instanceof Object; // true，所有的对象都是 Object 的实例d instanceof Number; // false，d 不是一个 Number 对象var a = [1, 2, 3]; // 通过数组字面量的写法创建一个数组a instanceof Array; // true，a 是一个数组a instanceof Object; // true，所有的数组都是对象a instanceof RegExp; // false，数组不是正则表达式 需要注意的是，所有的对象都是 Object 的实例。当通过 instanceof 判断一个对象是否是一个类的实例的时候，这个判断也会包含对「父类」的检测。如果 instanceof 的左操作数不是对象的话，instanceof 返回 false。如果右操作数不是函数，则抛出一个类型错误异常。 6）逻辑运算符逻辑运算符是对操作数进行布尔算术运算，经常和关系运算符一起配合使用，逻辑运算符将多个关系表达式组合起来组成一个更复杂的表达式。 &amp;&amp; 逻辑与逻辑与操作可以应用于任何类型的操作数，而不仅仅是布尔值。在有一个操作数不是布尔值的情况下，逻辑与操作不一定返回布尔值；此时，它遵循下列规则： 如果第一个操作数是对象，则返回第二个操作数； 如果第二个操作数是对象，则只有在第一个操作数的求值结果为 true 的情况下才会返回该对象； 如果两个操作数都是对象，则返回第二个操作数； 如果有一个操作数是 null，则返回 null； 如果有一个操作数是 NaN，则返回 NaN； 如果有一个操作数是 undefined，则返回 undefined。 逻辑与操作属于短路操作，即如果第一个操作数能够决定结果，那么就不会再对第二个操作数求值。对于逻辑与操作而言，如果第一个操作数是 false，无论第二个操作数是什么值，结果都不再可能是 true 了。 12console.log(3 &gt; 5 &amp;&amp; 3 &gt; 2); // falseconsole.log(3 &lt; 5 &amp;&amp; 3 &gt; 2); // true || 逻辑或与逻辑与操作相似，如果有一个操作数不是布尔值，逻辑或也不一定返回布尔值；此时，它遵循下列规则： 如果第一个操作数是对象，则返回第一个操作数； 如果第一个操作数的求值结果为 false，则返回第二个操作数； 如果两个操作数都是对象，则返回第一个操作数； 如果两个操作数都是 null，则返回 null； 如果两个操作数都是 NaN，则返回 NaN； 如果两个操作数都是 undefined，则返回 undefined。 与逻辑与运算符相似，逻辑或运算符也是短路运算符。也就是说，如果第一个操作数的求值结果为 true，就不会对第二个操作数求值了。 12console.log(3 &gt; 5 || 3 &gt; 2); // true console.log(3 &gt; 5 || 3 &lt; 2); // false ! 逻辑非逻辑非操作可以应用于任何类型的操作数，无论这个值是什么数据类型，这个运算符都会返回一个布尔值。逻辑非运算符首先会将它的操作数转换为一个布尔值，然后再对其求反。逻辑非运算符遵循下列规则： 如果操作数是一个对象，返回 false； 如果操作数是一个空字符串，返回 true； 如果操作数是一个非空字符串，返回 false； 如果操作数是数值 0，返回 true； 如果操作数是任意非 0 数值（包括 Infinity），返回 false； 如果操作数是 null，返回 true； 如果操作数是 NaN，返回 true； 如果操作数是 undefined，返回 true。 下面几个例子展示了应用上述规则的结果： 123456console.log(!false); // trueconsole.log(!&quot;blue&quot;); // falseconsole.log(!0); // trueconsole.log(!NaN); // trueconsole.log(!&quot;&quot;); // trueconsole.log(!12345); // false 逻辑非运算符也可以用于将一个值转换为与其对应的布尔值。而同时使用两个逻辑非运算符，实际上就会模拟 Boolean() 转型函数的行为。其中，第一个逻辑非操作会基于无论什么操作数返回一个布尔值，而第二个逻辑非操作则对该布尔值求反，于是就得到了这个值真正对应的布尔值。当然，最终结果与对这个值使用 Boolean() 函数相同，例如： 12345console.log(!!&quot;blue&quot;); //trueconsole.log(!!0); //falseconsole.log(!!NaN); //falseconsole.log(!!&quot;&quot;); //falseconsole.log(!!12345); //true 7）位运算符在 JavaScript 中，当对数值应用位运算符时，后台会发生如下转换过程：64位的数值被转换成32位数值，然后执行位操作，最后再将32位的结果转换回64位数值。这个转换过程导致了一个严重的副效应，即在对特殊的 NaN 和 Infinity 值应用位操作时，这两个值都会被当成 0 来处理。如果对非数值应用位运算符，会先使用 Number() 函数将该值转换为一个数值，然后再应用位操作，得到的结果将是一个数值。 ~ 按位非简单的理解，对任一数值 x 进行按位非操作的结果为 -(x+1)。例如： 1234567891011console.log(~null); // -1console.log(~undefined); // -1console.log(~0); // -1console.log(~&#123;&#125;); // -1console.log(~[]); // -1console.log(~(1/0)); // -1console.log(~false); // -1console.log(~true); // -2console.log(~1.2543); // -2console.log(~4.9); // -5console.log(~(-2.999)); // 1 &amp; 按位与按位与操作就是将两个数值的每一位对齐，两个数值的对应位都是 1 时才返回 1，任何一位是 0，结果都是 0。如下表所示： 第一个数值的位 第二个数值的位 结果 1 1 1 1 0 0 0 1 0 0 0 0 | 按位或按位或操作就是将两个数值的每一位对齐，两个数值只要有一个位是 1 就返回 1，只在两个位都是 0 的情况下才返回 0。如下表所示： 第一个数值的位 第二个数值的位 结果 1 1 1 1 0 1 0 1 1 0 0 0 ^ 按位异或按位异或与按位或的不同之处在于，两个数值只有一个 1 时才返回 1，如果对应的两位都是 1 或都是 0，则返回 0。 第一个数值的位 第二个数值的位 结果 1 1 0 1 0 1 0 1 1 0 0 0 &lt;&lt; 左移这个运算符会将数值的所有位向左移动指定的位数。例如： 12var oldValue = 2; // 等于二进制的 10var newValue = oldValue &lt;&lt; 5; // 等于二进制的 1000000，十进制的 64 注意，左移不会影响操作数的符号位。换句话说，如果将 -2 向左移动 5 位，结果将是 -64，而非 64。 &gt;&gt; 有符号的右移这个运算符会将数值向右移动，但保留符号位（即正负号标记）。 12var oldValue = 64; // 等于二进制的 1000000var newValue = oldValue &gt;&gt; 5; // 等于二进制的 10 ，即十进制的 2 &gt;&gt;&gt; 无符号的右移这个运算符会将数值的所有32位都向右移动。对正数来说，无符号右移的结果与有符号右移相同。 12var oldValue = 64; // 等于二进制的 1000000var newValue = oldValue &gt;&gt;&gt; 5; // 等于二进制的 10 ，即十进制的 2 无符号右移运算符会把负数的二进制码当成正数的二进制码。而且，由于负数以其绝对值的二进制补码形式表示，因此就会导致无符号右移后的结果非常之大。 12var oldValue = -64; // 等于二进制的 11111111111111111111111111000000var newValue = oldValue &gt;&gt;&gt; 5; // 等于十进制的 134217726 8）赋值运算符简单的赋值运算符由等于号 = 表示，其作用就是把右侧的值赋给左侧的变量，如下面的例子所示： 1var num = 10; 如果在等于号 = 前面再添加乘性运算符、加性运算符或位运算符，就可以完成复合赋值操作。这种复合赋值操作相当于是对下面常规表达式的简写形式： 12var num = 10;num += 10; // 等同于 num = num + 10; 每个主要算术运算符（以及个别的其他运算符）都有对应的复合赋值运算符。这些运算符如下所示： 乘&#x2F;赋值 *=； 除&#x2F;赋值 /=； 模&#x2F;赋值 %=； 加&#x2F;赋值 +=； 减&#x2F;赋值 -=； 左移&#x2F;赋值 &lt;&lt;=； 有符号右移&#x2F;赋值 &gt;&gt;=； 无符号右移&#x2F;赋值 &gt;&gt;&gt;=。 设计这些运算符的主要目的就是简化赋值操作，使用它们不会带来任何性能的提升。 9）条件运算符? : 条件运算符应该算是 JavaScript 中最灵活的一种运算符了，而且它遵循与 Java 中的条件运算符相同的语法形式，如下面的例子所示： 1variable = boolean_expression ? true_value : false_value; 10）逗号运算符逗号运算符多用于声明多个变量；但除此之外，逗号运算符还可以用于赋值。在用于赋值时，逗号运算符总会返回表达式中的最后一项，如下面的例子所示： 1var num = (5, 1, 4, 8, 0); // num 的值为 0 由于 0 是表达式中的最后一项，因此 num 的值就是 0。虽然逗号的这种使用方式并不常见，但这个例子可以帮我们理解逗号的这种行为。","categories":[{"name":"javascript","slug":"javascript","permalink":"http://example.com/categories/javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://example.com/tags/javascript/"}]},{"title":"javascript类型、值和变量","slug":"javascript类型、值和变量","date":"2017-04-23T00:08:27.000Z","updated":"2022-05-26T11:38:09.427Z","comments":true,"path":"2017/04/23/javascript类型、值和变量/","link":"","permalink":"http://example.com/2017/04/23/javascript%E7%B1%BB%E5%9E%8B%E3%80%81%E5%80%BC%E5%92%8C%E5%8F%98%E9%87%8F/","excerpt":"","text":"类型、值和变量JavaScript类型可以分为两类：原始类型和对象类型。 原始类型包括数值、字符串、布尔值、特殊值null、undefined。其中null和undefined不是数值、字符串或布尔值，通常被认为 是各自特殊类型的唯一成员。 对象是属性的集合，其中每个属性都有一个名字和一个值。 注意：任何不是数值、字符串、布尔值、符号、null和undefined的值都是对象。 在内存管理方面，js解析器会执行自动垃圾收集。当程序无法以任何方式引用这个值时，解释器会自动释放它占用的内存。 1）数值 整数 Number用于表示整数和近似实数。 Number 类型是 JavaScript 中最令人关注的数据类型，这种类型使用 IEEE 754 格式来表示整数和浮点数值（浮点数值在某些语言中也被称为双精度数值）。和其他编程语言不同，JavaScript 中的所有数字均用浮点数值表示。 在 JavaScript 中进行算术计算时，所有以八进制和十六进制表示的数值最终都将被转换成十进制数值。例如： 1234567var a = 10; // 十进制var b = 023; // 八进制var c = 0x12ac; // 十六进制0xff = 255；（15*16+15） // 十六进制0xbadcafe // =&gt;195939070 // 十六进制console.log(b); // 19console.log(c); // 4780 八进制第一位必须是0，后面跟八进制序列0到7，如果超出了范围，则忽略前导0，后面的数值当做十进制解析，例如：089会被解析为89。（八进制字面量在严格模式下是无效的，会抛出错误。） 十六进制前两位必须是 0x 或 0X，后跟十六进制序列09、af（10~15）（不区分大小写），如果超出了范围，则会报语法错误。 浮点数 所谓浮点数值，就是该数值中必须包含一个小数点，并且小数点后面必须至少有一位数字。虽然小数点前面可以没有整数，但我们不推荐这种写法。例如： 123var a = 1.1;var b = 0.1;var c = .1; // 有效，但不推荐 JavaScript 会不失时机的将浮点数转换成整数。例如： 12var a = 5.; // 解析成整数5var b = 5.0; // 解析成整数5 对于极大或者极小的数值，可采用科学技术法（也称e表示法）。JavaScript 会将那些小数点后面带有6个零以上的小于1的浮点数值转换为以e表示法表示的数值。例如： 123var a = 3.14e7; // 等于31400000var b = 3.14E-7; // 等于0.000000314console.log(0.0000003); // 3e-7 浮点数值的最高精度是17位小数，但在进行算术计算时其精确度远远不如整数，例如： 1console.log(0.1 + 0.2); // 0.30000000000000004 这个舍入误差会导致无法测试特定的浮点数值，因此，永远不要测试某个特定的浮点数值。 Js使用的IEEE~754浮点法是一种二进制表示法，这种表示法可以精确地表示如1&#x2F;2,1&#x2F;8,1&#x2F;1024等分数。然而我们常用的十进制 分数：1&#x2F;10,1&#x2F;100等等，二进制浮点表示法无法精确表示。 123456例如：let x = .3 - .2 ;//这个数值只能非常近似地表示0.1，但无法精确的表示。let y = .2 - .1;x ===y; ==&gt;falsex ===.1; ==&gt;falsey ===.1; ==&gt;true 正无穷、负无穷 由于内存限制，JavaScript 能表示的数值范围从 Number.MIN_VALUE 到 Number.MAX_VALUE，并将超出范围的数转换成 Number.POSITIVE_INFINITY 或 Number.NEGATIVE_INFINITY。0作为除数是不会报错的，正数除以0返回正无穷，负数除以0返回负无穷，0除以0返回NaN。例如： 123456789console.log(Number.MAX_VALUE); // 最大数 1.7976931348623157e+308console.log(Number.MIN_VALUE); // 最小数 5e-324console.log(Number.POSITIVE_INFINITY); // 正无穷 Infinityconsole.log(Number.NEGATIVE_INFINITY); // 负无穷 -Infinityconsole.log( 1 / 0); // Infinityconsole.log(-1 / 0); // -Infinity JavaScript 提供了 isFinite() 函数，来确定一个数是不是有穷的。例如： 12console.log(isFinite(100)); // trueconsole.log(isFinite(Infinity)); // false NaN NaN（not a number），是一个特殊的数值。之所以称它为「非数值」，是因为它不能参与算数运算，任何涉及 NaN 的操作都返回 NaN。并且 NaN 与任何值都不相等（包括自身）。例如： 12345678console.log(typeof NaN); // &quot;number&quot;console.log(0 / 0); // NaNconsole.log(NaN - NaN); // NaNconsole.log(Infinity - Infinity); // NaNvar a = NaN;console.log(a === a); // false JavaScript 提供了 isNaN() 函数，来确定一个数是不是 NaN。例如： 12345console.log(isNaN(100)); // falseconsole.log(isNaN(&quot;100&quot;)); // falseconsole.log(isNaN(true)); // falseconsole.log(isNaN(&quot;sss&quot;)); // trueconsole.log(isNaN(NaN)); // true Number()、parseInt()、parseFloat()转型函数 isNaN() 函数在接收到一个值之后，会尝试使用转型函数 Number() 将这个值转换为数值，转换规则如下： undefined 转换为 NaN； null 转换为 0； true 转换为 1、false 转换为 0； number 整数转换为十进制，小数不变； string 如果只包含十进制数和小数，则返回对应的数值，如果只包含八进制数，则忽略前导0返回剩余部分，如果只包含十六进制，则返回十进制数，空字符串转换为0，其它字符串转换为 NaN； 如果 object 具有 valueOf() 方法，且返回一个原始值（5种简单数据类型），则将这个原始值转换为数字，并返回这个数字；否则，如果 object 具有 toString() 方法，且返回一个原始值，则将这个原始值转换为数字，并返回这个数字；否则，抛出一个类型错误异常。 由于 Number() 转型函数在转换字符串时不够理想，因此还有两个专门用来转换字符串的函数 parseInt() 和 parseFloat() 函数。 parseInt() 函数会忽略字符串前面的空格，直至找到第一个非空格字符，只要第一个非空格字符不是数字或者正负号，一律返回 NaN， 如果第一个非空格字符是数字字符，parseInt() 会继续解析第二个字符，直到解析完所有后续字符或者遇到了一个非数字字符。例如： 123console.log(parseInt(&quot;&quot;)); // NaN（Number(&quot;&quot;)返回 0）console.log(parseInt(&quot;123S&quot;)); // 123console.log(parseInt(&quot;12.4&quot;)); // 12 parseFloat() 函数也会忽略字符串前面的空格，直至找到第一个非空格字符，只要第一个非空格字符不是数字或者正负号或者小数点，一律返回 NaN， 如果第一个非空格字符是上述字符之一，parseFloat() 会继续解析第二个字符，直到解析完所有后续字符或者遇到了一个非浮点数值。例如： 12console.log(parseFloat(&quot;098.2&quot;)); // 98.2console.log(parseFloat(&quot;123.23.23&quot;)); // 123.23 2）字符串字符串是16位值的不可修改的有序序列，其中每个值都表示一个Unicode字符。 在Js中可以使用单引号、双引号或者反引号(‘ ‘ ,” “,&#96;&#96;)包含起来来表示字符串，双引号和反引号可以出现在由单引号定界的字符 串中，同理由双引号和反引号定界的字符串里也可以包含另外两种引号。 12345&quot; &quot; //空字符串&#x27;testing&#x27;&quot;3.14&quot;&quot;Wouldn&#x27;t you prefer o&#x27;Reilly&#x27;s Books&quot;`&quot;she said &#x27;hi&#x27;&quot;,he said` 转义序列 12345678910\\0 Null字符\\b 退格符\\t 水平制表符\\n 换行符\\f 进制符\\r 回车符\\&quot; 双引号\\&#x27; 单引号\\\\ 反斜杠\\xnn 由2位16进制数字nn指定的Unicode字符 转义字符可出现在字符串中的任意位置，且长度为1。如要在字符串中显示 \\ ，则必须使用 \\ 进行转义。例如： 12console.log(&quot;\\n\\\\&quot;.length); // 2console.log(&quot;\\\\hello&quot;); // &quot;\\hello&quot;（长度为6） 大部分值都可以使用继承而来的 toString()方法转换为字符串，但 undefined 和 null 值没有这个方法。对数值使用 toString() 方法时，可以传入一个数字基数，以此输出对应进制的字符串值。例如： 1234567console.log(true.toString()); // &quot;true&quot;var num = 10;console.log(num.toString()); // &quot;10&quot;console.log(num.toString(2)); // &quot;1010&quot;console.log(num.toString(8)); // &quot;12&quot;console.log(num.toString(16)); // &quot;a&quot; 在不知道要转换的值是不是 undefined 或 null 的情况下，还可以使用转型函数 String()，这个函数能够将任何类型的值转换为字符串。String() 函数遵循下列转换规则： 如果值有 toString() 方法，则调用该方法（没有参数）并返回相应的结果； 如果值是 undefined，则返回 &quot;undefined&quot;； 如果值是 null，则返回 &quot;null&quot;。 12345var value;console.log(String(10)); // &quot;10&quot;console.log(String(true)); // &quot;true&quot;console.log(String(null)); // &quot;null&quot;console.log(String(value)); // &quot;undefined&quot; 3）布尔值Boolean 类型是 JavaScript 中使用得最多的一种类型，该类型只有两个字面值：true 和 false。需要注意的是，他们是区分大小写的，也就是说 True 和 False（以及其他的混合大小写形式）都不是 Boolean 值，只是标识符。 虽然 Boolean 类型的字面值只有两个，但 JavaScript 中所有类型的值都能使用 if 语句或 Boolean() 函数转换为对应的 Boolean 值，例如： 123456var message = &quot;Hello world!&quot;;if (message)&#123; console.log(&quot;Value is true.&quot;); // 被执行&#125;var messageAsBoolean = Boolean(message);console.log(messageAsBoolean); // true 下表给出了各种数据类型及其对应的转换规则。 数据类型 转换为true的值 转换为false的值 Undefined - undefined Null - null Boolean true false String 任何非空字符串 “”（空字符串） Number 任何非零数字值（包括无穷大） 0和NaN Object 任何对象 - 4）null和undefinedUndefined 类型只有1个值，即 undefined。使用 var 声明变量但未对其加以初始化时，这个变量的值就是 undefined，直接使用未声明的变量会产生错误。对未声明或已声明但未初始化的变量执行 typeof 运算符会返回 &quot;undefined&quot; 值，例如： 1234567var message; // 这个变量声明之后默认取得了 undefined 值// var age // 这个变量并没有声明console.log(message); // &quot;undefined&quot;console.log(age); // 产生错误console.log(typeof message); // &quot;undefined&quot;console.log(typeof age); // &quot;undefined&quot; Null 类型也只有1个值，即 null。它用来表示值的空缺。你可以认为 undefined 是表示系统级的、出乎意料的或类似错误的值的空缺，而 null 是表示程序级的、正常的或在意料之中的值的空缺。在下列场景中应当使用 null。 用来初始化一个变量，这个变量可能赋值为一个对象。 用来和一个已经初始化的变量比较，这个变量可以是也可以不是一个对象。 当函数的参数期望是对象时，作用参数传入。 当函数的返回值期望是对象时，作用返回值传出。 在下列场景中不应当使用 null。 不要使用 null 来检测是否传入了某个参数。 不要使用 null 来检测一个未初始化的变量。 5）全局对象全局对象的属性是全局性定义的标识符，可以在js程序的任何地方使用。js解释器启动后都会创建一个新的全局对象并为其添加一组初始的属性。 6）对象和数组JavaScript 中所有对象都继承自 Object 类型，每个对象都具有下列基本的属性和方法： constructor：保存着用于创建当前对象的函数（构造函数）。 hasOwnProperty()：用于检查给定的属性在当前对象实例中是否存在。 propertyIsEnumerable()：用于检查给定的属性是否能够使用for-in语句来枚举。 isPrototypeOf()：用于检查对象是否是传入对象的原型。 toString() 方法：返回对象的字符串表示。 toLocaleString()：返回对象的本地字符串表示。 valueOf()：返回对象的字符串、数值或布尔值表示（通常与toString()方法的返回值相同）。 Object 本质上是由一组无序的名值对组成，「名称」部分是一个 JavaScript 字符串，「值」部分可以是任何 JavaScript 的数据类型（包括对象和方法）。这使用户可以根据具体需求，创建出相当复杂的数据结构。 以下两种方法都可以创建一个空对象，这两种方法在语义上是相同的。第二种更方便的方法叫作「对象字面量」法。这也是 JSON 格式的核心语法，一般我们优先选择第二种方法。例如： 12var obj = new Object();var obj = &#123;&#125;; // 好的写法 「对象字面量」也可以用来在对象实例中定义一个对象： 12345678var obj = &#123; name: &quot;Carrot&quot;, &quot;for&quot;: &quot;Max&quot;, details: &#123; color: &quot;orange&quot;, size: 12 &#125;&#125; 对象的属性可以通过链式（chain）表示方法进行访问： 12obj.details.color; // orangeobj[&quot;details&quot;][&quot;size&quot;]; // 12 完成创建后，对象属性可以通过如下两种方式进行赋值和访问： 12345obj.name = &quot;Simon&quot; // 赋值var name = obj.name; // 访问obj[&quot;name&quot;] = &quot;Simon&quot;; // 赋值var name = obj[&quot;name&quot;]; // 访问 对象不同于原始值，对象是可修改的，即他们的值可以改变； 123456let object = &#123; x:1&#125;对象的属性访问：object.xlet arr = [1,2,3]数组的访问：arr[0] 对象不是按值比较的，两个不同的对象即使拥有完全相同的属性和值，它们也不相等。同样，两个不同的数组，即使每个元 素都相同，顺序也相同，它们也不相等。 1234let o = &#123;x:1&#125;,p = &#123;x:1&#125;o===p =&gt;falselet a = [],b = [];a===b =&gt;false 对象被称作引用类型，以区别于js的原始类型。对象值就是引用，对象是按引用比较的。两个对象值当且仅当它们引用同一个 底层对象时，才是相等的。 7）变量声明与赋值变量是通过var或let关键字声明的 1234let i;let sum;var i ;var sum; 也可以使用一条var&#x2F;let语句声明多个变量； 12let i,sum;var i,sum; 声明变量的同时也为其赋值是一个好的编程习惯； 12let msg = &quot;Hello World&quot;;let i = 0;j = 0;k = 0; 如果在var&#x2F;let语句中不为变量指定初始值，变量也会被声明，但在赋值之前它的值是undefined。 const是用来声明常量的，常量在声明是必须初始化且值不能改变，尝试给常量重新赋值会抛出TypeError 12const H0 = 74;const C = 299792.458 变量的作用域是程序源代码中的一个区域，在这个区域内变量有定义。通过let和const声明的变量和常量具有块作用域。这意味着它们只在let和const语句所在的代码块中有定义。 1234console.log(i);//抛出错误if(true)&#123; let i = 0;&#125; 在同一个作用域中使用多个let或const声明同一个名字是语法错误。在嵌套作用域中声明同名变量是合法的（最好不要这么做） 1234567const x = 1;if(x === 1)&#123; let x = 2; console.log(2)//打印2&#125;console.log(x);//打印1，回到全局作用域let x = 3;//报错 使用var和let声明的区别： 使用var声明的变量不具有块作用域，这种变量的作用域仅限于包含函数的函数体，无论它们在函数中嵌套的层次有多深。 如果在函数体外使用var声明，会声明一个全局变量。通过var声明的全局变量可以通过globalThis引用，因此，如果在函数外部写了var x &#x3D;2,则相当于globalThis.x &#x3D; 2; 使用var多次声明同名变量是合法的。 var声明变量的特性是作用域提升。在使用var声明变量时，该声明会被提高到包含函数的顶部。但变量的初始化仍然在代码所在位置完成，只有变量的定义转移到了函数顶部。","categories":[{"name":"javascript","slug":"javascript","permalink":"http://example.com/categories/javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://example.com/tags/javascript/"}]},{"title":"javascript词法结构","slug":"javascript词法结构","date":"2017-04-22T13:22:48.000Z","updated":"2022-05-31T02:40:15.175Z","comments":true,"path":"2017/04/22/javascript词法结构/","link":"","permalink":"http://example.com/2017/04/22/javascript%E8%AF%8D%E6%B3%95%E7%BB%93%E6%9E%84/","excerpt":"","text":"JavaScript简介​ js是一种专门为网页交互设计的客户端（浏览器端）的脚本语言； ​ js与html和css有相似之处，都在浏览器端解析； ​ js和java,c#,php等一样，是一门真正的编程语言 ​ javaScript简称js JavaScript组成部分 ​ ECMAScript:js的基础，主要规定了一些js的语法规范 ​ BOM：浏览器对象模型：提供了访问浏览器的一些接口； ​ DOM：文档对象模型：提供访问页面的接口； 词法结构区分大小写JavaScript 是区分大小写的。也就是说，关键字、变量、函数名和所有的标识符（identifier）都必须采取一致的大小写形式。 比如，关键字 while 必须写成 while，而不能写成 While 或者 WHILE。同样，online、Online、OnLine、ONLINE 是4个不同的 变量名。 但需要注意的是，HTML 并不区分大小写。由于它和客户端 JavaScript 联系紧密，因此这点区别很容易混淆。许多客户端 JavaScript 对象和属性与他们所表示的 HTML 标签和属性名相同。在 HTML 中，这些标签和属性名可以使用大写也可以是小 写，而在 JavaScript 中则必须是小写。例如，在 HTML 中设置事件处理程序时，onclick 属性可以写成 onClick，但在 JavaScript 代码中，必须使用小写的 onclick。 1234var userName = &#x27;张三&#x27;;var username = &#x27;李四&#x27;;console.log(userName);console.log(username) 注释JavaScript 使用 C 风格的注释，包括单行注释和块级注释。单行注释以两个斜杠 // 开头，块级注释以一个斜杠和一个星号 /* 开头，以一个星号和一个斜杠 */ 结尾。下面都是合法的 JavaScript 注释： 12345// 这是单行注释/*** * 这是多行注释 * 这是多行注释***/ 虽然上面注释中的第二和第三行都以一个星号开头，但这不是必须的，纯粹是为了提高注释的可读性 字面量所谓字面量（也可称直接量，Literal values），就是程序中直接使用的数据值。字面量只代表自身，不存储在特定位置。 JavaScript 中的字面量有：字符串、数字、布尔值、对象、数组、函数、正则表达式，以及特殊的 null 值。 12345678910&quot;hello world&quot; // 字符串123 // 数字1.2 // 小数true // 布尔值false // 布尔值/javascript/gi // 正则表达式null // 空&#123; name: &#x27;stone&#x27;, age: 20&#125; // 对象[ 1, 2, 3, 4, 5, 6, 7, 8 ] // 数组function()&#123; console.log(&#x27;good&#x27;); &#125; // 函数 标识符标识符用于在js代码中命名常量，变量，属性，函数和类，以及某些循环提供标记。 标识符命名规则 由数字、字母、下划线或$（美元符）组成； 不能以数字开头；并且区分大小写； 不能用关键字，保留字命名； 1234567//正确的命名方式my_name;_username;$str//错误的命名方式.myname1user 关键字和保留字ECMAScript 3 描述了一组具有特定用途的关键字，这些关键字可用于表示控制语句的开始或结束，或者用于执行特定操作 等。按照规则，关键字是语言保留的，不能用作标识符。以下是 ECMAScript 3 的全部关键字： 123456break delete function return typeofcase do if switch varcatch else in this voidcontinue false instanceof throw whiledebugger finally new true withdefault for null try ECMAScript 3 还将 Java 的所有关键字都作为自己的保留字，保留字也是不能当初标识符。尽管保留字还没有任何特定的用途，但他们有可能在将来被用作关键字： 123456abstract double goto native staticboolean enum implements package superbyte export import private synchronizedchar extends int protected throwsclass final interface public transientconst float long short volatile ECMAScript 5 把非严格模式下的保留字缩减为： 12class enum extends superconst export import ECMAScript 5 在严格模式下的保留字为： 123implements package publicinterface private staticlet protected yield 注意，let 和 yield 是 ECMAScript 5 新增的保留字，其他保留字都是 ECMAScript 3 定义的。为了保证兼容性，任何时候都不建议使用 ECMAScript 5 新增的保留字 let 和 yield 。 ECMAScript 还预定义了很多全局变量和函数，也应当避免把它们用作标识符： 12345678arguments Error Math RegExpArray eval NaN StringBoolean EvalError Number SyntaxErrorDate Function Object TypeErrordecodeURI Infinity parseFloat undefineddecodeURIComponent isFinite parseInt URIErrorencodeURI isNaN RangeErrorencodeURIComponent JSON ReferenceError JavaScript 的具体实现可能定义独有的全局变量和函数，每一种特定的 JavaScript 运行环境都有自己的一个全局属性列表，这一点是需要牢记的。 可选的分号js使用分号(;)分割语句，这对于保持代码的清晰很重要：如果没有分隔符，一条语句的结尾可能是另一条语句的开头。 js中如果两条语句分别写在两行，通常可以省略它们之间的分号。 123例如：var a = 4;var b = 3; 像这种方式可以省略分号。 如果是下面这种情况，必须加分号 1var a = 4;b = 3; 严格模式在 ECMAScript 5 引入了严格模式（strict mode）的概念。严格模式是为 JavaScript 定义了一种不同的解析与执行模式。在严格模式下，ECMAScript 3 中的一些不确定的行为将得到处理，而且对某些不安全的操作也会抛出错误。要在整个脚本中启用严格模式，可以在顶部添加如下代码： 1&quot;use strict&quot;; 这行代码看起来像是字符串，而且也没有赋值给任何变量，但其实它是一个编译指示（pragma），用于告诉支持的 JavaScript 引擎切换到严格模式。这是为了不破坏 ECMAScript 3 语法而特意选定的语法。 在函数内部的第一行包含这条编译指示，也可以指定函数在严格模式下执行： 1234function doSomething()&#123; &quot;use strict&quot;; // 函数体&#125;","categories":[{"name":"javascript","slug":"javascript","permalink":"http://example.com/categories/javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://example.com/tags/javascript/"}]}],"categories":[{"name":"python","slug":"python","permalink":"http://example.com/categories/python/"},{"name":"vue","slug":"vue","permalink":"http://example.com/categories/vue/"},{"name":"ES6","slug":"ES6","permalink":"http://example.com/categories/ES6/"},{"name":"javascript","slug":"javascript","permalink":"http://example.com/categories/javascript/"},{"name":"AJAX","slug":"AJAX","permalink":"http://example.com/categories/AJAX/"},{"name":"css","slug":"css","permalink":"http://example.com/categories/css/"},{"name":"BOM","slug":"BOM","permalink":"http://example.com/categories/BOM/"},{"name":"DOM","slug":"DOM","permalink":"http://example.com/categories/DOM/"}],"tags":[{"name":"python","slug":"python","permalink":"http://example.com/tags/python/"},{"name":"vue","slug":"vue","permalink":"http://example.com/tags/vue/"},{"name":"ES6","slug":"ES6","permalink":"http://example.com/tags/ES6/"},{"name":"javascript","slug":"javascript","permalink":"http://example.com/tags/javascript/"},{"name":"AJAX","slug":"AJAX","permalink":"http://example.com/tags/AJAX/"},{"name":"css","slug":"css","permalink":"http://example.com/tags/css/"},{"name":"BOM","slug":"BOM","permalink":"http://example.com/tags/BOM/"},{"name":"DOM","slug":"DOM","permalink":"http://example.com/tags/DOM/"}]}