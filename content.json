{"meta":{"title":"Hexo","subtitle":"","description":"","author":"John Doe","url":"http://example.com","root":"/"},"pages":[],"posts":[{"title":"Hello World","slug":"hello-world","date":"2022-05-25T03:25:34.642Z","updated":"2022-05-25T03:25:34.642Z","comments":true,"path":"2022/05/25/hello-world/","link":"","permalink":"http://example.com/2022/05/25/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]},{"title":"vue响应式原理","slug":"vue响应式原理","date":"2019-05-25T09:28:36.000Z","updated":"2022-05-25T11:11:58.547Z","comments":true,"path":"2019/05/25/vue响应式原理/","link":"","permalink":"http://example.com/2019/05/25/vue%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8E%9F%E7%90%86/","excerpt":"","text":"数据驱动 数据响应式、双向绑定、数据驱动 数据响应式 数据模型仅仅是普通的 JavaScript 对象，而当我们修改数据时，视图会进行更新，避免了繁琐的 DOM 操作提高开发效率 双向绑定 数据改变，视图改变;视图改变，数据也随之改变 我们可以使用 v-model 在表单元素上创建双向数据绑定 数据驱动是Vue最独特的特性之一，MVVM表示的是Model-View-ViewModel 开发过程中仅需要关注数据本身，不需要关心数据是如何渲染到视图 Model：模型层，负责处理业务逻辑以及和服务器端进行交互 View：视图层：负责将数据模型转化为UI展示出来，可以简单的理解为HTML页面 ViewModel：视图模型层，用来连接Model和View，是Model和View之间的通信桥梁 数据响应式的核心原理Vue 2.x 核心是通过 ES5 的保护对象的 Object.defindeProperty 中的访问器属性中的 get 和 set 方法，data 中声明的属性都被添加了访问器属性，当读取 data 中的数据时自动调用 get 方法，当修改 data 中的数据时，自动调用 set 方法，检测到数据的变化，会通知观察者 Wacher，观察者 Wacher自动触发重新render 当前组件（子组件不会重新渲染）,生成新的虚拟 DOM 树，Vue 框架会遍历并对比新虚拟 DOM 树和旧虚拟 DOM 树中每个节点的差别，并记录下来，最后，加载操作，将所有记录的不同点，局部修改到真实 DOM树上 总结：Vue 采用数据劫持结合发布—订阅模式的方法，通过 Object.defineProperty() 来劫持各个属性的 setter，getter，在数据变动时发布消息给订阅者，触发相应的监听回调 Object.defineProperty()，那么它的用法是什么，以及优缺点是什么呢？ 可以检测对象中数据发生的修改 对于复杂的对象，层级很深的话，是不友好的，需要经行深度监听，这样子就需要递归到底，这也是它的缺点。 对于一个对象中，如果你新增加属性，删除属性，Object.defineProperty()是不能观测到的，那么应该如何解决呢？可以通过Vue.set()和Vue.delete()来实现。 1234567891011121314151617181920212223242526272829303132// 模拟 Vue 中的 data 选项 let data = &#123; msg: &#x27;hello&#x27;&#125;// 模拟 Vue 的实例 let vm = &#123;&#125;// 数据劫持:当访问或者设置 vm 中的成员的时候，做一些干预操作Object.defineProperty(vm, &#x27;msg&#x27;, &#123; // 可枚举(可遍历) enumerable: true, // 可配置(可以使用 delete 删除，可以通过 defineProperty 重新定义) configurable: true, // 当获取值的时候执行 get () &#123; console.log(&#x27;get: &#x27;, data.msg) return data.msg &#125;, // 当设置值的时候执行 set (newValue) &#123; console.log(&#x27;set: &#x27;, newValue) if (newValue === data.msg) &#123; return &#125; data.msg = newValue // 数据更改，更新 DOM 的值 document.querySelector(&#x27;#app&#x27;).textContent = data.msg &#125; &#125;)// 测试vm.msg = &#x27;Hello World&#x27; console.log(vm.msg) Vue 3.x Vue3.x改用Proxy替代Object.defineProperty。因为Proxy可以直接监听对象和数组的变化，并且有多达13种拦截方法。并且作为新标准将受到浏览器厂商重点持续的性能优化。 12345678910111213141516171819202122232425262728293031const data = [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;]const proxyData = new Proxy(data, &#123; get(target, key, receiver) &#123; // 只处理本身（非原型的）属性 const ownKeys = Reflect.ownKeys(target) if (ownKeys.includes(key)) &#123; console.log(&#x27;get&#x27;, key) // 监听 &#125; const result = Reflect.get(target, key, receiver) return result // 返回结果 &#125;, set(target, key, val, receiver) &#123; // 重复的数据，不处理 if (val === target[key]) &#123; return true &#125; const result = Reflect.set(target, key, val, receiver) console.log(&#x27;set&#x27;, key, val) // console.log(&#x27;result&#x27;, result) // true return result // 是否设置成功 &#125;, deleteProperty(target, key) &#123; const result = Reflect.deleteProperty(target, key) console.log(&#x27;delete property&#x27;, key) // console.log(&#x27;result&#x27;, result) // true return result // 是否删除成功 &#125;&#125;) Reflect作用： 和proxy能力一一对应 规范化，标准化，函数式 代替Object上的工具函数 12345678910const obj = &#123;a: 100, b: 200&#125;&#x27;a&#x27; in obj //trueReflect.has(obj,&#x27;a&#x27;) //truedelete obj.a //trueReflect.deleteProperty(obj,&#x27;a&#x27;) //trueObject.getOwnPropertyNames(obj) //[&quot;a&quot;,&quot;b&quot;]Reflect.owbKeys(obj) //[&quot;a&quot;,&quot;b&quot;] proxy创建响应式 Proxy只会代理对象的第一层，那么Vue3又是怎样处理这个问题的呢？ 判断当前Reflect.get的返回值是否为Object，如果是则再通过reactive方法做代理， 这样就实现了深度观测。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172// 创建响应式function reactive(target = &#123;&#125;) &#123; if (typeof target !== &#x27;object&#x27; || target == null) &#123; // 不是对象或数组，则返回 return target &#125; // 代理配置 const proxyConf = &#123; get(target, key, receiver) &#123; // 只处理本身（非原型的）属性 const ownKeys = Reflect.ownKeys(target) if (ownKeys.includes(key)) &#123; console.log(&#x27;get&#x27;, key) // 监听 &#125; const result = Reflect.get(target, key, receiver) // 深度监听 // 性能如何提升的？ return reactive(result) &#125;, set(target, key, val, receiver) &#123; // 重复的数据，不处理 if (val === target[key]) &#123; return true &#125; const ownKeys = Reflect.ownKeys(target) if (ownKeys.includes(key)) &#123; console.log(&#x27;已有的 key&#x27;, key) &#125; else &#123; console.log(&#x27;新增的 key&#x27;, key) &#125; const result = Reflect.set(target, key, val, receiver) console.log(&#x27;set&#x27;, key, val) // console.log(&#x27;result&#x27;, result) // true return result // 是否设置成功 &#125;, deleteProperty(target, key) &#123; const result = Reflect.deleteProperty(target, key) console.log(&#x27;delete property&#x27;, key) // console.log(&#x27;result&#x27;, result) // true return result // 是否删除成功 &#125; &#125; // 生成代理对象 const observed = new Proxy(target, proxyConf) return observed&#125;// 测试数据const data = &#123; name: &#x27;zhangsan&#x27;, age: 20, info: &#123; city: &#x27;beijing&#x27;, a: &#123; b: &#123; c: &#123; d: &#123; e: 100 &#125; &#125; &#125; &#125; &#125;&#125;const proxyData = reactive(data) Proxy 相比于 defineProperty 的优势 数组变化也能监听到 不需要深度遍历监听","categories":[],"tags":[]}],"categories":[],"tags":[]}