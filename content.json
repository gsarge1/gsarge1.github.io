{"meta":{"title":"Valar Dohaeris","subtitle":"","description":"世上只有一种真正的英雄主义,那就是认清生活的真相后依然热爱生活","author":"烨钬","url":"http://example.com","root":"/"},"pages":[],"posts":[{"title":"javascript语句","slug":"javascript语句","date":"2022-05-26T01:34:16.000Z","updated":"2022-05-26T02:26:25.459Z","comments":true,"path":"2022/05/26/javascript语句/","link":"","permalink":"http://example.com/2022/05/26/javascript%E8%AF%AD%E5%8F%A5/","excerpt":"","text":"语句表达式在 JavaScript 中是短语，那么语句就是整句命令。表达式用来计算出一个值，语句用来执行以使某件事发生。从本质上看，语句定义了 JavaScript 中的主要语法，语句通常使用一或多个关键字来完成给定任务。语句可以很简单，例如通知函数退出；也可以比较复杂，例如指定重复执行某个命令的次数。下表列出了 JavaScript 大部分语句的语法和用途： 语句 语法 用途 break break [label]; 退出最内层循环或者退出 switch 语句，又或者退出 label 指定的语句 case case expression: 在 switch 语句中标记一条语句 continue continue [label]; 重新开始最内层的循环或重新开始 label 指定的循环 debugger debugger; 断点器调试 default default; 在 switch 中标记默认的语句 do-while do statement while(expression); while 循环的一种替代形式 empty ; 什么都不做 for for(init;expr;incr) statement 简写的循环结构 for-in for(var in object) statement 遍历一个对象的属性 function function name([param[],...])&#123;statement&#125; 声明一个函数 if-else if (expression) statement1[else statement2] 执行 statement1 或者 statement2 label label:statement 给 statement 指定一个名字 label return return [expression]; 从函数返回一个值 switch switch(expression)&#123;statement&#125; 用 case 或者 default 语句标记的多分支语句 throw throw expression; 抛出异常 try try &#123;statement&#125;[catch &#123;handler statement&#125;][finally &#123;cleaup statement&#125;] 捕获异常 use strict &quot;use strict&quot; 对脚本和函数应用严格模式 var var name=[=expr][,...]; 声明并初始化一个或多个变量 while while(expression) statement 基本的循环结构 with with(object) statement 扩展作用域链 1)条件语句if-else 语句大多数编程语言中最为常用的一个语句就是 if-else 语句。以下是 if-else 语句的语法： 1if (condition) statement1 [else statement2] 其中的 condition 可以是任意表达式；而且对这个表达式求值的结果不一定是布尔值。JavaScript 会自动调用 Boolean() 转换函数将这个表达式的结果转换为一个布尔值。如果对 condition 求值的结果是 true，则执行 statement1，如果对 condition 求值的结果是 false，则执行 statement2。而且这两个语句既可以是一行代码，也可以是一个代码块（以一对花括号括起来的多行代码）。请看下面的例子： 12345if (i &gt; 25) console.log(&quot;Greater than 25.&quot;); // 单行语句else &#123; console.log(&quot;Less than or equal to 25.&quot;); // 代码块中的语句&#125; 业界普遍推崇的最佳实践是始终使用代码块，即使要执行的只有一行代码。因为这样可以消除人们的误解，否则可能让人分不清在不同条件下要执行哪些语句。 switch 语句switch 语句与 if 语句的关系最为密切，而且也是在其他语言中普遍使用的一种流控制语句。JavaScript 中 switch 语句的语法与其他基于 C 的语言非常接近，如下所示： 1234567891011switch (expression) &#123; case value: statement break; case value: statement break; case value: statement break; case value: statement break; default: statement&#125; switch 语句中的每一种情形的含义是：“如果表达式等于这个值（value），则执行后面的语句（statement）”。而 break 关键字会导致代码执行流跳出 switch 语句。如果省略 break 关键字，就会导致执行完当前 case 后，继续执行下一个 case。最后的 default 关键字则用于在表达式不匹配前面任何一种情形的时候，也相当于一个 else 语句。从根本上讲，switch 语句就是为了让开发人员免于编写像下面这样的代码： 123456789if (i === 25)&#123; console.log(&quot;25&quot;);&#125; else if (i === 35) &#123; console.log(&quot;35&quot;);&#125; else if (i === 45) &#123; console.log(&quot;45&quot;);&#125; else &#123; console.log(&quot;Other&quot;);&#125; 而与此等价的switch语句如下所示： 12345678910111213switch (i) &#123; case 25: console.log(&quot;25&quot;); break; case 35: console.log(&quot;35&quot;); break; case 45: console.log(&quot;45&quot;); break; default: console.log(&quot;Other&quot;);&#125; 通过为每个case后面都添加一个break语句，就可以避免同时执行多个case代码的情况。假如确实需要混合几种情形，不要忘了在代码中添加注释，说明你是有意省略了break关键字。 虽然 JavaScript 中的 switch 语句借鉴自其他语言，但这个语句也有自己的特色。首先，可以在 switch 语句中使用任何数据类型（在很多其他语言中只能使用数值），无论是字符串，还是对象都没有问题。其次，每个 case 的值不一定是常量，可以是变量，甚至是表达式。请看下面这两个例子： 12345678910111213141516171819202122232425switch (&quot;hello world&quot;) &#123; case &quot;hello&quot; + &quot; world&quot;: console.log(&quot;Greeting was found.&quot;); break; case &quot;goodbye&quot;: console.log(&quot;Closing was found.&quot;); break; default: console.log(&quot;Unexpected message was found.&quot;);&#125;var num = 25;switch (true) &#123; case num &lt; 0: console.log(&quot;Less than 0.&quot;); break; case num &gt;= 0 &amp;&amp; num &lt;= 10: console.log(&quot;Between 0 and 10.&quot;); break; case num &gt; 10 &amp;&amp; num &lt;= 20: console.log(&quot;Between 10 and 20.&quot;); break; default: console.log(&quot;More than 20.&quot;);&#125; switch 语句首先计算 switch 关键字后的表达式，然后按照从上到下的顺序计算每个 case 后的表达式，直到执行到 case 的表达式的值与 switch 的表达式的值相等时为止。由于对每个 case 的匹配操作实际上是 === 恒等运算符比较，而不是 == 相等运算符比较，因此，表达式和 case 的匹配并不会做任何类型转换。 2）循环while 语句while 语句属于前测试循环语句，也就是说，在循环体内的代码被执行之前，就会对出口条件求值。因引，循环体内的代码有可能永远不会被执行。以下是 while 语句的语法： 1while(expression) statement 下面是一个示例： 1234var i = 0;while (i &lt; 10) &#123; i += 2;&#125; do-while 语句do-while 语句是一种后测试循环语句，即只有在循环体中的代码执行之后，才会测试出口条件。换句话说，在对条件表达式求值之前，循环体内的代码至少会被执行一次。以下是 do-while 语句的语法： 123do &#123; statement&#125; while (expression); 下面是一个示例： 1234var i = 0;do &#123; i += 2;&#125; while (i &lt; 10); for 语句for 语句也是一种前测试循环语句，但它具有在执行循环之前初始化变量和定义循环后要执行的代码的能力。以下是 for 语句的语法： 1for (初始化变量; 条件表达式; 操作表达式) 循环体 下面是一个示例： 1234var count = 10;for (var i = 0; i &lt; count; i++)&#123; console.log(i);&#125; 这个 for 循环语句与下面的 while 语句的功能相同： 123456var count = 10;var i = 0;while (i &lt; count)&#123; console.log(i); i++;&#125; 由于 JavaScript 中不存在块级作用域，因此在循环内部定义的变量也可以在外部访问到。例如： 12345var count = 10;for (var i = 0; i &lt; count; i++)&#123; console.log(i);&#125;console.log(i); // 10 此外，for 语句中的初始化表达式、控制表达式和循环后表达式都是可选的。将这两个表达式全部省略，就会创建一个无限循环，例如： 12345// 无限循环for (;;) &#123; doSomething();&#125; for-in 语句for-in 语句是一种精准的迭代语句，可以用来枚举对象的属性。以下是 for-in 语句的语法： 1for (property in object) statement 下面是一个示例： 123for (var propName in window) &#123; console.log(propName);&#125; 在这个例子中，我们使用 for-in 循环来显示了 BOM 中 window 对象的所有属性。每次执行循环时，都会将 window 对象中存在的一个属性名赋值给变量 propName。这个过程会一直持续到对象中的所有属性都被枚举一遍为止。与 for 语句类似，这里控制语句中的 var 操作符也不是必需的。但是，为了保证使用局部变量，我们推荐上面例子中的这种做法。 JavaScript 对象的属性没有顺序。因此，通过 for-in 循环输出的属性名的顺序是不可预测的。具体来讲，所有属性都会被返回一次，但返回的先后次序可能会因浏览器而异。 如果表示要迭代的对象的变量值为 null 或 undefined，for-in 语句会抛出错误。虽然 ECMAScript 5 更正了这一行为；对这种情况不再抛出错误，而只是不执行循环体。为了保证最大限度的兼容性，建议在使用 for-in 循环之前，先检测确认该对象的值不是 null 或 undefined。 3）跳转break 和 continue 语句break 和 continue 语句用于在循环中精确地控制代码的执行。其中，break 语句会立即退出循环，强制继续执行循环后面的语句。而 continue 语句虽然也是立即退出循环，但退出循环后会从循环的顶部继续执行。请看下面的例子： 12345678910var num = 0;for (var i=1; i &lt; 10; i++) &#123; if (i % 5 == 0) &#123; break; &#125; num++;&#125;console.log(num); // 4 这个例子中的 for 循环会将变量 i 由1递增至 10。在循环体内，有一个 if 语句检查 i 的值是否可以被 5 整除（使用求模运算符）。如果是，则执行 break 语句退出循环。另一方面，变量 num 从 0 开始，用于记录循环执行的次数。在执行 break 语句之后，结果显示 4。也就是说，在变量 i 等于 5 时，循环总共执行了 4 次；而 break 语句的执行，导致了循环在 num 再次递增之前就退出了。如果在这里把 break 替换为 continue 的话，则可以看到另一种结果： 12345678910var num = 0;for (var i=1; i &lt; 10; i++) &#123;if (i % 5 == 0) &#123; continue; &#125; num++;&#125;console.log(num); // 8 例子的结果显示 8，也就是循环总共执行了 8 次。当变量 i 等于 5 时，循环会在 num 再次递增之前退出，但接下来执行的是下一次循环，即i的值等于 6 的循环。于是，循环又继续执行，直到 i 等于 10 时自然结束。而 num 的最终值之所以是 8，是因为 continue 语句导致它少递增了一次。 break 和 continue 语句都可以与 label 语句联合使用，从而返回代码中特定的位置。这种联合使用的情况多发生在循环嵌套的情况下，如下面的例子所示： 12345678910111213var num = 0;outermost:for (var i = 0; i &lt; 10; i++) &#123; for (var j = 0; j &lt; 10; j++) &#123; if (i == 5 &amp;&amp; j == 5) &#123; break outermost; &#125; num++; &#125;&#125;console.log(num); // 55 在这个例子中，outermost 标签表示外部的 for 语句。如果每个循环正常执行 10 次，则 num++ 语句就会正常执行 100 次。换句话说，如果两个循环都自然结束，num 的值应该是 100。但内部循环中的 break 语句带了一个参数：要返回到的标签。添加这个标签的结果将导致 break 语句不仅会退出内部的 for 语句（即使用变量 j 的循环），而且也会退出外部的 for 语句（即使用变量 i 的循环）。为此，当变量 i 和 j 都等于 5 时， num的值正好是 55。同样，continue 语句也可以像这样与 label 语句联用，如下面的例子所示： 12345678910111213var num = 0;outermost:for (var i = 0; i &lt; 10; i++) &#123; for (var j = 0; j &lt; 10; j++) &#123; if (i == 5 &amp;&amp; j == 5) &#123; continue outermost; &#125; num++; &#125;&#125;console.log(num); // 95 在这种情况下，continue 语句会强制继续执行循环，退出内部循环，执行外部循环。当 j 是 5 时，continue 语句执行，而这也就意味着内部循环少执行了 5 次，因此 num 的结果是 95。 虽然联用 break、continue 和 label 语句能够执行复杂的操作，但如果使用过度，也会给调试带来麻烦。在此，我们建议如果使用 label 语句，一定要使用描述性的标签，同时不要嵌套过多的循环。 return 语句return 语句的作用是指定函数调用后的返回值。return 语句的语法如下： 1return [expression]; 下面是一个示例： 12function square(x) &#123; return x*x; &#125; // 一个包含 return 语句的函数square(2); // 调用结果为 4 return 语句只能在函数体内出现，如果不是的话会报语法错误。当执行到 return 语句的时候，函数终止执行，并返回 expression 的值给调用程序。如果没有 return 语句，则函数调用仅依次执行函数体内的每一条语句直到函数结束，最后返回调用程序。这种情况下，调用表达式的结果是 undefined。return 语句经常作为函数内的最后一条语句出现，但并不是说要一定放在函数最后。return 语句可以单独使用而不必带有 expression，这样的话函数也会向调用程序返回 undefined。 由于 JavaScript 可以自动插入分号，因此在 return 关键字和它后面的表达式之间不能有换行。 4）其他with 语句with 语句的作用是将代码的作用域设置到一个特定的对象中。with 语句的语法如下： 1with (expression) statement; 定义 with 语句的目的主要是为了简化多次编写同一个对象的工作，如下面的例子所示： 123var qs = location.search.substring(1);var hostName = location.hostname;var url = location.href; 上面几行代码都包含 location 对象。如果使用 with 语句，可以把上面的代码改写成如下所示： 12345with(location)&#123; var qs = search.substring(1); var hostName = hostname; var url = href;&#125; 在这个重写后的例子中，使用 with 语句关联了 location 对象。这意味着在 with 语句的代码块内部，每个变量首先被认为是一个局部变量，而如果在局部环境中找不到该变量的定义，就会查询 location 对象中是否有同名的属性。如果发现了同名属性，则以 location 对象属性的值作为变量的值。 由于大量使用 with 语句会导致性能下降，同时也会给调试代码造成困难，因此在开发大型应用程序时，不建议使用 with 语句。严格模式下不允许使用 with 语句，否则将视为语法错误。 代码块代码块将多个语句组合为一个复合语句。代码块其实就是一系列语句，可以放在任何期待一个语句的地方： 12345&#123; x = Math.PI cx = Math.cos(x) console.log(&quot;cos(n)= &quot; + cx)&#125; 注意：1)它没有以分号结尾。块中的单条语句都以分号结尾，但块本身没有。2）块中的代码相对于包含它们的花括号缩进","categories":[{"name":"javascript","slug":"javascript","permalink":"http://example.com/categories/javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://example.com/tags/javascript/"}]},{"title":"vue响应式原理","slug":"vue响应式原理","date":"2019-05-25T09:28:36.000Z","updated":"2022-05-26T00:05:45.015Z","comments":true,"path":"2019/05/25/vue响应式原理/","link":"","permalink":"http://example.com/2019/05/25/vue%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8E%9F%E7%90%86/","excerpt":"","text":"数据驱动 数据响应式、双向绑定、数据驱动 数据响应式 数据模型仅仅是普通的 JavaScript 对象，而当我们修改数据时，视图会进行更新，避免了繁琐的 DOM 操作提高开发效率 双向绑定 数据改变，视图改变;视图改变，数据也随之改变 我们可以使用 v-model 在表单元素上创建双向数据绑定 数据驱动是Vue最独特的特性之一，MVVM表示的是Model-View-ViewModel 开发过程中仅需要关注数据本身，不需要关心数据是如何渲染到视图 Model：模型层，负责处理业务逻辑以及和服务器端进行交互 View：视图层：负责将数据模型转化为UI展示出来，可以简单的理解为HTML页面 ViewModel：视图模型层，用来连接Model和View，是Model和View之间的通信桥梁 数据响应式的核心原理Vue 2.x 核心是通过 ES5 的保护对象的 Object.defindeProperty 中的访问器属性中的 get 和 set 方法，data 中声明的属性都被添加了访问器属性，当读取 data 中的数据时自动调用 get 方法，当修改 data 中的数据时，自动调用 set 方法，检测到数据的变化，会通知观察者 Wacher，观察者 Wacher自动触发重新render 当前组件（子组件不会重新渲染）,生成新的虚拟 DOM 树，Vue 框架会遍历并对比新虚拟 DOM 树和旧虚拟 DOM 树中每个节点的差别，并记录下来，最后，加载操作，将所有记录的不同点，局部修改到真实 DOM树上 总结：Vue 采用数据劫持结合发布—订阅模式的方法，通过 Object.defineProperty() 来劫持各个属性的 setter，getter，在数据变动时发布消息给订阅者，触发相应的监听回调 Object.defineProperty()，那么它的用法是什么，以及优缺点是什么呢？ 可以检测对象中数据发生的修改 对于复杂的对象，层级很深的话，是不友好的，需要经行深度监听，这样子就需要递归到底，这也是它的缺点。 对于一个对象中，如果你新增加属性，删除属性，Object.defineProperty()是不能观测到的，那么应该如何解决呢？可以通过Vue.set()和Vue.delete()来实现。 1234567891011121314151617181920212223242526272829303132// 模拟 Vue 中的 data 选项 let data = &#123; msg: &#x27;hello&#x27;&#125;// 模拟 Vue 的实例 let vm = &#123;&#125;// 数据劫持:当访问或者设置 vm 中的成员的时候，做一些干预操作Object.defineProperty(vm, &#x27;msg&#x27;, &#123; // 可枚举(可遍历) enumerable: true, // 可配置(可以使用 delete 删除，可以通过 defineProperty 重新定义) configurable: true, // 当获取值的时候执行 get () &#123; console.log(&#x27;get: &#x27;, data.msg) return data.msg &#125;, // 当设置值的时候执行 set (newValue) &#123; console.log(&#x27;set: &#x27;, newValue) if (newValue === data.msg) &#123; return &#125; data.msg = newValue // 数据更改，更新 DOM 的值 document.querySelector(&#x27;#app&#x27;).textContent = data.msg &#125; &#125;)// 测试vm.msg = &#x27;Hello World&#x27; console.log(vm.msg) Vue 3.x Vue3.x改用Proxy替代Object.defineProperty。因为Proxy可以直接监听对象和数组的变化，并且有多达13种拦截方法。并且作为新标准将受到浏览器厂商重点持续的性能优化。 12345678910111213141516171819202122232425262728293031const data = [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;]const proxyData = new Proxy(data, &#123; get(target, key, receiver) &#123; // 只处理本身（非原型的）属性 const ownKeys = Reflect.ownKeys(target) if (ownKeys.includes(key)) &#123; console.log(&#x27;get&#x27;, key) // 监听 &#125; const result = Reflect.get(target, key, receiver) return result // 返回结果 &#125;, set(target, key, val, receiver) &#123; // 重复的数据，不处理 if (val === target[key]) &#123; return true &#125; const result = Reflect.set(target, key, val, receiver) console.log(&#x27;set&#x27;, key, val) // console.log(&#x27;result&#x27;, result) // true return result // 是否设置成功 &#125;, deleteProperty(target, key) &#123; const result = Reflect.deleteProperty(target, key) console.log(&#x27;delete property&#x27;, key) // console.log(&#x27;result&#x27;, result) // true return result // 是否删除成功 &#125;&#125;) Reflect作用： 和proxy能力一一对应 规范化，标准化，函数式 代替Object上的工具函数 12345678910const obj = &#123;a: 100, b: 200&#125;&#x27;a&#x27; in obj //trueReflect.has(obj,&#x27;a&#x27;) //truedelete obj.a //trueReflect.deleteProperty(obj,&#x27;a&#x27;) //trueObject.getOwnPropertyNames(obj) //[&quot;a&quot;,&quot;b&quot;]Reflect.owbKeys(obj) //[&quot;a&quot;,&quot;b&quot;] proxy创建响应式 Proxy只会代理对象的第一层，那么Vue3又是怎样处理这个问题的呢？ 判断当前Reflect.get的返回值是否为Object，如果是则再通过reactive方法做代理， 这样就实现了深度观测。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172// 创建响应式function reactive(target = &#123;&#125;) &#123; if (typeof target !== &#x27;object&#x27; || target == null) &#123; // 不是对象或数组，则返回 return target &#125; // 代理配置 const proxyConf = &#123; get(target, key, receiver) &#123; // 只处理本身（非原型的）属性 const ownKeys = Reflect.ownKeys(target) if (ownKeys.includes(key)) &#123; console.log(&#x27;get&#x27;, key) // 监听 &#125; const result = Reflect.get(target, key, receiver) // 深度监听 // 性能如何提升的？ return reactive(result) &#125;, set(target, key, val, receiver) &#123; // 重复的数据，不处理 if (val === target[key]) &#123; return true &#125; const ownKeys = Reflect.ownKeys(target) if (ownKeys.includes(key)) &#123; console.log(&#x27;已有的 key&#x27;, key) &#125; else &#123; console.log(&#x27;新增的 key&#x27;, key) &#125; const result = Reflect.set(target, key, val, receiver) console.log(&#x27;set&#x27;, key, val) // console.log(&#x27;result&#x27;, result) // true return result // 是否设置成功 &#125;, deleteProperty(target, key) &#123; const result = Reflect.deleteProperty(target, key) console.log(&#x27;delete property&#x27;, key) // console.log(&#x27;result&#x27;, result) // true return result // 是否删除成功 &#125; &#125; // 生成代理对象 const observed = new Proxy(target, proxyConf) return observed&#125;// 测试数据const data = &#123; name: &#x27;zhangsan&#x27;, age: 20, info: &#123; city: &#x27;beijing&#x27;, a: &#123; b: &#123; c: &#123; d: &#123; e: 100 &#125; &#125; &#125; &#125; &#125;&#125;const proxyData = reactive(data) Proxy 相比于 defineProperty 的优势 数组变化也能监听到 不需要深度遍历监听","categories":[{"name":"vue","slug":"vue","permalink":"http://example.com/categories/vue/"}],"tags":[{"name":"vue","slug":"vue","permalink":"http://example.com/tags/vue/"}]},{"title":"javascript表达式和操作符","slug":"javascript表达式和操作符","date":"2017-04-23T08:18:22.000Z","updated":"2022-05-26T02:13:21.260Z","comments":true,"path":"2017/04/23/javascript表达式和操作符/","link":"","permalink":"http://example.com/2017/04/23/javascript%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%92%8C%E6%93%8D%E4%BD%9C%E7%AC%A6/","excerpt":"","text":"表达式与操作符1）表达式表达式是由数字、运算符、数字分组符号（如括号）、自由变量和约束变量等以能求得数值的有意义排列方法所得的组合。JavaScript 表达式主要有以下几种形式： 原始表达式：常量、变量、保留字。 对象、数组初始化表达式：var obj=&#123;a:1,b:2&#125;;，var arr=[1,2,3];。 函数定义表达式：var fn=function()&#123;&#125;。 属性访问表达式：Math.abs。 调用表达式：alert(&#39;hello&#39;);。 对象创建表达式：new object();。 1）函数定义表达式函数定义表达式通常用关键字function,位于括号中的逗号分隔的0或多个标识符，以及一个位于花括号中的js代码块构成。 12345let square = function(x)&#123; return x*x;&#125;或function square(x)&#123; return x*x;&#125; 2）属性访问表达式属性访问表达式求值为对象属性或数组元素的值，其语法结构为 12expression.identifierexpression[identifier] 第一种属性访问语法是表达式后跟着一个句点和一个标识符。其中，表达式指定对象，标识符指定属性名。第二种属性访问语法是表达式后跟另一个位于方括号中的表达式。这第二个表达式指定属性名或数组元素的索引。 123456let o = &#123;x:1,y:&#123;z:3&#125;&#125;;let a = [o,4,[5,6]]o.x;o.y.za[1]a[0] 2）运算符JavaScript 中的运算符用于算术表达式、比较表达式、逻辑表达式、赋值表达式等。需要注意的是，大多数运算符都是由标点符号表示的，比如 + 和 =。而另外一些运算符则是由关键字表示的，比如 typeof 和 instanceof，关键字运算符和标点符号都是正规的运算符。 下表列出了 JavaScript 中所有的运算符，并按照运算符的优先级排序的，前面的运算符优先级要高于后面的运算符优先级，被空行分隔开来的运算符具有不同的优先级。标题为 A 的列表示运算符的结合性（Associativity），L 表示从左至右、R 表示从右至左，标题为 N 的列表示操作数的个数（Number）。 运算符 操作 A N ++ 前&#x2F;后增量 R 1 -- 前&#x2F;后增量 R 1 - 求反 R 1 + 转换为数字 R 1 ~ 按位求反 R 1 ! 逻辑非 R 1 delete 删除属性 R 1 typeof 检测类型 R 1 void 返回undefined R 1 * / % 乘，除，求模 L 2 + - 加，减 L 2 + 字符串连接 L 2 &lt;&lt; 左移位 L 2 &gt;&gt; 有符号右移 L 2 &gt;&gt;&gt; 无符号右移 L 2 &lt; &lt;= &gt; &gt;= 比较数字顺序 L 2 &lt; &lt;= &gt; &gt;= 比较字母顺序 L 2 instanceof 测试对象类 L 2 in 测试属性是否存在 L 2 == 判断相等 L 2 != 判断不等 L 2 === 判断恒等 L 2 !== 判断恒不等 L 2 &amp; 按位与 L 2 ^ 按位异或 L 2 ┃ 按位或 L 2 &amp;&amp; 逻辑与 L 2 ┃┃ 逻辑或 L 2 ?: 条件运算符 R 3 = 赋值 R 2 *= /= %= += -= &amp;= &lt;&lt;= &gt;&gt;= ^= ┃= &gt;&gt;&gt;= 运算且赋值 R 2 , 忽略第一个操作数， 返回第二个操作数 L 2 因为 | 是制表符，会导致格式混乱，所以表格中的 | 均以 ┃ 代替。 1）一元运算符（1）delete 运算符delete 运算符用来删除对象属性或者数组元素，如果删除成功或所删除的目标不存在，delete 将返回 true。然而，并不是所有的属性都可删除，一些内置核心和客户端属性是不能删除的，通过 var 语句声明的变量不能删除，通过 function 语句定义的函数也是不能删除的。例如： 1234567891011121314151617var o = &#123; x: 1, y: 2&#125;; // 定义一个对象console.log(delete o.x); // true，删除一个属性console.log(delete o.x); // true，什么都没做，x 在已上一步被删除console.log(&quot;x&quot; in o); // false，这个属性在对象中不再存在console.log(delete o.toString); // true，什么也没做，toString是继承来的console.log(delete 1); // true，无意义var a = [&quot;x&quot;,&quot;y&quot;,&quot;z&quot;]; // 定义一个数组console.log(2 in a); // true，下标为2的元素，在数组中存在console.log(delete a[2]); // true，删除下标为2的元素（最后一个数组元素）console.log(2 in a); // false，下标为2的元素，在数组中不再存在console.log(a.length); // 3，数组长度并不会因 delete 而改变console.log(a[2]); // undefined，下标为2的元素，位置被空了出来console.log(delete a); // false，通过 var 语句声明的变量不能删除function f(args)&#123;&#125; // 定义一个函数console.log(delete f); // false，通过 function 语句声明的函数不能删除 （2）void 运算符void 运算符可以应用于任何表类型的表达式，表达式会被执行，但计算结果会被忽略并返回 undefined。例如： 1234567void 0;void &quot;you are useless?&quot;;void false;void [];void /(useless)/ig;void function()&#123; console.log(&quot;you are so useless?&quot;); &#125;// always return undefined （3）typeof 运算符鉴于 JavaScript 是松散类型的，因此需要有一种手段来检测给定变量的数据类型，typeof 就是负责提供这方面信息的运算符。对一个值使用 typeof 运算符可能返回下列某个字符串： &quot;undefined&quot;，如果这个值未声明或已声明但未初始化。 &quot;boolean&quot;，如果这个值是布尔值。 &quot;string&quot;，如果这个值是字符串。 &quot;number&quot;，如果这个值是数值。 &quot;object&quot;，如果这个值是对象或 null。 &quot;function&quot;，如果这个值是函数。 下面是几个使用 typeof 运算符的例子： 1234var message = &quot;some string&quot;;console.log(typeof message); // &quot;string&quot;console.log(typeof(message)); // &quot;string&quot;console.log(typeof 95); // &quot;number&quot; 从以上例子可以看出，typeof 运算符既可以对变量使用，又可以对字面量使用。由于 typeof 是一个运算符而不是函数，因此例子中的圆括号尽管可以使用，但并不提倡。 typeof null 结果是 &quot;object&quot; 是历史遗留 Bug，在 ECMAScript 6 中，曾经有提案为历史平反, 将 typeof null 的值纠正为 &quot;null&quot;，但最后该提案被拒。理由是历史遗留代码太多，不如继续将错就错。 （4）++ -- 运算符++ -- 递增递减运算符借鉴自 C 语言，它们分前置型和后置型，作用是改变一个变量的值。例如： 12345var a = 5;console.log(a++); // 5console.log(++a); // 7console.log(a--); // 7console.log(--a); // 5 （5）+ - 运算符当 + - 作为一元运算符时，应用于数值，表示数值的正负。应用于非数值，先按 Number() 转型函数对这个值执行转换，再表示该值的正负。 （6）~ ! 运算符 ~ 按位非运算符，请参见下面「位运算符」。! 逻辑非运算符，请参见下面「逻辑运算符」。 2）乘性运算符JavaScript 定义了3个乘性运算符：乘法、除法和求模。这些运算符与 C 语言的相应运算符用途类似，只不过在操作数为非数值的情况下会执行自动的类型转换。如果参与乘法计算的某个操作数不是数值，后台会先使用 Number() 转型函数将其转换为数值。也就是说，空字符串将被当作 0，布尔值 true 将被当作 1。 （1）* 乘法运算符用于计算两个数值的乘积，在处理特殊值的情况下，乘法运算符遵循下列特殊的规则： 如果操作数都是数值，执行常规的乘法计算，即两个正数或两个负数相乘的结果还是正数，而如果只有一个操作数有符号，那么结果就是负数。如果乘积超过了 JavaScript 数值的表示范围，则返回 Infinity 或 -Infinity； 如果有一个操作数是 NaN，则结果是 NaN； 如果是 Infinity 与 0 相乘，则结果是 NaN； 如果是 Infinity 与非 0 数值相乘，则结果是 Infinity 或 -Infinity，取决于有符号操作数的符号； 如果是 Infinity 与 Infinity 相乘，则结果是 Infinity；如果有一个操作数不是数值，则在后台调用 Number()将其转换为数值，然后再应用上面的规则。 （2）/ 除法运算符用于计算两个数值的商，与乘法运算符类似，除法运算符对特殊的值也有特殊的处理规则。这些规则如下： 如果操作数都是数值，执行常规的除法计算，即两个正数或两个负数相除的结果还是正数，而如果只有一个操作数有符号，那么结果就是负数。如果商超过了 JavaScript 数值的表示范围，则返回 Infinity 或 -Infinity； 如果有一个操作数是 NaN，则结果是 NaN； 如果是 Infinity 被 Infinity 除，则结果是 NaN； 如果是零被零除，则结果是 NaN； 如果是非零的有限数被零除，则结果是 Infinity 或 -Infinity，取决于有符号操作数的符号； 如果是 Infinity 被任何非零数值除，则结果是 Infinity 或 -Infinity，取决于有符号操作数的符号； 如果有一个操作数不是数值，则在后台调用 Number() 将其转换为数值，然后再应用上面的规则。 （3）% 求模运算符用于计算两个数值的余数，与另外两个乘性运算符类似，求模运算符会遵循下列特殊规则来处理特殊的值： 如果操作数都是数值，执行常规的除法计算，返回除得的余数； 如果被除数是无穷大值而除数是有限大的数值，则结果是 NaN； 如果被除数是有限大的数值而除数是零，则结果是 NaN； 如果是 Infinity 被 Infinity 除，则结果是 NaN； 如果被除数是有限大的数值而除数是无穷大的数值，则结果是被除数； 如果被除数是零，则结果是零； 如果有一个操作数不是数值，则在后台调用 Number() 将其转换为数值，然后再应用上面的规则。 3）加性运算符加法和减法这两个加性运算符应该说是编程语言中最简单的算术运算符了。但是在 JavaScript 中，这两个运算符却都有一系列的特殊行为。与乘性运算符类似，加性运算符也会在后台转换不同的数据类型。然而，对于加性运算符而言，相应的转换规则还稍微有点复杂。 + 加法运算符如果两个运算符都是数值，执行常规的加法计算，然后根据下列规则返回结果： 如果有一个操作数是 NaN，则结果是 NaN； 如果是 Infinity 加 Infinity，则结果是 Infinity； 如果是 -Infinity 加 -Infinity，则结果是 -Infinity； 如果是 Infinity 加- Infinity，则结果是 NaN； 如果是 +0 加 +0，则结果是 +0； 如果是 -0 加 -0，则结果是 -0； 如果是 +0 加 -0，则结果是 +0; 如果有一个操作数不是数值，那么就要应用如下规则： 如果两个操作数都是字符串，则将第二个操作数与第一个操作数拼接起来； 如果只有一个操作数是字符串，则将另一个操作数转换为字符串，然后再将两个字符串拼接起来。 如果有一个操作数是对象、数值或布尔值，则调用它们的 toString() 方法取得相应的字符串值，然后再应用前面关于字符串的规则。对于 undefined 和 null，则分别调用 String() 函数并取得字符串 &quot;undefined&quot; 和 &quot;null&quot;。 如果是 null 加 null，则结果是 0; 如果是 undefined 加 undefined，则结果是 NaN; 下面来举几个例子： 12345678910var result1 = 5 + 5; // 两个数值相加console.log(result1); // 10var result2 = 5 + &quot;5&quot;; // 一个数值和一个字符串相加console.log(result2); // &quot;55&quot;var num1 = 5;var num2 = 10;var message = &quot;The sum of 5 and 10 is &quot; + num1 + num2;console.log(message); // &quot;The sum of 5 and 10 is 510&quot;，如何修改？ - 减法运算符如果两个运算符都是数值，执行常规的减法计算，然后根据下列规则返回结果： 如果有一个操作数是 NaN，则结果是 NaN； 如果是 Infinity 减 Infinity，则结果是 NaN； 如果是 -Infinity 减 -Infinity，则结果是 NaN； 如果是 Infinity 减 -Infinity，则结果是 Infinity； 如果是 -Infinity 减 Infinity，则结果是 -Infinity； 如果是 +0 减 +0，则结果是 +0； 如果是 +0 减 -0，则结果是 -0； 如果是 -0 减 -0，则结果是 +0； 如果有一个操作数不是数值，那么就要应用如下规则： 如果有一个操作数是字符串、布尔值、null 或 undefined，则先在后台调用 Number() 函数将其转换为数值，然后再根据前面的规则执行减法计算。如果转换的结果是 NaN，则减法的结果就是 NaN； 如果有一个操作数是对象，则调用对象的 valueOf() 方法以取得表示该对象的数值。如果得到的值是 NaN，则减法的结果就是 NaN。如果对象没有 valueOf() 方法，则调用其 toString()方法并将得到的字符串转换为数值。 如果是 null 减 null，则结果是 0; 如果是 undefined 减 undefined，则结果是 NaN; 下面来举几个例子： 123456var result1 = 5 - true; // 4，因为true被转换成了1var result2 = NaN - 1; // NaNvar result3 = 5 - 3; // 2var result4 = 5 - &quot;&quot;; // 5，因为&quot;&quot; 被转换成了0var result5 = 5 - &quot;2&quot;; // 3，因为&quot;2&quot;被转换成了2var result6 = 5 - null; // 5，因为null被转换成了0 4）等值运算符确定两个变量是否相等是编程中的一个非常重要的操作。在比较简单数据类型之间的相等性时，问题还比较简单。但在涉及到对象之间的比较时，问题就变得复杂了。最早的 JavaScript 中的相等和不等运算符会在执行比较之前，先将对象转换成相似的类型。后来，有人提出了这种转换到底是否合理的质疑。最后，JavaScript 的解决方案就是提供两组运算符：相等和不相等（先转换再比较），恒等和不恒等（仅比较而不转换）。 == != 运算符== != 这两个运算符都会先转换操作数（通常称为强制转型），然后再比较它们的相等性。在转换不同的数据类型时，相等和不相等运算符遵循下列基本规则： 如果有一个操作数是布尔值，则在比较相等性之前先将其转换为数值（false 转换为 0，而 true 转换为 1）； 如果一个操作数是字符串，另一个操作数是数值，在比较相等性之前先将字符串转换为数值； 如果一个操作数是对象，另一个操作数不是，则调用对象的 valueOf() 方法，用得到的基本类型值按照前面的规则进行比较； null 和 undefined 是相等的。要比较相等性之前，不能将 null 和 undefined 转换成其他任何值。 如果有一个操作数是 NaN，则相等运算符返回 false，而不相等运算符返回 true。重要提示：即使两个操作数都是 NaN，相等运算符也返回 false；因为按照规则，NaN 不等于 NaN。 如果两个操作数都是对象，则比较它们是不是同一个对象。如果两个操作数都指向同一个对象，则相等运算符返回 true；否则，返回 false。 列出了一些特殊情况及比较结果： 1234567891011null == undefined // true&quot;NaN&quot; == NaN // false5 == NaN // falseNaN == NaN // falseNaN != NaN // truefalse == 0 // truetrue == 1 // truetrue == 2 // falseundefined == 0 // falsenull == 0 // false&quot;5&quot; == 5 // true === !== 运算符除了在比较之前不转换操作数之外，恒等和不恒等运算符与相等和不相等运算符没有什么区别。它只在两个操作数未经转换就相等的情况下返回 true，如下面的例子所示： 1234var result1 = (&quot;55&quot; == 55); // true，因为转换后相等var result2 = (&quot;55&quot; === 55); // false，因为不同的数据类型不相等var result3 = (null == undefined) // true，因为它们是类似的值var result4 = (null === undefined) // false，因为它们是不同类型的值 5）关系运算符&lt; &gt; &lt;= &gt;= 运算符&lt; 小于、&gt; 大于、&lt;= 小于等于、 &gt;= 大于等于 这几个关系运算符用于对两个值进行比较返回一个布尔值。与 JavaScript 中的其他运算符一样，当关系运算符的操作数使用了非数值时，也要进行数据转换或完成某些奇怪的操作。以下就是相应的规则。 如果两个操作数都是数值，则执行数值比较。 如果两个操作数都是字符串，则比较两个字符串对应的字符编码值（可以通过字符串的 charCodeAt() 函数获取字符编码值）。 如果一个操作数是数值，则将另一个操作数转换为一个数值，然后执行数值比较。 如果一个操作数是对象，则调用这个对象的 valueOf() 方法，用得到的结果按照前面的规则执行比较。如果对象没有 valueOf()方法，则调用 toString()方法，并用得到的结果根据前面的规则执行比较。 如果一个操作数是布尔值，则先将其转换为数值，然后再执行比较。 请思考下面几个例子的结果是如何得出的： 1234567var result1 = &quot;Brick&quot; &lt; &quot;alphabet&quot;; // truevar result2 = &quot;brick&quot; &lt; &quot;alphabet&quot;; // falsevar result3 = &quot;23&quot; &lt; &quot;3&quot;; // truevar result4 = &quot;23&quot; &lt; 3; // falsevar result5 = &quot;a&quot; &lt; 3; // falsevar result6 = NaN &lt; 3; // falsevar result7 = NaN &gt;= 3; // false in 运算符in 运算符希望它的左操作数是一个字符串或可以转换为字符串，希望它的右操作数是一个对象。如果右侧的对象拥有一个名为左操作数值的属性名，那么表达式返回 true，例如： 123456789var point = &#123; x:1, y:1 &#125;; // 定义一个对象&quot;x&quot; in point // true，对象有一个名为&quot;x&quot;的属性&quot;z&quot; in point // false，对象中不存在名为&quot;z&quot;的属性&quot;toString&quot; in point // true，对象继承了toString()方法var data = [7,8,9]; // 拥有三个元素的数组&quot;0&quot; in data // true，数组包含元素&quot;0&quot;1 in data // true，数字转换为字符串3 in data // false，没有索引为3的元素 instanceof 运算符instanceof 运算符希望左操作数是一个对象，右操作数标识对象的类。如果左侧的对象是右侧类的实例，则表达式返回 true；否则返回 false。后面会讲 JavaScript 中对象的类是通过初始化它们的构造函数来定义的。这样的话，instanceof 的右操作数应当是一个函数。比如： 123456789var d = new Date(); // 通过 Date() 构造函数来创建一个新对象d instanceof Date; // true，d 是由 Date() 创建的d instanceof Object; // true，所有的对象都是 Object 的实例d instanceof Number; // false，d 不是一个 Number 对象var a = [1, 2, 3]; // 通过数组字面量的写法创建一个数组a instanceof Array; // true，a 是一个数组a instanceof Object; // true，所有的数组都是对象a instanceof RegExp; // false，数组不是正则表达式 需要注意的是，所有的对象都是 Object 的实例。当通过 instanceof 判断一个对象是否是一个类的实例的时候，这个判断也会包含对「父类」的检测。如果 instanceof 的左操作数不是对象的话，instanceof 返回 false。如果右操作数不是函数，则抛出一个类型错误异常。 6）逻辑运算符逻辑运算符是对操作数进行布尔算术运算，经常和关系运算符一起配合使用，逻辑运算符将多个关系表达式组合起来组成一个更复杂的表达式。 &amp;&amp; 逻辑与逻辑与操作可以应用于任何类型的操作数，而不仅仅是布尔值。在有一个操作数不是布尔值的情况下，逻辑与操作不一定返回布尔值；此时，它遵循下列规则： 如果第一个操作数是对象，则返回第二个操作数； 如果第二个操作数是对象，则只有在第一个操作数的求值结果为 true 的情况下才会返回该对象； 如果两个操作数都是对象，则返回第二个操作数； 如果有一个操作数是 null，则返回 null； 如果有一个操作数是 NaN，则返回 NaN； 如果有一个操作数是 undefined，则返回 undefined。 逻辑与操作属于短路操作，即如果第一个操作数能够决定结果，那么就不会再对第二个操作数求值。对于逻辑与操作而言，如果第一个操作数是 false，无论第二个操作数是什么值，结果都不再可能是 true 了。 12console.log(3 &gt; 5 &amp;&amp; 3 &gt; 2); // falseconsole.log(3 &lt; 5 &amp;&amp; 3 &gt; 2); // true || 逻辑或与逻辑与操作相似，如果有一个操作数不是布尔值，逻辑或也不一定返回布尔值；此时，它遵循下列规则： 如果第一个操作数是对象，则返回第一个操作数； 如果第一个操作数的求值结果为 false，则返回第二个操作数； 如果两个操作数都是对象，则返回第一个操作数； 如果两个操作数都是 null，则返回 null； 如果两个操作数都是 NaN，则返回 NaN； 如果两个操作数都是 undefined，则返回 undefined。 与逻辑与运算符相似，逻辑或运算符也是短路运算符。也就是说，如果第一个操作数的求值结果为 true，就不会对第二个操作数求值了。 12console.log(3 &gt; 5 || 3 &gt; 2); // true console.log(3 &gt; 5 || 3 &lt; 2); // false ! 逻辑非逻辑非操作可以应用于任何类型的操作数，无论这个值是什么数据类型，这个运算符都会返回一个布尔值。逻辑非运算符首先会将它的操作数转换为一个布尔值，然后再对其求反。逻辑非运算符遵循下列规则： 如果操作数是一个对象，返回 false； 如果操作数是一个空字符串，返回 true； 如果操作数是一个非空字符串，返回 false； 如果操作数是数值 0，返回 true； 如果操作数是任意非 0 数值（包括 Infinity），返回 false； 如果操作数是 null，返回 true； 如果操作数是 NaN，返回 true； 如果操作数是 undefined，返回 true。 下面几个例子展示了应用上述规则的结果： 123456console.log(!false); // trueconsole.log(!&quot;blue&quot;); // falseconsole.log(!0); // trueconsole.log(!NaN); // trueconsole.log(!&quot;&quot;); // trueconsole.log(!12345); // false 逻辑非运算符也可以用于将一个值转换为与其对应的布尔值。而同时使用两个逻辑非运算符，实际上就会模拟 Boolean() 转型函数的行为。其中，第一个逻辑非操作会基于无论什么操作数返回一个布尔值，而第二个逻辑非操作则对该布尔值求反，于是就得到了这个值真正对应的布尔值。当然，最终结果与对这个值使用 Boolean() 函数相同，例如： 12345console.log(!!&quot;blue&quot;); //trueconsole.log(!!0); //falseconsole.log(!!NaN); //falseconsole.log(!!&quot;&quot;); //falseconsole.log(!!12345); //true 7）位运算符在 JavaScript 中，当对数值应用位运算符时，后台会发生如下转换过程：64位的数值被转换成32位数值，然后执行位操作，最后再将32位的结果转换回64位数值。这个转换过程导致了一个严重的副效应，即在对特殊的 NaN 和 Infinity 值应用位操作时，这两个值都会被当成 0 来处理。如果对非数值应用位运算符，会先使用 Number() 函数将该值转换为一个数值，然后再应用位操作，得到的结果将是一个数值。 ~ 按位非简单的理解，对任一数值 x 进行按位非操作的结果为 -(x+1)。例如： 1234567891011console.log(~null); // -1console.log(~undefined); // -1console.log(~0); // -1console.log(~&#123;&#125;); // -1console.log(~[]); // -1console.log(~(1/0)); // -1console.log(~false); // -1console.log(~true); // -2console.log(~1.2543); // -2console.log(~4.9); // -5console.log(~(-2.999)); // 1 &amp; 按位与按位与操作就是将两个数值的每一位对齐，两个数值的对应位都是 1 时才返回 1，任何一位是 0，结果都是 0。如下表所示： 第一个数值的位 第二个数值的位 结果 1 1 1 1 0 0 0 1 0 0 0 0 | 按位或按位或操作就是将两个数值的每一位对齐，两个数值只要有一个位是 1 就返回 1，只在两个位都是 0 的情况下才返回 0。如下表所示： 第一个数值的位 第二个数值的位 结果 1 1 1 1 0 1 0 1 1 0 0 0 ^ 按位异或按位异或与按位或的不同之处在于，两个数值只有一个 1 时才返回 1，如果对应的两位都是 1 或都是 0，则返回 0。 第一个数值的位 第二个数值的位 结果 1 1 0 1 0 1 0 1 1 0 0 0 &lt;&lt; 左移这个运算符会将数值的所有位向左移动指定的位数。例如： 12var oldValue = 2; // 等于二进制的 10var newValue = oldValue &lt;&lt; 5; // 等于二进制的 1000000，十进制的 64 注意，左移不会影响操作数的符号位。换句话说，如果将 -2 向左移动 5 位，结果将是 -64，而非 64。 &gt;&gt; 有符号的右移这个运算符会将数值向右移动，但保留符号位（即正负号标记）。 12var oldValue = 64; // 等于二进制的 1000000var newValue = oldValue &gt;&gt; 5; // 等于二进制的 10 ，即十进制的 2 &gt;&gt;&gt; 无符号的右移这个运算符会将数值的所有32位都向右移动。对正数来说，无符号右移的结果与有符号右移相同。 12var oldValue = 64; // 等于二进制的 1000000var newValue = oldValue &gt;&gt;&gt; 5; // 等于二进制的 10 ，即十进制的 2 无符号右移运算符会把负数的二进制码当成正数的二进制码。而且，由于负数以其绝对值的二进制补码形式表示，因此就会导致无符号右移后的结果非常之大。 12var oldValue = -64; // 等于二进制的 11111111111111111111111111000000var newValue = oldValue &gt;&gt;&gt; 5; // 等于十进制的 134217726 8）赋值运算符简单的赋值运算符由等于号 = 表示，其作用就是把右侧的值赋给左侧的变量，如下面的例子所示： 1var num = 10; 如果在等于号 = 前面再添加乘性运算符、加性运算符或位运算符，就可以完成复合赋值操作。这种复合赋值操作相当于是对下面常规表达式的简写形式： 12var num = 10;num += 10; // 等同于 num = num + 10; 每个主要算术运算符（以及个别的其他运算符）都有对应的复合赋值运算符。这些运算符如下所示： 乘&#x2F;赋值 *=； 除&#x2F;赋值 /=； 模&#x2F;赋值 %=； 加&#x2F;赋值 +=； 减&#x2F;赋值 -=； 左移&#x2F;赋值 &lt;&lt;=； 有符号右移&#x2F;赋值 &gt;&gt;=； 无符号右移&#x2F;赋值 &gt;&gt;&gt;=。 设计这些运算符的主要目的就是简化赋值操作，使用它们不会带来任何性能的提升。 9）条件运算符? : 条件运算符应该算是 JavaScript 中最灵活的一种运算符了，而且它遵循与 Java 中的条件运算符相同的语法形式，如下面的例子所示： 1variable = boolean_expression ? true_value : false_value; 10）逗号运算符逗号运算符多用于声明多个变量；但除此之外，逗号运算符还可以用于赋值。在用于赋值时，逗号运算符总会返回表达式中的最后一项，如下面的例子所示： 1var num = (5, 1, 4, 8, 0); // num 的值为 0 由于 0 是表达式中的最后一项，因此 num 的值就是 0。虽然逗号的这种使用方式并不常见，但这个例子可以帮我们理解逗号的这种行为。","categories":[{"name":"javascript","slug":"javascript","permalink":"http://example.com/categories/javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://example.com/tags/javascript/"}]},{"title":"javascript类型、值和变量","slug":"javascript类型、值和变量","date":"2017-04-23T00:08:27.000Z","updated":"2022-05-26T02:13:12.654Z","comments":true,"path":"2017/04/23/javascript类型、值和变量/","link":"","permalink":"http://example.com/2017/04/23/javascript%E7%B1%BB%E5%9E%8B%E3%80%81%E5%80%BC%E5%92%8C%E5%8F%98%E9%87%8F/","excerpt":"","text":"类型、值和变量JavaScript类型可以分为两类：原始类型和对象类型。 原始类型包括数值、字符串、布尔值、特殊值null、undefined。其中null和undefined不是数值、字符串或布尔值，通常被认为 是各自特殊类型的唯一成员。 对象是属性的集合，其中每个属性都有一个名字和一个值。 注意：任何不是数值、字符串、布尔值、符号、null和undefined的值都是对象。 在内存管理方面，js解析器会执行自动垃圾收集。当程序无法以任何方式引用这个值时，解释器会自动释放它占用的内存。 1）数值 整数 Number用于表示整数和近似实数。 Number 类型是 JavaScript 中最令人关注的数据类型，这种类型使用 IEEE 754 格式来表示整数和浮点数值（浮点数值在某些语言中也被称为双精度数值）。和其他编程语言不同，JavaScript 中的所有数字均用浮点数值表示。 在 JavaScript 中进行算术计算时，所有以八进制和十六进制表示的数值最终都将被转换成十进制数值。例如： 1234567var a = 10; // 十进制var b = 023; // 八进制var c = 0x12ac; // 十六进制0xff = 255；（15*16+15） // 十六进制0xbadcafe // =&gt;195939070 // 十六进制console.log(b); // 19console.log(c); // 4780 八进制第一位必须是0，后面跟八进制序列0到7，如果超出了范围，则忽略前导0，后面的数值当做十进制解析，例如：089会被解析为89。（八进制字面量在严格模式下是无效的，会抛出错误。） 十六进制前两位必须是 0x 或 0X，后跟十六进制序列09、af（10~15）（不区分大小写），如果超出了范围，则会报语法错误。 浮点数 所谓浮点数值，就是该数值中必须包含一个小数点，并且小数点后面必须至少有一位数字。虽然小数点前面可以没有整数，但我们不推荐这种写法。例如： 123var a = 1.1;var b = 0.1;var c = .1; // 有效，但不推荐 JavaScript 会不失时机的将浮点数转换成整数。例如： 12var a = 5.; // 解析成整数5var b = 5.0; // 解析成整数5 对于极大或者极小的数值，可采用科学技术法（也称e表示法）。JavaScript 会将那些小数点后面带有6个零以上的小于1的浮点数值转换为以e表示法表示的数值。例如： 123var a = 3.14e7; // 等于31400000var b = 3.14E-7; // 等于0.000000314console.log(0.0000003); // 3e-7 浮点数值的最高精度是17位小数，但在进行算术计算时其精确度远远不如整数，例如： 1console.log(0.1 + 0.2); // 0.30000000000000004 这个舍入误差会导致无法测试特定的浮点数值，因此，永远不要测试某个特定的浮点数值。 Js使用的IEEE~754浮点法是一种二进制表示法，这种表示法可以精确地表示如1&#x2F;2,1&#x2F;8,1&#x2F;1024等分数。然而我们常用的十进制 分数：1&#x2F;10,1&#x2F;100等等，二进制浮点表示法无法精确表示。 123456例如：let x = .3 - .2 ;//这个数值只能非常近似地表示0.1，但无法精确的表示。let y = .2 - .1;x ===y; ==&gt;falsex ===.1; ==&gt;falsey ===.1; ==&gt;true 正无穷、负无穷 由于内存限制，JavaScript 能表示的数值范围从 Number.MIN_VALUE 到 Number.MAX_VALUE，并将超出范围的数转换成 Number.POSITIVE_INFINITY 或 Number.NEGATIVE_INFINITY。0作为除数是不会报错的，正数除以0返回正无穷，负数除以0返回负无穷，0除以0返回NaN。例如： 123456789console.log(Number.MAX_VALUE); // 最大数 1.7976931348623157e+308console.log(Number.MIN_VALUE); // 最小数 5e-324console.log(Number.POSITIVE_INFINITY); // 正无穷 Infinityconsole.log(Number.NEGATIVE_INFINITY); // 负无穷 -Infinityconsole.log( 1 / 0); // Infinityconsole.log(-1 / 0); // -Infinity JavaScript 提供了 isFinite() 函数，来确定一个数是不是有穷的。例如： 12console.log(isFinite(100)); // trueconsole.log(isFinite(Infinity)); // false NaN NaN（not a number），是一个特殊的数值。之所以称它为「非数值」，是因为它不能参与算数运算，任何涉及 NaN 的操作都返回 NaN。并且 NaN 与任何值都不相等（包括自身）。例如： 12345678console.log(typeof NaN); // &quot;number&quot;console.log(0 / 0); // NaNconsole.log(NaN - NaN); // NaNconsole.log(Infinity - Infinity); // NaNvar a = NaN;console.log(a === a); // false JavaScript 提供了 isNaN() 函数，来确定一个数是不是 NaN。例如： 12345console.log(isNaN(100)); // falseconsole.log(isNaN(&quot;100&quot;)); // falseconsole.log(isNaN(true)); // falseconsole.log(isNaN(&quot;sss&quot;)); // trueconsole.log(isNaN(NaN)); // true Number()、parseInt()、parseFloat()转型函数 isNaN() 函数在接收到一个值之后，会尝试使用转型函数 Number() 将这个值转换为数值，转换规则如下： undefined 转换为 NaN； null 转换为 0； true 转换为 1、false 转换为 0； number 整数转换为十进制，小数不变； string 如果只包含十进制数和小数，则返回对应的数值，如果只包含八进制数，则忽略前导0返回剩余部分，如果只包含十六进制，则返回十进制数，空字符串转换为0，其它字符串转换为 NaN； 如果 object 具有 valueOf() 方法，且返回一个原始值（5种简单数据类型），则将这个原始值转换为数字，并返回这个数字；否则，如果 object 具有 toString() 方法，且返回一个原始值，则将这个原始值转换为数字，并返回这个数字；否则，抛出一个类型错误异常。 由于 Number() 转型函数在转换字符串时不够理想，因此还有两个专门用来转换字符串的函数 parseInt() 和 parseFloat() 函数。 parseInt() 函数会忽略字符串前面的空格，直至找到第一个非空格字符，只要第一个非空格字符不是数字或者正负号，一律返回 NaN， 如果第一个非空格字符是数字字符，parseInt() 会继续解析第二个字符，直到解析完所有后续字符或者遇到了一个非数字字符。例如： 123console.log(parseInt(&quot;&quot;)); // NaN（Number(&quot;&quot;)返回 0）console.log(parseInt(&quot;123S&quot;)); // 123console.log(parseInt(&quot;12.4&quot;)); // 12 parseFloat() 函数也会忽略字符串前面的空格，直至找到第一个非空格字符，只要第一个非空格字符不是数字或者正负号或者小数点，一律返回 NaN， 如果第一个非空格字符是上述字符之一，parseFloat() 会继续解析第二个字符，直到解析完所有后续字符或者遇到了一个非浮点数值。例如： 12console.log(parseFloat(&quot;098.2&quot;)); // 98.2console.log(parseFloat(&quot;123.23.23&quot;)); // 123.23 2）字符串字符串是16位值的不可修改的有序序列，其中每个值都表示一个Unicode字符。 在Js中可以使用单引号、双引号或者反引号(‘ ‘ ,” “,&#96;&#96;)包含起来来表示字符串，双引号和反引号可以出现在由单引号定界的字符 串中，同理由双引号和反引号定界的字符串里也可以包含另外两种引号。 12345&quot; &quot; //空字符串&#x27;testing&#x27;&quot;3.14&quot;&quot;Wouldn&#x27;t you prefer o&#x27;Reilly&#x27;s Books&quot;`&quot;she said &#x27;hi&#x27;&quot;,he said` 转义序列 12345678910\\0 Null字符\\b 退格符\\t 水平制表符\\n 换行符\\f 进制符\\r 回车符\\&quot; 双引号\\&#x27; 单引号\\\\ 反斜杠\\xnn 由2位16进制数字nn指定的Unicode字符 转义字符可出现在字符串中的任意位置，且长度为1。如要在字符串中显示 \\ ，则必须使用 \\ 进行转义。例如： 12console.log(&quot;\\n\\\\&quot;.length); // 2console.log(&quot;\\\\hello&quot;); // &quot;\\hello&quot;（长度为6） 大部分值都可以使用继承而来的 toString()方法转换为字符串，但 undefined 和 null 值没有这个方法。对数值使用 toString() 方法时，可以传入一个数字基数，以此输出对应进制的字符串值。例如： 1234567console.log(true.toString()); // &quot;true&quot;var num = 10;console.log(num.toString()); // &quot;10&quot;console.log(num.toString(2)); // &quot;1010&quot;console.log(num.toString(8)); // &quot;12&quot;console.log(num.toString(16)); // &quot;a&quot; 在不知道要转换的值是不是 undefined 或 null 的情况下，还可以使用转型函数 String()，这个函数能够将任何类型的值转换为字符串。String() 函数遵循下列转换规则： 如果值有 toString() 方法，则调用该方法（没有参数）并返回相应的结果； 如果值是 undefined，则返回 &quot;undefined&quot;； 如果值是 null，则返回 &quot;null&quot;。 12345var value;console.log(String(10)); // &quot;10&quot;console.log(String(true)); // &quot;true&quot;console.log(String(null)); // &quot;null&quot;console.log(String(value)); // &quot;undefined&quot; 3）布尔值Boolean 类型是 JavaScript 中使用得最多的一种类型，该类型只有两个字面值：true 和 false。需要注意的是，他们是区分大小写的，也就是说 True 和 False（以及其他的混合大小写形式）都不是 Boolean 值，只是标识符。 虽然 Boolean 类型的字面值只有两个，但 JavaScript 中所有类型的值都能使用 if 语句或 Boolean() 函数转换为对应的 Boolean 值，例如： 123456var message = &quot;Hello world!&quot;;if (message)&#123; console.log(&quot;Value is true.&quot;); // 被执行&#125;var messageAsBoolean = Boolean(message);console.log(messageAsBoolean); // true 下表给出了各种数据类型及其对应的转换规则。 数据类型 转换为true的值 转换为false的值 Undefined - undefined Null - null Boolean true false String 任何非空字符串 “”（空字符串） Number 任何非零数字值（包括无穷大） 0和NaN Object 任何对象 - 4）null和undefinedUndefined 类型只有1个值，即 undefined。使用 var 声明变量但未对其加以初始化时，这个变量的值就是 undefined，直接使用未声明的变量会产生错误。对未声明或已声明但未初始化的变量执行 typeof 运算符会返回 &quot;undefined&quot; 值，例如： 1234567var message; // 这个变量声明之后默认取得了 undefined 值// var age // 这个变量并没有声明console.log(message); // &quot;undefined&quot;console.log(age); // 产生错误console.log(typeof message); // &quot;undefined&quot;console.log(typeof age); // &quot;undefined&quot; Null 类型也只有1个值，即 null。它用来表示值的空缺。你可以认为 undefined 是表示系统级的、出乎意料的或类似错误的值的空缺，而 null 是表示程序级的、正常的或在意料之中的值的空缺。在下列场景中应当使用 null。 用来初始化一个变量，这个变量可能赋值为一个对象。 用来和一个已经初始化的变量比较，这个变量可以是也可以不是一个对象。 当函数的参数期望是对象时，作用参数传入。 当函数的返回值期望是对象时，作用返回值传出。 在下列场景中不应当使用 null。 不要使用 null 来检测是否传入了某个参数。 不要使用 null 来检测一个未初始化的变量。 5）全局对象全局对象的属性是全局性定义的标识符，可以在js程序的任何地方使用。js解释器启动后都会创建一个新的全局对象并为其添加一组初始的属性。 6）对象和数组JavaScript 中所有对象都继承自 Object 类型，每个对象都具有下列基本的属性和方法： constructor：保存着用于创建当前对象的函数（构造函数）。 hasOwnProperty()：用于检查给定的属性在当前对象实例中是否存在。 propertyIsEnumerable()：用于检查给定的属性是否能够使用for-in语句来枚举。 isPrototypeOf()：用于检查对象是否是传入对象的原型。 toString() 方法：返回对象的字符串表示。 toLocaleString()：返回对象的本地字符串表示。 valueOf()：返回对象的字符串、数值或布尔值表示（通常与toString()方法的返回值相同）。 Object 本质上是由一组无序的名值对组成，「名称」部分是一个 JavaScript 字符串，「值」部分可以是任何 JavaScript 的数据类型（包括对象和方法）。这使用户可以根据具体需求，创建出相当复杂的数据结构。 以下两种方法都可以创建一个空对象，这两种方法在语义上是相同的。第二种更方便的方法叫作「对象字面量」法。这也是 JSON 格式的核心语法，一般我们优先选择第二种方法。例如： 12var obj = new Object();var obj = &#123;&#125;; // 好的写法 「对象字面量」也可以用来在对象实例中定义一个对象： 12345678var obj = &#123; name: &quot;Carrot&quot;, &quot;for&quot;: &quot;Max&quot;, details: &#123; color: &quot;orange&quot;, size: 12 &#125;&#125; 对象的属性可以通过链式（chain）表示方法进行访问： 12obj.details.color; // orangeobj[&quot;details&quot;][&quot;size&quot;]; // 12 完成创建后，对象属性可以通过如下两种方式进行赋值和访问： 12345obj.name = &quot;Simon&quot; // 赋值var name = obj.name; // 访问obj[&quot;name&quot;] = &quot;Simon&quot;; // 赋值var name = obj[&quot;name&quot;]; // 访问 对象不同于原始值，对象是可修改的，即他们的值可以改变； 123456let object = &#123; x:1&#125;对象的属性访问：object.xlet arr = [1,2,3]数组的访问：arr[0] 对象不是按值比较的，两个不同的对象即使拥有完全相同的属性和值，它们也不相等。同样，两个不同的数组，即使每个元 素都相同，顺序也相同，它们也不相等。 1234let o = &#123;x:1&#125;,p = &#123;x:1&#125;o===p =&gt;falselet a = [],b = [];a===b =&gt;false 对象被称作引用类型，以区别于js的原始类型。对象值就是引用，对象是按引用比较的。两个对象值当且仅当它们引用同一个 底层对象时，才是相等的。 7）变量声明与赋值变量是通过var或let关键字声明的 1234let i;let sum;var i ;var sum; 也可以使用一条var&#x2F;let语句声明多个变量； 12let i,sum;var i,sum; 声明变量的同时也为其赋值是一个好的编程习惯； 12let msg = &quot;Hello World&quot;;let i = 0;j = 0;k = 0; 如果在var&#x2F;let语句中不为变量指定初始值，变量也会被声明，但在赋值之前它的值是undefined。 const是用来声明常量的，常量在声明是必须初始化且值不能改变，尝试给常量重新赋值会抛出TypeError 12const H0 = 74;const C = 299792.458 变量的作用域是程序源代码中的一个区域，在这个区域内变量有定义。通过let和const声明的变量和常量具有块作用域。这意味着它们只在let和const语句所在的代码块中有定义。 1234console.log(i);//抛出错误if(true)&#123; let i = 0;&#125; 在同一个作用域中使用多个let或const声明同一个名字是语法错误。在嵌套作用域中声明同名变量是合法的（最好不要这么做） 1234567const x = 1;if(x === 1)&#123; let x = 2; console.log(2)//打印2&#125;console.log(x);//打印1，回到全局作用域let x = 3;//报错 使用var和let声明的区别： 使用var声明的变量不具有块作用域，这种变量的作用域仅限于包含函数的函数体，无论它们在函数中嵌套的层次有多深。 如果在函数体外使用var声明，会声明一个全局变量。通过var声明的全局变量可以通过globalThis引用，因此，如果在函数外部写了var x &#x3D;2,则相当于globalThis.x &#x3D; 2; 使用var多次声明同名变量是合法的。 var声明变量的特性是作用域提升。在使用var声明变量时，该声明会被提高到包含函数的顶部。但变量的初始化仍然在代码所在位置完成，只有变量的定义转移到了函数顶部。","categories":[{"name":"javascript","slug":"javascript","permalink":"http://example.com/categories/javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://example.com/tags/javascript/"}]},{"title":"javascript词法结构","slug":"javascript词法结构","date":"2017-04-22T13:22:48.000Z","updated":"2022-05-26T02:13:17.088Z","comments":true,"path":"2017/04/22/javascript词法结构/","link":"","permalink":"http://example.com/2017/04/22/javascript%E8%AF%8D%E6%B3%95%E7%BB%93%E6%9E%84/","excerpt":"","text":"词法结构1）区分大小写JavaScript 是区分大小写的。也就是说，关键字、变量、函数名和所有的标识符（identifier）都必须采取一致的大小写形式。 比如，关键字 while 必须写成 while，而不能写成 While 或者 WHILE。同样，online、Online、OnLine、ONLINE 是4个不同的 变量名。 但需要注意的是，HTML 并不区分大小写。由于它和客户端 JavaScript 联系紧密，因此这点区别很容易混淆。许多客户端 JavaScript 对象和属性与他们所表示的 HTML 标签和属性名相同。在 HTML 中，这些标签和属性名可以使用大写也可以是小 写，而在 JavaScript 中则必须是小写。例如，在 HTML 中设置事件处理程序时，onclick 属性可以写成 onClick，但在 JavaScript 代码中，必须使用小写的 onclick。 1234var userName = &#x27;张三&#x27;;var username = &#x27;李四&#x27;;console.log(userName);console.log(username) 2）注释JavaScript 使用 C 风格的注释，包括单行注释和块级注释。单行注释以两个斜杠 // 开头，块级注释以一个斜杠和一个星号 /* 开头，以一个星号和一个斜杠 */ 结尾。下面都是合法的 JavaScript 注释： 12345// 这是单行注释/*** * 这是多行注释 * 这是多行注释***/ 虽然上面注释中的第二和第三行都以一个星号开头，但这不是必须的，纯粹是为了提高注释的可读性 3）字面量所谓字面量（也可称直接量，Literal values），就是程序中直接使用的数据值。字面量只代表自身，不存储在特定位置。 JavaScript 中的字面量有：字符串、数字、布尔值、对象、数组、函数、正则表达式，以及特殊的 null 值。 12345678910&quot;hello world&quot; // 字符串123 // 数字1.2 // 小数true // 布尔值false // 布尔值/javascript/gi // 正则表达式null // 空&#123; name: &#x27;stone&#x27;, age: 20&#125; // 对象[ 1, 2, 3, 4, 5, 6, 7, 8 ] // 数组function()&#123; console.log(&#x27;good&#x27;); &#125; // 函数 4）标识符标识符用于在js代码中命名常量，变量，属性，函数和类，以及某些循环提供标记。 标识符命名规则 由数字、字母、下划线或$（美元符）组成； 不能以数字开头；并且区分大小写； 不能用关键字，保留字命名； 1234567//正确的命名方式my_name;_username;$str//错误的命名方式.myname1user 5）关键字和保留字ECMAScript 3 描述了一组具有特定用途的关键字，这些关键字可用于表示控制语句的开始或结束，或者用于执行特定操作 等。按照规则，关键字是语言保留的，不能用作标识符。以下是 ECMAScript 3 的全部关键字： 123456break delete function return typeofcase do if switch varcatch else in this voidcontinue false instanceof throw whiledebugger finally new true withdefault for null try ECMAScript 3 还将 Java 的所有关键字都作为自己的保留字，保留字也是不能当初标识符。尽管保留字还没有任何特定的用途，但他们有可能在将来被用作关键字： 123456abstract double goto native staticboolean enum implements package superbyte export import private synchronizedchar extends int protected throwsclass final interface public transientconst float long short volatile ECMAScript 5 把非严格模式下的保留字缩减为： 12class enum extends superconst export import ECMAScript 5 在严格模式下的保留字为： 123implements package publicinterface private staticlet protected yield 注意，let 和 yield 是 ECMAScript 5 新增的保留字，其他保留字都是 ECMAScript 3 定义的。为了保证兼容性，任何时候都不建议使用 ECMAScript 5 新增的保留字 let 和 yield 。 ECMAScript 还预定义了很多全局变量和函数，也应当避免把它们用作标识符： 12345678arguments Error Math RegExpArray eval NaN StringBoolean EvalError Number SyntaxErrorDate Function Object TypeErrordecodeURI Infinity parseFloat undefineddecodeURIComponent isFinite parseInt URIErrorencodeURI isNaN RangeErrorencodeURIComponent JSON ReferenceError JavaScript 的具体实现可能定义独有的全局变量和函数，每一种特定的 JavaScript 运行环境都有自己的一个全局属性列表，这一点是需要牢记的。 6）可选的分号js使用分号(;)分割语句，这对于保持代码的清晰很重要：如果没有分隔符，一条语句的结尾可能是另一条语句的开头。 js中如果两条语句分别写在两行，通常可以省略它们之间的分号。 123例如：var a = 4;var b = 3; 像这种方式可以省略分号。 如果是下面这种情况，必须加分号 1var a = 4;b = 3; 7）严格模式在 ECMAScript 5 引入了严格模式（strict mode）的概念。严格模式是为 JavaScript 定义了一种不同的解析与执行模式。在严格模式下，ECMAScript 3 中的一些不确定的行为将得到处理，而且对某些不安全的操作也会抛出错误。要在整个脚本中启用严格模式，可以在顶部添加如下代码： 1&quot;use strict&quot;; 这行代码看起来像是字符串，而且也没有赋值给任何变量，但其实它是一个编译指示（pragma），用于告诉支持的 JavaScript 引擎切换到严格模式。这是为了不破坏 ECMAScript 3 语法而特意选定的语法。 在函数内部的第一行包含这条编译指示，也可以指定函数在严格模式下执行： 1234function doSomething()&#123; &quot;use strict&quot;; // 函数体&#125;","categories":[{"name":"javascript","slug":"javascript","permalink":"http://example.com/categories/javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://example.com/tags/javascript/"}]}],"categories":[{"name":"javascript","slug":"javascript","permalink":"http://example.com/categories/javascript/"},{"name":"vue","slug":"vue","permalink":"http://example.com/categories/vue/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://example.com/tags/javascript/"},{"name":"vue","slug":"vue","permalink":"http://example.com/tags/vue/"}]}